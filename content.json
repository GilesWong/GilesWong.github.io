{"posts":[{"title":"代码随想录算法训练营第11天 | 20. 有效的括号，1047. 删除字符串中的所有相邻重复项，150. 逆波兰表达式求值","text":"20. 有效的括号 代码随想录链接 题目 LeetCode-20 给定一个只包含了()6种字符的字符串，判断该字符串中的括号是否满足左右匹配。 自己的想法 遇到左侧符号[({就进栈，遇到右侧符号])}就判断栈顶是否为对应的左侧符号，若是则将左侧符号弹出，若不匹配，则不满足条件。若遍历完成后，栈中仍有元素，则也不满足条件。 题解 12345678910111213141516171819202122232425class Solution {private: stack&lt;char&gt; cs;public: bool isPair(char a, char b) { // 判断a是否为b的对应左侧符号 if (a == '(' &amp;&amp; b == ')') return true; if (a == '[' &amp;&amp; b == ']') return true; if (a == '{' &amp;&amp; b == '}') return true; return false; } bool isValid(string s) { for (char c : s) { // 遍历字符串中的字符 if (c == '(' || c == '{' || c == '[') cs.push(c); // 若为左侧字符，则入栈 else { // 若为右侧字符 if (cs.empty()) return false; // 栈中没有内容，不匹配 char topChar = cs.top(); // 判断栈顶符号是否和当前的右侧符号匹配 if (isPair(topChar, c)) cs.pop(); else return false; } } if (!cs.empty()) return false; // 遍历完成后，栈若不为空，则仍不满足条件 return true; }}; 1047. 删除字符串中的所有相邻重复项 代码随想录链接 题目 LeetCode-1047 去除字符串中所有的相同相邻字符。 自己的想法 遍历给定的字符串，设遍历获得的字符为c，若c和新的结果字符串末尾的字符相同，则将结果字符串的末尾字符取出；若不同，则将c拼接在新的字符串的结尾。实际上将字符串当做了一个栈。 题解 1234567891011121314class Solution {public: string removeDuplicates(string s) { string result; // 初始化一个结果字符串 for (char c : s) { // 遍历给定的字符串 if (result.empty() || result.back() != c) { // 若字符串为空或者字符串末尾字符不等于当前遍历到的字符 result.push_back(c); // 将该字符加入结果字符串 } else { result.pop_back(); // 否则就将结果字符串的末尾字符去除 } } return result; }}; 150. 逆波兰表达式求值 代码随想录链接 题目 LeetCode-150 根据逆波兰表达式，求该表达式的值。 自己的想法 Yet Anther Problem Appeared in WANGDAO. 设两个栈，一个用于存储运算数，一个用于暂存运算符。遍历表达式，遇到运算数就将数据压栈，遇到运算符时，先查看运算符的栈栈顶的运算符，若当前运算符的顺序高于栈顶运算符时，则将运算符入栈，否则取运算数栈顶两个数字，使用当前运算符进行运算，并将结果压入运算数栈中。遍历完成后若运算符栈仍有运算符，继续取出做运算。最后返回运算数栈的栈顶数字即可。 题解 123456789101112131415161718192021222324252627282930313233class Solution {public: bool hasPriority(char a, char b) { // 对比运算符优先级 if ((a == '*' || a == '/') &amp;&amp; (b == '+' || b == '-')) return true; return false; } int evalRPN(vector&lt;string&gt;&amp; tokens) { stack&lt;int&gt; nums; stack&lt;char&gt; ops; for (string s : tokens) { if (s != &quot;+&quot; &amp;&amp; s != &quot;-&quot; &amp;&amp; s != &quot;*&quot; &amp;&amp; s != &quot;/&quot;) nums.push(stoi(s)); // 将遇到的每个运算数入栈 else { char c = s[0]; if (ops.empty() || !hasPriority(s[0], ops.top())) { // 满足进行运算的条件 int a = nums.top(); nums.pop(); int b = nums.top(); nums.pop(); int num = 0; if (c == '+') num = a + b; else if (c == '-') num = b - a; else if (c == '*') num = a * b; else if (c == '/') num = b / a; nums.push(num); } else { ops.push(c); } } } return nums.top(); }};","link":"/algorithm-train-day11/"},{"title":"代码随想录算法训练营第10天 | 栈和队列理论基础，232.用栈实现队列，225.用队列实现栈","text":"栈和队列理论基础 栈是先进后出的数据结构，队列是先进先出的结构。如图所示。 C++中的STL有三儿比较普遍的版本： HP STL，是C++ STL的第一个实现版本，而且开放源代码。 P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。 SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。 C++的栈和队列不是一个容器，而是一个容器适配器，其内部的数据存储形式可以由不同的其他数据实现，如vector, deque, list等。 目前使用最广泛的SGI STL中，deque是默认的栈的底层实现。开发者也可以指定栈的底层实现。 1std::stack&lt;int, std::vector&lt;int&gt; &gt; stack; // 使用vector为底层容器的栈 队列的情况一样，SGI STL中队列一样是以deque为默认情况下的底部结构。也可以手动指定： 1std::queue&lt;int, std::list&lt;int&gt;&gt; queue; // 定义以list为底层容器的队列 232.用栈实现队列 代码随想录链接 题目 LeetCode-232 使用栈实现队列。又是在王道上做过的题 自己的想法 使用两个栈，A栈负责接收输入的数据，在遇到取队首或者出队操作时，若B栈为空，将A栈的元素依次弹出并压入B栈，此时B栈栈顶即为“队首”，若B栈不为空，直接操作B栈栈顶即可。 解法 12345678910111213141516171819202122232425262728293031323334353637class MyQueue {private: stack&lt;int&gt; in, out; // 用于接收输入数据和输出数据的两个栈public: MyQueue() { } void push(int x) { in.push(x); // 直接放入in栈中 } int pop() { if (out.empty()) { // 若输出栈out为空 while (!in.empty()) { // 将in栈中的所有元素弹出并压入out栈 out.push(in.top()); in.pop(); } } if (!out.empty()) { // 当out栈不为空时，取值并弹出元素 int val = out.top(); out.pop(); return val; } return -1; } int peek() { int frontVal = this -&gt; pop(); // 调用已经写好的pop函数来获得队首值 out.push(frontVal); // 将值放置到原位置上 return frontVal; } bool empty() { return in.empty() &amp;&amp; out.empty(); }}; 225.用队列实现栈 代码随想录链接 题目 LeetCode-225 使用队列来实现栈。 自己的想法 重点在处理出栈操作。思路是将队列中的元素不断出队，直到原来在队尾（即“栈顶”）的元素到达队首，再对队首进行出队操作即可。 解法 123456789101112131415161718192021222324252627282930313233343536class MyStack {private: queue&lt;int&gt; q;public: MyStack() { } void push(int x) { // “压栈”操作，直接进队 q.push(x); } int pop() { int size = q.size(); // 获得元素个数 int tmp; while (--size) { // 重复（队长 - 1）次 tmp = q.front(); // 队首出队并重新入队 q.pop(); q.push(tmp); } int val = q.front(); // 取此时队首并返回 q.pop(); return val; } int top() { int topVal = this -&gt; pop(); // 重复利用上面的函数，获得“栈顶” q.push(topVal); // 将该元素重新入队，复原栈 return topVal; } bool empty() { return q.empty(); }};","link":"/algorithm-train-day10/"},{"title":"代码随想录算法训练营第14天 | 二叉树理论基础，二叉树遍历","text":"二叉树理论基础 一个节点指向左右两个孩子节点构成的树状结构。 二叉树的种类 满二叉树 一棵二叉树只有度为0和度为2的节点，且度为0的节点都在同一层上时，该二叉树为满二叉树。深度为k的满二叉树，节点一定有\\(2 ^k - 1\\)个。 满二叉树，图源代码随想录 完全二叉树 除了最底层节点可能没填满以外，每层节点都达到了最大值，且最底层节点都集中在左侧。 完全二叉树 二叉搜索树 二叉搜索树是个有序树，其左子树上的节点的值均小于根节点的值，右子树上的值均大于根节点的值，且左右子树也是二叉搜索树。 二叉搜索树 平衡二叉搜索树 平衡二叉搜索树实在二叉搜索树的基础上，添加以下要求： 为空树或者左右子树高度差不大于1 左右子树都是平衡二叉搜索树 平衡二叉搜索树 C++中map, set, multimap, multiset的底层实现都是平衡二叉搜索树，所以map, set的增删操作时间都是\\(O(logn)\\)。unordered_set、unordered_map 的实现是哈希表。 二叉树的存储方式 可以链式存储，也可以顺序存储 链式存储 使用链表的形式，通过左右孩子指针完成链接。 链式存储二叉树 顺序存储 就是使用数组来存储二叉树。若父节点的索引为\\(i\\)，其左孩子节点索引为\\(2 * i + 1\\)，右孩子节点索引为\\(2 * i + 2\\)。 二叉树的遍历方式 深度优先遍历 优先向深度递增的方向访问。可分为前序遍历、中序遍历、后序遍历。 广度优先遍历 优先访问同一深度的节点。有层次遍历。 二叉树的定义 12345struct TreeNode { int data; TreeNode *left; TreeNode *right;}; 二叉树递归遍历 例题: 前序遍历 中序遍历 后序遍历 递归遍历的写法比较简单，按照前中后三种遍历方式的定义来写即可。 前序遍历： 12345678910111213141516class Solution {private: void preOrderTravel(TreeNode *root, vector&lt;int&gt; &amp;result) { if (root == NULL) return; result.push_back(root -&gt; val); // 先访问该节点 preOrderTravel(root -&gt; left, result); // 再访问左右节点 preOrderTravel(root -&gt; right, result); }public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (root == NULL) return result; preOrderTravel(root, result); return result; }}; 中序遍历: 12345678910111213141516class Solution {private: void inOrderTravel(TreeNode *root, vector&lt;int&gt; &amp;result) { if (!root) return; inOrderTravel(root -&gt; left, result); // 先访问左节点 result.push_back(root -&gt; val); // 再访问中间节点 inOrderTravel(root -&gt; right, result); // 最后访问右节点 }public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; inOrderTravel(root, result); return result; }}; 后序遍历: 12345678910111213141516class Solution {private: void postOrderTravel(TreeNode *root, vector&lt;int&gt; &amp;result) { if (root == NULL) return; postOrderTravel(root -&gt; left, result); // 先访问左节点 postOrderTravel(root -&gt; right, result); // 再访问右节点 result.push_back(root -&gt; val); // 最后访问中间节点 }public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; postOrderTravel(root, result); return result; }}; 二叉树迭代遍历 使用迭代来完成二叉树的遍历也是一个重点.二叉树的迭代遍历中,最主要的部分是对栈的调用. 前序遍历: 1234567891011121314151617class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (root == NULL) return result; stack&lt;TreeNode*&gt; st; // 用来遍历节点的栈 st.push(root); // 将根节点入栈 while (!st.empty()) { // 栈不为空时 TreeNode *node = st.top(); // 取栈顶并出栈 st.pop(); result.push_back(node -&gt; val); // 访问节点 if (node -&gt; right) st.push(node -&gt; right); // 左右子节点存在时,先压入右子节点,再压入左子节点 if (node -&gt; left) st.push(node -&gt; left); } return result; }}; 中序遍历: 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; // 中序遍历中处理顺序和访问顺序不一致,需要额外指针辅助 while (cur != NULL || !st.empty()) { // 当指针不为空或者栈不为空时 if (cur) { // 如果指针不为空 st.push(cur); // 指针节点压栈,指针左移 cur = cur -&gt; left; } else { // 若指针为空,意味着遇到了一颗子树遍历完成,需要进行中间节点的访问 cur = st.top(); st.pop(); result.push_back(cur -&gt; val); cur = cur -&gt; right; // 访问中间节点完毕后,指针右移 } } return result; }}; 后序遍历: 后序遍历的顺序是左右中,可以通过中右左的顺序逆转来完成. 123456789101112131415161718class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; stack&lt;TreeNode*&gt; st; st.push(root); while (!st.empty()) { // 与前序遍历的代码相似,不过交换了左右节点的压栈顺序 TreeNode *cur = st.top(); st.pop(); result.push_back(cur -&gt; val); if (cur -&gt; left) st.push(cur -&gt; left); if (cur -&gt; right) st.push(cur -&gt; right); } reverse(result.begin(), result.end()); // 逆转访问记录来获得目标顺序的记录 return result; }}; 二叉树统一迭代法 上面的迭代法写的方式不够统一. 下面是三种遍历比较统一的写法. 前序遍历: 12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (root == NULL) return result; stack&lt;TreeNode*&gt; st; st.push(root); // 压入根节点 while (!st.empty()) { // 栈不为空时 TreeNode *node = st.top(); // 取栈顶 if (node) { // 若栈顶元素不是空指针,则弹出并将不为空的右指针和左指针压入 st.pop(); if (node -&gt; right) st.push(node -&gt; right); if (node -&gt; left) st.push(node -&gt; left); st.push(node); // 再压入节点本身 st.push(NULL); // 压入一个空指针,表示需要访问该节点 } else { // 栈顶是空指针时 st.pop(); node = st.top(); // 获得需要访问的节点并进行访问 st.pop(); result.push_back(node -&gt; val); } } return result; }}; 中序遍历: 12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (root == NULL) return result; stack&lt;TreeNode*&gt; st; st.push(root); // 压入根节点 while (!st.empty()) { // 栈不为空时 TreeNode *node = st.top(); // 取栈顶 if (node) { // 若栈顶元素不是空指针,则弹出并将不为空的右指针,节点指针和访问标记,左指针压入 st.pop(); if (node -&gt; right) st.push(node -&gt; right); st.push(node); // 压入节点本身 st.push(NULL); // 压入一个空指针,表示需要访问该节点 if (node -&gt; left) st.push(node -&gt; left); } else { // 栈顶是空指针时 st.pop(); node = st.top(); // 获得需要访问的节点并进行访问 st.pop(); result.push_back(node -&gt; val); } } return result; }}; 后序遍历: 12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (root == NULL) return result; stack&lt;TreeNode*&gt; st; st.push(root); // 压入根节点 while (!st.empty()) { // 栈不为空时 TreeNode *node = st.top(); // 取栈顶 if (node) { // 若栈顶元素不是空指针,则弹出并将节点指针和访问标记,不为空的右指针,左指针压入 st.pop(); st.push(node); // 压入节点本身 st.push(NULL); // 压入一个空指针,表示需要访问该节点 if (node -&gt; right) st.push(node -&gt; right); if (node -&gt; left) st.push(node -&gt; left); } else { // 栈顶是空指针时 st.pop(); node = st.top(); // 获得需要访问的节点并进行访问 st.pop(); result.push_back(node -&gt; val); } } return result; }};","link":"/algorithm-train-day14/"},{"title":"代码随想录算法训练营第13天 | LeetCode - 239.滑动窗口最大值，347.前 K 个高频元素，栈和队列总结","text":"239.滑动窗口最大值 代码随想录链接 题目 LeetCode 239 在给定的一个数组中，进行一个大小为k的滑动窗口的移动，将每次移动过程中窗口的最大值保存下来并返回。 自己的思路 暴力法，然后Time Limit Exceeded. 使用一个队列，随着窗口的移动，队列也同时移动，并且队列的队首应该是当前窗口中的最大值。 要实现这样一个数据结构，需要自己定义一个队列并进行维护。这个队列只需要维护可能成为最大值的元素，保证队列里的元素从大到小进行排列。 在pop时，如果窗口移出的元素等于单调队列的出口元素，则将该元素从队列弹出，否则不进行任何操作；在push时，若窗口加入的元素大于队尾元素，则将队尾的元素依次取出，直到对空或队尾元素大于窗口加入的元素，再将该元素push入队。这样操作后，队首即为当前窗口的最大值。 为了实现这样一个数据结构，即满足需要在队首队尾进行操作的条件，使用deque来实现这个队列最合适。 关于deque和queue的区别，可以参照这个文章 解法 12345678910111213141516171819202122232425262728293031323334353637class MonotonicQueue { // 单调队列private: deque&lt;int&gt; que; // 使用deque实现public: void pop(int val) { if (!que.empty() &amp;&amp; que.front() == val) { // 当队列不为空且队首等于滑动窗口移出的值时，弹出队首 que.pop_front(); } } void push (int val) { while (!que.empty() &amp;&amp; val &gt; que.back()) { // 若不满足队尾元素大于窗口加入的元素的条件，就不断弹出队尾直到满足条件后再将该值加入队伍 que.pop_back(); } que.push_back(val); } int front() { // 设计的队列的队首在任意时刻都是对应时刻滑动窗口中的最大值 return que.front(); }};class Solution {public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { MonotonicQueue mq; vector&lt;int&gt; result; for (int i = 0; i &lt; k; i++) mq.push(nums[i]); // 将前k个数据加入 result.push_back(mq.front()); // 取前k个数据的最大值 for (int i = k; i &lt; nums.size(); i++) { // 使用一个for循环来移动窗口 mq.pop(nums[i - k]); // 从队列中移出滑动窗口移出的值 mq.push(nums[i]); // 将滑动窗口中新加入的值加入队列 result.push_back(mq.front()); // 取此时队列的最大值，并放入结果数组中 } return result; }}; 该方法的时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(k)\\)。 347.前 K 个高频元素 代码随想录链接 题目 LeetCode 347 给定一个数组和一个数字K，返回在该数组中出现频率最高的前k个数字。 自己的思路 统计元素的出现次数可以使用map来实现，而按照出现次数来排列前k个元素可以使用优先级队列。 为什么不用快排来对所有出现的元素的频率进行排序？因为我们最后只求前k个，可以只维护前k个可能的元素就好。 优先级队列在默认情况下是使用大顶堆进行排序，在这个题目中，如果每次更新大顶堆时，都将最大的元素弹出，不能保留高频元素。所以要使用小顶堆，将最小的元素弹出，剩下的才是最大的元素。 解法 1234567891011121314151617181920212223242526272829class MinHeapComp { // 根据map的结构定义大小如何对比public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt; &amp;rhs) { return lhs.second &gt; rhs.second; }};class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; map; for (int i : nums) { // 将所有元素的出现次数进行统计 map[i]++; } priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, MinHeapComp&gt; que; // 使用优先级队列来实现小顶堆排序 for (auto it = map.begin(); it != map.end(); it++) { // 遍历map，将map中的值推入 que.push(*it); if (que.size() &gt; k) { // 并弹出多余的元素 que.pop(); } } vector&lt;int&gt; result(k); for (int i = k - 1; i &gt;= 0; i--) { // 不断取小顶堆的值，以倒序的方式，放入结果数组中 result[i] = que.top().first; que.pop(); } return result; }}; 栈和队列总结 理论基础 栈和队列都是容器适配器，其底层实现可以有: vector deque list 不同的实现方式，对于数据的实际存储方式是有影响的。C++中，栈和队列的默认底层实现都是deque。 栈与队列相互实现 例如用栈来实现队列，用队列来实现栈，这种题目考察的是对于栈和队列特性的了解和使用。 例题: 栈实现队列 队列实现栈 括号匹配问题 这是使用栈来解决的经典问题。 例题： 括号匹配问题 字符串去重 将字符串按顺序放到一个串中，若要放入的字符与栈顶相同，就丢弃这两个字符。 例题： 字符串去重 逆波兰表达式 按照逆波兰表达式的顺序求出对应式子的答案，也是栈的经典应用题目。 例题： 逆波兰表达式求解 滑动窗口最大值 这个题目中一个比较重要的应用是单调队列，即单调递增或单调递减的队列。 例题： 滑动窗口最大值 求前k个高频元素 这个题目里面着重讲了优先级队列，优先级队列其实就是个堆，内部元素自动按照元素的权值进行排列。 求前K个高频元素","link":"/algorithm-train-day13/"},{"title":"2021级西安交通大学计算机专硕上岸经验","text":"个人情况 计算机科班, 双非, 无科研经历, 做过两个小的外包项目, 绩点4.1, 20%左右 四六级大一过的, 四级600分, 六级558分 初试成绩:政治75, 英语二86, 数学二126, 专业课912 119, 总分 406分, 初试排名目测是25左右 最后总排名15~20. 去年在王道论坛看了20各位学长的经验贴, 得到了许多帮助. 现在把自己的一些心得写一下, 希望能帮助到备考的你. 仅供参考. 初试准备 正式开始准备基本上是从6月初开始的,去学校提供的考研教室,每天差不多7点起,7-9月份晚上到8点,之后就去锻炼. 10月份起就6点半起,到9点结束学习. 相比着之前发帖的大佬,我觉得我的学习效率可能远不如他. 考研有一个复习的法则: 多次, 全面. 政治 20年的特殊形势, 在政治卷子上的影响就体现在各个老师押题押的都很准(因为不得不考这些),导致最后大家的分数普遍较高.同时也就是说, 大家的政治主要靠的还是考前的一个月突击, 在此之前政治不要开始过早过晚, 月初就可. 我自己用的是徐涛老师的核心考案, 听徐涛老师的强化班的课(徐涛老师的课可能是那段时间快乐的源泉之一),另外买了肖秀荣老师的1000题,听一章课,做一章选择题,大题不用做.虽然题和课不是同一个老师的,但是在章节分布上还是差不多的,这样搭配没问题的. (私以为的)重点来了: 1000题上做过的选择题,要定时进行复习(主要是重做). 我推荐使用一些辅助记忆的方法来完成,比如说艾宾浩斯遗忘曲线等. 我使用的是iPad上面的软件(开发者把广告费结一下谢谢), 卡片只需要添加哪一页哪一题即可,然后按照查阅计划重复做. 11月份等肖8出来之后, 开始做肖8的选择题, 做法和1000题一样,尽量把所有选择题都搞懂. 大题的话B站找带背视频(我看的空卡的). 肖4出来之后,选择题还是全部搞懂,大题试着自己做一下,同样也是找带背视频,背下来. 省流助手: - 9月初开始就行 - 徐涛 - 徐涛强化班 - 肖秀荣1000题 - 1000题的错题 - 11月份之后肖8 肖4 - 宝藏UP主的带背视频 英语 英语是门语言,想要成绩好的话,还是要多背单词,词汇量上去了题目完全就不是问题. 我从19年10月份开始用背单词软件(墨墨背单词, 其他软件也可以)背单词, 把考研要求的词汇全背了. 背单词这个过程要一直持续到初试考完英语那天,一定要坚持下去. 7月份开始,做英语往年真题. 英语二可以先做英语一的题目, 然后再做英语二的. 我用的是黄皮书. 阅读理解每道错题都要找出为什么错,错在哪里. 作文在考前40天左右,开始背作文书,我背的是王江涛的作文预测,里面的20篇要背的非常熟.基本上作文就没什么问题了. 要点: - 背单词直到初试英语结束 - 7月份开始做真题 - 背作文书 数学 21的数学算是...不要太简单, 我数学底子比较差, 都可以考到126分. 按照大小年的规律, 22的同学们要小心了, 22的数学大概率会非常难. 而且数学非常能拉分, 所以数学一定要抓好.我数学从5月份开始准备(说实话, 晚了), 高数跟的是武忠祥老师, 线代跟的是李永乐老师. 材料全是他们的配套材料. 基础部分建议就6月份及之前, 开始学的话就先把高数基础班过一遍, 再过线代, 过的时候看一节课, 做一节课对应的习题, 把错误的习题拿红笔标注一下, 方便重复去做. 做完一节课之后可以再反过头来, 把这节的理论知识再过一遍, 重点放在自己不熟练的地方. 强化阶段建议7-9月. 这段时间非常关键, 是数学提分的重要阶段. 武忠祥老师的高数强化资料和李永乐老师的线代强化资料上面的题目都是非常好的. 把这些题能够吃透, 130应该是没问题的, 不要怕错题, 发现了错题, 解决一个问题, 才能进步. 10-11月份, 开始做真题, 各家的真题都可以买, 没什么特别大的区别, 做真题的话把最近15年的做题吃透就可以了, 抽个时间可以试着给自己来一次模拟考试. 11月底就开始刷模拟卷, 我用的模拟卷是李林老师的6套卷和4套卷, 题目难度适中, 比较适合数学二的考试来做. 专业课 21专业课课程代码不变, 初试科目比20少了一门操作系统(不要以为初试科目少就比其他好考, 西交复试有笔试). 数据结构这门课, 没什么好说的, 王道吃透做透就行了. 试卷上数据结构总共有选择题, 大题, 以及代码题三种. 选择题是5道, 大题5道, 代码题1道. 这些题目在王道上都有比较接近或类似的题目. 参考书籍的散列表部分可以看一下, 有王道上面没有的知识点, 前些年考过. 计算机组成原理这门课是比较不好做的. 一定要买王换招老师的那本书, 然后反复啃, 反复看, 把课后习题搞懂就问题不大. 试卷上计算机组成原理的题目有填空题, 简答题, 计算题. 简答题的占比还是很大的, 这点务必要注意. 课后习题里面的简答题和书上的一些重要的知识点, 都有可能出简答题. 复试 复试阶段有笔试, 机试, 面试(面试包括英语面试, 专业提问以及老师们对你的自由问答). 现阶段先准备初试即可, 初试完之后觉得可以的话, 再准备复试. 笔试可选 操作系统, 计算机网络, 离散数学, 数据库, 编译原理, 软件工程. 六选二. 难度也是不小的. 同样还是喜欢考简答题, 还有名词解释的题目(给你英文单词, 让你解释这是什么东西, 回答时中英文都可). 最低60分. 机试可用C, C++, Java. 五道题目, 总体来说还是难度不大的. 考一些基本操作. 最低分50分. 面试部分基本上就是自我介绍, 文献翻译, 专业提问, 老师自由提问这四个部分.","link":"/2021-xjtu-postgraduate-admission-experience/"},{"title":"代码随想录算法训练营第16天 | 104.二叉树的最大深度, 111.二叉树的最小深度, 222.完全二叉树的节点个数","text":"104.二叉树的最大深度 代码随想录链接 题目 返回给定二叉树的最大深度. 自己的想法 层序遍历一下, 返回最后一层深度. 题解 层序遍历: 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if (!root) return 0; int depth = 0; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); depth++; // 每遍历一层, depth就自增1 for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return depth; }}; 递归法: 1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if (!root) return 0; return 1 + max(maxDepth(root -&gt; left), maxDepth(root -&gt; right)); // 左侧节点个数 + 右侧节点个数 + 自身 }}; 111.二叉树的最小深度 代码随想录链接 题目 返回二叉树的最小深度. 自己的想法 层序遍历, 在遇到第一个无左右孩子的节点时, 返回当前深度. 题解 层序遍历: 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int minDepth(TreeNode* root) { if (!root) return 0; queue&lt;TreeNode *&gt; que; que.push(root); int level = 0; while (!que.empty()) { level++; int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (!(node -&gt; left) &amp;&amp; !(node -&gt; right)) return level; // 遇到无左右孩子的节点就返回当前深度 if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return level; }}; 递归: 1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int minDepth(TreeNode* root) { if (root == nullptr) return 0; if ((root -&gt; left == nullptr) &amp;&amp; (root -&gt; right != nullptr)) return 1 + minDepth(root -&gt; right); // 只有右孩子就只计算右子树的最小深度 if ((root -&gt; left != nullptr) &amp;&amp; (root -&gt; right == nullptr)) return 1 + minDepth(root -&gt; left); // 只有左孩子就只计算左子树的最小深度 return 1 + min(minDepth(root -&gt; left), minDepth(root -&gt; right)); // 左右孩子都有就取左右子树的最小值 }}; 222.完全二叉树的节点个数 代码随想录链接 题目 统计给定的完全二叉树有多少个节点. 自己的想法 不管什么遍历, 个数查一下. 但时间复杂度是\\(O(n)\\). 应该要针对于完全二叉树的特性, 使用一些方法来降低时间复杂度. 题解 当做普通二叉树来层序遍历: 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int countNodes(TreeNode* root) { if (!root) return 0; int count = 0; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); count++; // 查个数 if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return count; }}; 当做普通二叉树来递归: 123456789101112131415161718/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int countNodes(TreeNode* root) { if (!root) return 0; return 1 + countNodes(root -&gt; left) + countNodes(root -&gt; right); }}; 针对完全二叉树的特性, 来优化时间复杂度. 完全二叉树的叶子结点一定是积累在最后一层的靠左部分. 其中部分子树是满二叉树, 满足从任意节点出发, 最左下的节点和最后下的节点与出发节点的高度差一致的特性. 可以在计算时, 判断当前节点出发的树是否是满二叉树, 如果是, 用公式计算即可, 如果不是, 再使用类似于上面的递归方法来统计节点个数. 针对完全二叉树的方法: 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int countNodes(TreeNode* root) { if (!root) return 0; TreeNode *left = root -&gt; left; TreeNode *right = root -&gt; right; int leftDepth = 0, rightDepth = 0; while (left) { // 最左下节点的高度差 left = left -&gt; left; leftDepth++; } while (right) { // 最右下节点的高度差 right = right -&gt; right; rightDepth++; } if (leftDepth == rightDepth) { // 高度差一致, 说明这个子树是完全二叉树, 快速计算个数 return (2 &lt;&lt; leftDepth) - 1; } return countNodes(root -&gt; left) + countNodes(root -&gt; right) + 1; // 若子树不是完全二叉树, 就递归计算这个子树的个数 }};","link":"/algorithm-train-day16/"},{"title":"代码随想录算法训练营第15天 | 二叉树层序遍历, 226.翻转二叉树, 101.对称二叉树","text":"二叉树层序遍历 二叉树的层序遍历可以通过队列来完成, 要点在于访问一个节点时, 将其左右孩子指针送入队列中. 最基础的层序遍历: 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;int&gt; levelOrder(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; queue&lt;TreeNode*&gt; que; que.push(root); while (!que.empty()) { TreeNode *node = que.front(); result.push_back(node -&gt; val); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } return result; }}; 就真的只是能得到层序遍历的顺序而已. 如果要在遍历的每层节点处, 分层进行一些操作, 就需要在遍历的时候, 多出一些对于队列的判定. 有明显层次的层序遍历: 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; result; if (!root) return result; queue&lt;TreeNode*&gt; que; que.push(root); while (!que.empty()) { vector&lt;int&gt; vec; int qsize = que.size(); // 当前队列的大小即为要遍历的下一层的节点数 for (int i = 0; i &lt; qsize; i++) { // 只遍历这一层, 下一层在下一次while循环内进行遍历 TreeNode *node = que.front(); vec.push_back(node -&gt; val); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } result.push_back(vec); } return result; }}; 在带有层次的层序遍历的代码的基础上, 可以写出很多题目的答案. 如: 102. 二叉树的层序遍历 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; result; if (!root) return result; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty()) { vector&lt;int&gt; vec; int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); vec.push_back(node -&gt; val); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } result.push_back(vec); } return result; }}; 107. 二叉树的层序遍历 II 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; result; if (!root) return result; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); vector&lt;int&gt; levelResult; for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); levelResult.push_back(node -&gt; val); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } result.push_back(levelResult); } reverse(result.begin(), result.end()); // 层序遍历,再把层次逆转一下 return result; }}; 199. 二叉树的右视图 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;int&gt; rightSideView(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { // 层序遍历, 但只记录每层最后一个节点 TreeNode *node = que.back(); result.push_back(node -&gt; val); int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return result; }}; 637. 二叉树的层平均值 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;double&gt; averageOfLevels(TreeNode* root) { vector&lt;double&gt; result; if (!root) return result; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { // 层序遍历, 每层节点求和并求平均 int qsize = que.size(); double sum = 0; for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); sum += node -&gt; val; if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } sum /= qsize; result.push_back(sum); } return result; }}; 429. N 叉树的层序遍历 123456789101112131415161718192021222324252627282930313233343536373839/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { vector&lt;vector&lt;int&gt;&gt; result; if (!root) return result; queue&lt;Node *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); vector&lt;int&gt; levelResult; for (int i = 0; i &lt; qsize; i++) { Node *node = que.front(); que.pop(); levelResult.push_back(node -&gt; val); // 就是对左右节点的判断, 变成了对于一个指针数组的遍历判断 for (Node *n : node -&gt; children) { if (n) que.push(n); } } result.push_back(levelResult); } return result; }}; 515. 在每个树行中找最大值 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;int&gt; largestValues(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); int max = INT_MIN; // 每层记录一个最大值 for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; val &gt; max) max = node -&gt; val; if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } result.push_back(max); } return result; }}; 116. 填充每个节点的下一个右侧节点指针 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*// Definition for a Node.class Node {public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {}};*/class Solution {public: Node* connect(Node* root) { if (!root) return root; queue&lt;Node *&gt; que; que.push(root); while (!que.empty()) { // 层序遍历, 按照先后加next指针 int qsize = que.size(); if (qsize == 1) { que.front() -&gt; next = NULL; if (que.front() -&gt; left) que.push(que.front() -&gt; left); if (que.front() -&gt; right) que.push(que.front() -&gt; right); que.pop(); } for (int i = 1; i &lt; qsize; i++) { Node *first = que.front(); que.pop(); Node *second = que.front(); first -&gt; next = second; if (first -&gt; left) que.push(first -&gt; left); if (first -&gt; right) que.push(first -&gt; right); if (i == qsize - 1) { que.pop(); if (second -&gt; left) que.push(second -&gt; left); if (second -&gt; right) que.push(second -&gt; right); second -&gt; next == NULL; } } } return root; }}; 117. 填充每个节点的下一个右侧节点指针 II 好像和上面那题代码没差. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*// Definition for a Node.class Node {public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {}};*/class Solution {public: Node* connect(Node* root) { if (!root) return root; queue&lt;Node *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); if (qsize == 1) { que.front() -&gt; next = NULL; if (que.front() -&gt; left) que.push(que.front() -&gt; left); if (que.front() -&gt; right) que.push(que.front() -&gt; right); que.pop(); } for (int i = 1; i &lt; qsize; i++) { Node *first = que.front(); que.pop(); Node *second = que.front(); first -&gt; next = second; if (first -&gt; left) que.push(first -&gt; left); if (first -&gt; right) que.push(first -&gt; right); if (i == qsize - 1) { que.pop(); if (second -&gt; left) que.push(second -&gt; left); if (second -&gt; right) que.push(second -&gt; right); second -&gt; next == NULL; } } } return root; }}; 104. 二叉树的最大深度 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if (!root) return 0; int depth = 0; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { // 就层序遍历的时候加个数数数数 int qsize = que.size(); depth++; for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return depth; }}; 111. 二叉树的最小深度 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int minDepth(TreeNode* root) { if (!root) return 0; queue&lt;TreeNode *&gt; que; que.push(root); int level = 0; while (!que.empty()) { level++; int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (!(node -&gt; left) &amp;&amp; !(node -&gt; right)) return level; // 遇见没有左右孩子的节点就返回当前是几层 if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return level; }}; 做复制完上面这些题之后, 力扣已做题目瞬间+10. 226.翻转二叉树 代码随想录链接 题目 把整个二叉树翻转一下. 自己的想法 可以递归, 可以迭代(层序, 前序(某种意义上的))来完成. 题解一 递归: 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {private: void invert(TreeNode *root) { if (!root) return; // 空节点就什么也不做 swap(root -&gt; left, root -&gt; right); // 交换节点的左右孩子 invert(root -&gt; left); // 对左孩子进行相同操作 invert(root -&gt; right); // 对右孩子进行相同操作 }public: TreeNode* invertTree(TreeNode* root) { invert(root); return root; }}; 题解二 前序迭代, 其实就是在遍历访问的时候, \"访问\"的操作变成了交换左右孩子的操作. 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* invertTree(TreeNode* root) { if (!root) return root; stack&lt;TreeNode *&gt; stack; stack.push(root); while (!stack.empty()) { // 使用了昨天提到的统一风格的迭代遍历实现 TreeNode *node = stack.top(); if (node) { stack.pop(); if (node -&gt; right) stack.push(node -&gt; right); if (node -&gt; left) stack.push(node -&gt; left); stack.push(node); stack.push(NULL); } else { stack.pop(); node = stack.top(); stack.pop(); swap(node -&gt; left, node -&gt; right); // 交换左右孩子 } } return root; }}; 题解三 层序遍历, 同样也是把\"访问\"的操作变成了交换左右节点的操作. 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* invertTree(TreeNode* root) { if (!root) return root; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); swap(node -&gt; left, node -&gt; right); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return root; }}; 101.对称二叉树 代码随想录链接 题目 判断整个二叉树是否是左右对称的. 自己的想法 先想到的是递归法, 先检查左右孩子是否相同, 再递归地去检查左右孩子起始的子树是否和镜面对应的子树相同 题解一 递归法: 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {private: bool compare(TreeNode *left, TreeNode *right) { if (!left &amp;&amp; !right) return true; if (!left || !right || (left -&gt; val != right -&gt; val)) return false; // 如果左右孩子不同, 则不满足条件 return compare(left -&gt; left, right -&gt; right) &amp;&amp; compare(left -&gt; right, right -&gt; left); // 递归地检查子树. }public: bool isSymmetric(TreeNode* root) { if (!root) return true; return compare(root -&gt; left, root -&gt; right); }}; 题解二 使用队列来记录下次要对比的子树的根: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { if (!root) return true; queue&lt;TreeNode *&gt; que; que.push(root -&gt; left); que.push(root -&gt; right); while (!que.empty()) { TreeNode *left = que.front(); // 相邻的两个节点是要对比的对象 que.pop(); TreeNode *right = que.front(); que.pop(); if (!left &amp;&amp; !right) continue; if (!left || !right || (left -&gt; val != right -&gt; val)) return false; que.push(left -&gt; left); // 左孩子的左子树和右孩子的右子树要对比, 一起放入队列 que.push(right -&gt; right); que.push(left -&gt; right); // 左孩子的右子树和右孩子的左子树需要对比, 一起放入队列 que.push(right -&gt; left); } return true; }}; 题解三 相似地, 使用栈来记录下次要对比的字数的根节点: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { if (!root) return true; queue&lt;TreeNode *&gt; que; que.push(root -&gt; left); que.push(root -&gt; right); while (!que.empty()) { TreeNode *left = que.front(); // 同样是取两个节点对比 que.pop(); TreeNode *right = que.front(); que.pop(); if (!left &amp;&amp; !right) continue; if (!left || !right || (left -&gt; val != right -&gt; val)) return false; que.push(left -&gt; left); // 同样地将要对比的节点压入栈中 que.push(right -&gt; right); que.push(left -&gt; right); que.push(right -&gt; left); } return true; }};","link":"/algorithm-train-day15/"},{"title":"代码随想录算法训练营第1天 | 704. 二分查找、27. 移除元素","text":"希望自己能够坚持下去 自己的小破站好久没更了就是说。 二分查找 代码随想录-二分查找 适合条件 给定一个有序的数组，从其中找出指定的元素的位置 思路 将查找区间一分为二，通过对比区间中间值与目标值的大小来确定： 中间值是否就是目标值所在 若中间值不是目标值，确定下个循环的查找区间的移动方向 跳出循环的条件，区间的左边界大于区间的右边界 例题 LeetCode-704 二分查找 LeetCode-704 题目的描述就是给定了有序数组，在O(logn)的时间内找出给定值的索引，若给定值不存在，则输出-1。 在O(logn)的时间内完成这个操作，必定是需要使用和区间划分有关的方法。 根据区间定义的不同，有两种解题方法。 解法一 如果目标值在区间[left, right]内 12345678910111213141516171819202122232425class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int size = nums.size(); // 下面一行确定初次循环时的查找区间的左右边界 int left = 0, right = size - 1; while (left &lt;= right) { // 循环结束条件 /** * 根据左右边界计算出中间位置的索引， * 之所以不使用 mid = (left + right) / 2 是因为防止溢出 */ int mid = left + ((right - left) / 2); if (nums[mid] == target) return mid; // 若中间值为目标值，则返回中间值 if (nums[mid] &gt; target) { // 若中间值大于目标值，即要找的目标值应该在中间值的左侧，则将区间右边界向左调整 right = mid - 1; continue; } if (nums[mid] &lt; target) { // 若中间值小于目标值，即目标值应该在中间值的右侧，则将区间左边界向右调整 left = mid + 1; continue; } } return -1; // 当找不到目标值时，返回 -1 }}; 解法二 如果目标值在[left, right)内 123456789101112131415161718192021222324class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { // 下面一行确定初次循环时的查找区间的左右边界 int left = 0, right = nums.size(); while (left &lt; right) { // 循环结束条件 /** * 根据左右边界计算出中间位置的索引， * 之所以不使用 mid = (left + right) / 2 是因为防止溢出 */ int mid = left + ((right - left) / 2); if (nums[mid] == target) return mid; // 若中间值为目标值，则返回中间值 if (nums[mid] &gt; target) { // 若中间值大于目标值，即要找的目标值应该在中间值的左侧，则将区间右边界向左调整 right = mid; continue; } if (nums[mid] &lt; target) { // 若中间值小于目标值，即目标值应该在中间值的右侧，则将区间左边界向右调整 left = mid + 1; continue; } } return -1; // 当找不到目标值时，返回 -1 }}; 类似题目 LeetCode-34 寻找可能重复的目标值的存在区间 分别利用二分法找最左边的目标值和最右侧的目标值。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int leftBorder = getLeftBorder(nums, target); // 分别调用封装好的函数去找左右边界，性能可能稍差，但代码逻辑会清晰些 int rightBorder = getRightBorder(nums, target); if (leftBorder == -2 || rightBorder == -2) return {-1, -1}; // 不存在目标值的返回 if (rightBorder - leftBorder &gt; 1) return {leftBorder + 1, rightBorder - 1}; return {-1, -1}; } int getLeftBorder(vector&lt;int&gt; &amp;nums, int target) {// 找左边界，其实是找目标值的左侧紧挨着的非目标值的数 int left = 0, right = nums.size() - 1; int leftBorder = -2; while (left &lt;= right) { // 循环结束条件 int mid = left + ((right - left) / 2); // 求中间位置 if (nums[mid] &gt;= target) {// 由于要找的是左边界，当中间值大于等于目标值时，应当将当前寻找的边界取中间值左侧 right = mid - 1; // 右边界取在中间值左侧 leftBorder = right; // 为了处理可能存在的中间值等于目标值的情况，要将寻找的左边界置为当前的右边界 } else { // 若中间值小于目标值，证明要找的边界在中间值右边 left = mid + 1; } } return leftBorder; } int getRightBorder(vector&lt;int&gt; &amp;nums, int target) { // 找右边界，其实是找目标值右侧紧挨着的非目标值的数 int left = 0, right = nums.size() - 1; int rightBorder = -2; while (left &lt;= right) { // 循环结束条件 int mid = left + ((right - left) / 2); if (nums[mid] &gt; target) { // 中间值大于目标，应该取左区间 right = mid - 1; } else { // 中间值小于等于目标，应该取右区间，并更新rightBorder为右区间的首位 left = mid + 1; rightBorder = left; } } return rightBorder; }}; 移除元素 代码随想录-移除元素 题目要求 给定一个数组，和一个值，将数组中等于给定值的数据移出，返回剩下的数据组成的数组以及该数组的大小。 思路 解法一 暴力法，没有什么是for循环嵌套不能解决的（然后时间复杂度就上去了捏） 思路是，一个for循环用于遍历给定数组，遍历过程中若遇到与给定值相同的数，则使用一个新的for循环，将当前位置之后的全部数据，向前移动一位，同时还需要注意将遍历的索引置于正确位置。 12345678910111213141516class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int size = nums.size(); // 记录数组的实时大小 for (int i = 0; i &lt; size; i++) { // 遍历数组 if (nums[i] == val) { // 若等于目标值，就使用一个新的for循环将后续数据向前移动一位 for (int j = i; j &lt; size - 1; j++) { nums[j] = nums[j + 1]; } i--; // 移动后，当前位置数据发生变化，该位置需要重新判断一次 size--; // 覆盖掉了一位数据，数组大小-1 } } return size; }}; 两个for循环且每个循环的循环次数与给定数组的大小线性有关，故时间复杂度为\\(O(n^2)\\)。 使用了常数个变量，故空间复杂度为\\(O(1)\\)。 解法二 双指针法 思想是同时保留两个指针，快指针用于遍历原数组，慢指针用于保存结果数组。当快指针遇到与给定值相同的数据时，什么也不做，只是单纯地将快指针移动到下一位；若快指针遇见了非给定值的数，则将快指针当前指向的数拷贝至慢指针指向的位置，并将慢指针后移一位。 12345678910111213class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int slowIndex = 0; // 用于指向结果数组的末尾 for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) { // 遍历数组 if (val != nums[fastIndex]) { // 若遇到了非给定值的数，则将其保存下来，复制至slowIndex指向的位置，slowIndex向后移一位 nums[slowIndex++] = nums[fastIndex]; } // 若遇到了给定值的数，则什么都不做，相当于将其丢弃 } return slowIndex; // slowIndex在最后一次复制操作后的自增，正好为结果数组的大小 }}; 使用了一个for循环，循环的次数和数组大小线性相关，故时间复杂度为\\(O(n)\\)。 使用了常数个变量，故空间复杂度为\\(O(1)\\)。 解法三 另一种双指针法 类似于快速排序分区的过程，左指针从数组左侧出发，依次寻找一个等于给定值的数，等待被替换，找到后，右指针从数组末尾出发，找到一个不为给定值的数据，用于替换左指针指向的数据。 123456789101112131415161718class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int left = 0, right = nums.size() - 1; // 左右指针的起始位置 while (left &lt;= right) { // 循环进行条件 while (left &lt;= right &amp;&amp; nums[left] != val) { // 从左侧寻找一个与给定值相同的数，等待被替换 left++; } while (left &lt;= right &amp;&amp; nums[right] == val) { // 从右侧寻找一个非给定值的数，用于替换左指针找到的数 right--; } if (left &lt; right) { // 确保是因为找到了被替换数据和替换数据，才进行替换 nums[left++] = nums[right--]; } } return left; }}; 代码中循环次数和数组大小线性相关，故时间复杂度为\\(O(n)\\)，使用了常数个变量，故空间复杂度为\\(O(1)\\)。","link":"/algorithm-train-day1/"},{"title":"代码随想录算法训练营第18天 | 513.找树左下角的值, 112. 路径总和, 113.路径总和ii, 105.从前序与中序遍历序列构造二叉树, 106.从中序与后序遍历序列构造二叉树","text":"513.找树左下角的值 代码随想录链接 题目 给定一颗二叉树, 返回树的最后一层的最左侧叶子结点的值. 自己的想法 迭代法的话就层序遍历, 判断当前访问的一层是否都是叶子节点, 若是, 则输出该层第一个节点的值. 递归法的话就要使用前序遍历了, 在不断往下遍历时, 标记最深的叶子节点. 题解 迭代法: 12345678910111213141516171819202122232425262728class Solution {public: int findBottomLeftValue(TreeNode* root) { int result = 0; queue&lt;TreeNode *&gt; que; if (!root) return result; que.push(root); while (!que.empty()) { int qsize = que.size(); bool hasChild = false; result = que.front() -&gt; val; // 取该层最左侧节点的值 for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; left) { hasChild = true; que.push(node -&gt; left); } if (node -&gt; right) { hasChild = true; que.push(node -&gt; right); } } if (!hasChild) return result; // 如果本层节点都没有子节点, 则返回本层第一个节点的值 } return result; }}; 递归法: 123456789101112131415161718192021class Solution {private: int maxDepth = INT_MIN; // 记录最大叶子节点的深度, 用于比较 int result; // 最终的值 void traversal(TreeNode *root, int depth) { if (root -&gt; left == NULL &amp;&amp; root -&gt; right == NULL) { // 是叶子节点就和记录进行对比 if (depth &gt; maxDepth) { maxDepth = depth; result = root -&gt; val; } return; } if (root -&gt; left) traversal(root -&gt; left, depth + 1); // 递归遍历左子树 if (root -&gt; right) traversal(root -&gt; right, depth + 1); // 递归遍历右子树 }public: int findBottomLeftValue(TreeNode* root) { traversal(root, 0); return this -&gt; result; }}; 112. 路径总和 113.路径总和ii 代码随想录链接 题目 112题是只要求判断是否有路径之和等于给定值, 而113题要求输出这些路径, 除此之外没有区别. 自己的想法 迭代法的话使用前序遍历, 存储根节点到当前节点的值, 进行判断 递归法同样是使用前序遍历. 题解 112 递归法: 12345678class Solution {public: bool hasPathSum(TreeNode* root, int targetSum) { if (!root) return false; if (!(root -&gt; left) &amp;&amp; !(root -&gt; right) &amp;&amp; targetSum == root -&gt; val) return true; // 判断当前节点是否符合 return hasPathSum(root -&gt; left, targetSum - root -&gt; val) || hasPathSum(root -&gt; right, targetSum - root -&gt; val); // 将给定值减去当前节点的值, 并递归判断左孩子和右孩子 }}; 112 迭代法: 12345678910111213141516class Solution {public: bool hasPathSum(TreeNode* root, int targetSum) { if (!root) return false; stack&lt;pair&lt;TreeNode*, int&gt;&gt; st; // 存储根节点到当前节点的值的栈 st.push(pair&lt;TreeNode*, int&gt;(root, root -&gt; val)); while (!st.empty()) { auto node = st.top(); st.pop(); if (!(node.first -&gt; left) &amp;&amp; !(node.first -&gt; right) &amp;&amp; node.second == targetSum) return true; // 判断当前取出的节点是否符合 if (node.first -&gt; left) st.push(pair&lt;TreeNode*, int&gt;(node.first -&gt; left, node.second + node.first -&gt; left -&gt; val)); // 将左孩子与左孩子的路径值入栈 if (node.first -&gt; right) st.push(pair&lt;TreeNode*, int&gt;(node.first -&gt; right, node.second + node.first -&gt; right -&gt;val)); // 将右孩子与右孩子的路径值入栈 } return false; }}; 113 迭代法: 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) { vector&lt;vector&lt;int&gt;&gt; result; if (!root) return result; vector&lt;vector&lt;int&gt;&gt; paths; // 存放节点的路径, 换成栈也可以 stack&lt;pair&lt;TreeNode*, int&gt;&gt; st; // 存放节点和到达它的路径值 st.push(pair&lt;TreeNode*, int&gt;(root, root -&gt; val)); paths.push_back(vector&lt;int&gt;{root -&gt; val}); while (!st.empty()) { auto node = st.top(); st.pop(); auto path = paths.back(); paths.pop_back(); if (!(node.first -&gt; left) &amp;&amp; !(node.first -&gt; right) &amp;&amp; node.second == targetSum) result.push_back(path); // 如果当前取出的节点符合条件, 就将路径记录在结果数组里 if (node.first -&gt; left) { // 左孩子的相关信息记录下来 st.push(pair&lt;TreeNode*, int&gt;(node.first -&gt; left, node.second + node.first -&gt; left -&gt; val)); path.push_back(node.first -&gt; left -&gt; val); paths.push_back(path); path.pop_back(); } if (node.first -&gt; right) { // 右孩子的相关信息记录下来 st.push(pair&lt;TreeNode*, int&gt;(node.first -&gt; right, node.second + node.first -&gt; right -&gt; val)); path.push_back(node.first -&gt; right -&gt; val); paths.push_back(path); } } return result; }}; 105.从前序与中序遍历序列构造二叉树 106.从中序与后序遍历序列构造二叉树 代码随想录链接 题目 根据二叉树的中序和后序遍历构建二叉树 根据二叉树的前序和中序遍历构建二叉树 自己的想法 对于给定中序和后序的情况, 先使用后序的最后一个确定根节点, 然后根据根节点, 在中序数组中划分出来左字数的中序和右子树的中序, 又因为同一棵子树的节点数目是相同的, 也能在后序遍历的数组当中划分出左子树的后序遍历以及右子树的后序遍历. 根据左右子树的两种遍历数组, 递归地进行构建即可. 对于给定前序和中序的情况, 和上面是相似的, 进行划分, 得到左右子树的前序和中序遍历, 再进行递归即可. 题解 105: 12345678910111213141516171819202122232425class Solution {public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { if (inorder.size() != preorder.size()) return NULL; if (!inorder.size()) return NULL; int rootVal = preorder.front(); TreeNode *root = new TreeNode(rootVal); if (inorder.size() == 1) return root; int rootValIndex; for (rootValIndex = 0; rootValIndex &lt; inorder.size(); rootValIndex++) // 找到根节点的位置, 以进行划分 if (inorder[rootValIndex] == rootVal) break; vector&lt;int&gt; leftInOrder(inorder.begin(), inorder.begin() + rootValIndex); // 划分左右子树的前序和中序 vector&lt;int&gt; rightInOrder(inorder.begin() + rootValIndex + 1, inorder.end()); vector&lt;int&gt; leftPreOrder(preorder.begin() + 1, preorder.begin() + rootValIndex + 1); vector&lt;int&gt; rightPreOrder(preorder.begin() + rootValIndex + 1, preorder.end()); root -&gt; left = buildTree(leftPreOrder, leftInOrder); // 递归构建左右子树 root -&gt; right = buildTree(rightPreOrder, rightInOrder); return root; }}; 106: 12345678910111213141516171819202122232425class Solution {public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { if (inorder.size() != postorder.size()) return NULL; if (!inorder.size()) return NULL; int rootVal = postorder.back(); TreeNode *root = new TreeNode(rootVal); if (inorder.size() == 1) return root; int rootValIndex; for (rootValIndex = 0; rootValIndex &lt; inorder.size(); rootValIndex++) // 定位根节点, 以进行划分 if (inorder[rootValIndex] == rootVal) break; vector&lt;int&gt; leftInOrder(inorder.begin(), inorder.begin() + rootValIndex); // 划分左右子树的中序和后序 vector&lt;int&gt; rightInOrder(inorder.begin() + rootValIndex + 1, inorder.end()); vector&lt;int&gt; leftPostOrder(postorder.begin(), postorder.begin() + rootValIndex); vector&lt;int&gt; rightPostOrder(postorder.begin() + rootValIndex, postorder.end() - 1); root -&gt; left = buildTree(leftInOrder, leftPostOrder); // 递归构建左右子树 root -&gt; right = buildTree(rightInOrder, rightPostOrder); return root; }};","link":"/algorithm-train-day18/"},{"title":"代码随想录算法训练营第2天 |  977.有序数组的平方，209.长度最小的子数组，59.螺旋矩阵II","text":"977.有序数组的平方 代码随想录链接 题目 LeetCode-977 给定一个顺序不减的有序数组A，返回一个由A数组中每个值的平方组成的顺序不减数组。 自己的思考 可能还是倾向于暴力法一点，有看到提示说可以用双指针法，但是自己也没想明白应该怎么用(我好蔡啊.jpg) 解法一 暴力法，先就原地计算出来每一项的平方是多少，覆盖到原位置，然后再排个序。 1234567891011#include&lt;algorithm&gt;class Solution {public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { for (int i = 0; i &lt; nums.size(); i++) { // 遍历每个值 nums[i] *= nums[i]; // 求出平方值，写入原位置 } sort(nums.begin(), nums.end()); // 调用C++的sort函数进行排序 return nums; }}; 一个for循环遍历数组，时间复杂度为\\(O(n)\\)，C++的sort函数是基于快速排序的优化算法，时间复杂度为\\(O(nlogn)\\)。 使用了常数个变量，空间复杂度为\\(O(1)\\)。 解法二 双指针法，类似于昨天的题目，使用两个指针来完成。 为什么可以使用双指针法呢？要题目给定的条件出发。 题目给定的数组是顺序不减进行排列的，求得平方值值后需要调整位置的情况，只存在于原数组左侧的负数，平方之后应该被排在右侧的某个位置，而原数组和结果数组的右侧都是较大的值。由这个条件，我们可以使用双指针法，对比两个指针指向的值的平方，较大的值，应该依次从右至左写入到结果数组内。 1234567891011121314151617#include&lt;algorithm&gt;#include&lt;cmath&gt;class Solution {public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; result(nums.size(), 0); // 声明并实例化一个新的数组，大小和原数组一样，并均用0填充 int leftIndex = 0, rightIndex = nums.size() - 1, resultIndex = nums.size() - 1; // 声明原数组的左右指针，以及结果数组的指针 while(leftIndex &lt;= rightIndex) { // 循环条件 if (pow(nums[leftIndex], 2) &gt; pow(nums[rightIndex], 2)) { // 若左指针指向的数的平方值要大于右指针指向的数的平方值 result[resultIndex--] = pow(nums[leftIndex++], 2); // 将左指针的值写入到目标数组,并移动左指针和结果数组的指针 } else { result[resultIndex--] = pow(nums[rightIndex--], 2); // 否则，就将右指针指向的数的平方值写入结果数组，并相应调整两个指针 } } return result; }}; 算法中while的循环次数和数组的大小线性相关，时间复杂度为\\(O(n)\\)。 由于使用了一个新的且和原数组大小一致的数组，空间复杂度为\\(O(n)\\)。 209.长度最小的子数组 代码随想录链接 题目 LeetCode-209 自己的思考 暴力法（蔡啊） 失败案例 使用两个for循环，计算并对比从第一个for循环的索引指向的数开始的每个子序列是否符合条件，若符合条件，记录下最短值。 1234567891011121314151617181920class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int result = INT32_MAX; int sum = 0; int subLength = 0; for (int i = 0; i &lt; nums.size(); i++) { // 外层for循环，其索引用于标记子序列的开头 sum = 0; for (int j = i; j &lt; nums.size(); j++) { // 内层for循环，j表示当前判断的子序列的末尾索引 sum += nums[j]; // 将当前位置的值加入 if (sum &gt;= target) { // 若满足了大于等于目标值的条件，就计算并对比是否是最短子序列 subLength = j - i + 1; result = result &lt; subLength ? result : subLength; break; // 都找到满足的了，再往后找，子序列就变更长了，该考虑以下一位数据开头的子序列了 } } } return result == INT32_MAX ? 0 : result; // 如果result还是初始值，代表没有找到合适的子序列，按题目要求返回0 }}; 很不幸，由于这个写法的时间复杂度为\\(O(n^2)\\)，没有AC，超时了 LeetCode-209-寄 正确解法 滑动窗口法 什么是滑动窗口呢，这里给出一个百科链接，讲述的是TCP协议中的滑动窗口。 下面我用自己的语言描述一下滑动窗口。所谓滑动窗口，是指在序列中取一段子序列，其前后边界是可以随时按照情况进行灵活调整的。 但如果仍然使用上面的两个for循环来表示起始和终止位置的话，那和“灵活”两个字怕是要说再见了。 可以仅适用一个for循环来表示后指针，在循环内，对左指针进行调整。这里偷一个代码随想录网站上的动图，来更好地说明滑动窗口。 滑动窗口动图示意，图来自代码随想录 123456789101112131415161718class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int result = INT32_MAX; int sum = 0; int subLength = 0; int leftIndex = 0; // 左指针 for (int rightIndex = 0; rightIndex &lt; nums.size(); rightIndex++) { // 右指针 sum += nums[rightIndex]; // 移动右指针之后，更新当前窗口内元素之和 while (sum &gt;= target) { // 若当前窗口之和符合条件，则进入判断，若不符合条件，则进入for循环的下一次循环 subLength = rightIndex - leftIndex + 1; // 计算当前窗口的长度，并与记录值对比，若小于记录的长度值，则更新记录值 result = result &lt; subLength ? result : subLength; sum -= nums[leftIndex++]; // 将窗口左侧向右移动 } } return result == INT32_MAX ? 0 : result; }}; 这个解法使用了一个for循环来遍历数组，for循环内又有一个while循环，所以时间复杂度是\\(O(b^2)\\)，但是while循环执行一次，左指针就会向右移动一次，而左指针移动的次数是和数组的长度是线性相关的，所以整个过程中while循环的执行次数是\\(O(n)\\)，与for循环的次数无关。 故该解法的时间复杂度为\\(O(2 * n) = O(n)\\)。 使用了常数个变量，空间复杂度为\\(O(1)\\)。 59.螺旋矩阵II 代码随想录链接 题目 LeetCode-59 给定一个正整数n，以顺时针方向螺旋填充\\(n * n\\)的一个矩阵 自己的思考 这题本科的时候绝对做过。需要设定一些控制变量，用于记录当前填充的坐标，但是怎么设置控制变量，是非常关键的地方，然后想不出来了 解法 在设计控制变量的时候，要考虑好在什么条件下，需要按照上右下左四个边的顺序进行进行下一个边的填充。 还要考虑到填充的时候，边与边的重叠部分，应该怎么处理，比如： 重叠部分由当前边填写 由下一个边填写 当然甚至还可以： + 两个边都填写，然后再调整要填写的数字 这里选择由下一个边填写的方法，原因是在完成一个loop之后，下一个loop开始的位置比较容易计算。 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; result(n, vector&lt;int&gt;(n, 0)); // 结果矩阵 int startx = 0, starty = 0; // 下一个loop开始时的坐标 int offset = 1; // 控制填写一条边的时候，应该剩下几个位置不填写，offset初始为1即表示重叠部分在下一个边填写 int loop = n / 2; // 需要进行多少次螺旋 int mid = n / 2; // 计算是否需要对最中间的位置单独进行填充 int count = 1; // 记录下次填充的数字 int i, j; // 当前填充的位置坐标 while (loop--) { i = startx; // 自左上方开始的横纵坐标 j = starty; for (j = starty; j &lt; n - offset; j++) result[i][j] = count++; // 填写上边 for (i = startx; i &lt; n - offset; i++) result[i][j] = count++; // 填写右边 for (; j &gt; starty; j--) result[i][j] = count++; // 填写下边，这里的 j &gt; starty 也是为了控制重叠部分在下一条边填写 for (; i &gt; startx; i--) result[i][j] = count++; // 填写左边，这里的 i &gt; startx 同上理 startx++; // 完成一次四边填写后，调整起始位置 starty++; offset++; // 完成一次四边填写，offset应该+1来控制上边和右边的填写不覆盖掉之前填写的内容 } if (n % 2) result[mid][mid] = count; // 若 n 为基数，需要针对中心位置单独填写 return result; }}; 代码时间复杂度为\\(O(n^2)\\)，空间复杂度为\\(O(n^2)\\)。 数组总结 在这个数组的专题内，学习到的方法主要有 二分法 用于查找，主要思想是在有序的数组里，通过左边界和有边界计算出来区间中间位置，根据中间位置的数据与目标数据的大小关系来调整下一次寻找的左右区间。 关键的一点是坚持自己刚开始设定的对于区间的定义（是左闭右开、左开右闭亦或是左闭右闭），并贯穿到所写题目的整个代码当中。 时间复杂度为\\(O(logn)\\) 例题：LeetCode-704 二分查找 双指针法 顾名思义，使用两个指针在一个for循环下，完成两个for循环的工作，使得时间复杂度降低。 双指针法既可以是同时从一个方向起步，例如LeetCode-27；也可以是分别从数组的开始和末尾向中间靠拢，例如LeetCode-977 双指针法还经常在链表中使用。 滑动窗口 滑动窗口可以用于求一个数组中子序列之用，相比于暴力法显著地降低了时间复杂度。 要理解滑动窗口，关键之处就在于理解窗口的起始位置和结束位置是怎么调整的。例题：LeetCode-209 本文上面的部分有滑动窗口的示意图。 模拟行为 例如模拟螺旋填充矩阵。这类题目主要考察对于代码循环边界控制的能力。要做好这类题目，关键是需要坚持好边界上的处理方法，从一而终。","link":"/algorithm-train-day2/"},{"title":"代码随想录算法训练营第22天 | 235.二叉搜索树的最近公共祖先, 701.二叉搜索树中的插入操作, 450.删除二叉搜索树中的节点","text":"235. 二叉搜索树的最近公共祖先 代码随想录链接 题目 235.二叉搜索树的最近公共祖先 给定一个二叉搜索树和两个指定节点, 在这个二叉树中找到这两个指定节点的最近公共祖先. 自己的想法 和昨天的236题一样, 使用递归法来找这两个节点的最近公共祖先, 实测昨天的代码也是可以直接AC的. 但这没有利用到二叉树的特性. 二叉树的特性的存在, 使得找节点更有方向性. 当前遍历节点的值小于两个目标节点, 则向遍历节点的右侧查找; 否则就向左侧查找. 题解 递归法: 123456789class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (!root) return NULL; if (root -&gt; val &gt; p -&gt; val &amp;&amp; root -&gt; val &gt; q -&gt; val) return lowestCommonAncestor(root -&gt; left, p, q); // 节点值大于两个目标节点, 向左侧查找 if (root -&gt; val &lt; p -&gt; val &amp;&amp; root -&gt; val &lt; q -&gt; val) return lowestCommonAncestor(root -&gt; right, p, q); // 节点值小于两个目标节点, 向右侧查找 return root; // 若落在两个节点的区间内, 则为要找的节点 }}; 迭代法: 1234567891011class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { while (root) { if (root -&gt; val &gt; p -&gt; val &amp;&amp; root -&gt; val &gt; q -&gt; val) root = root -&gt;left; // 节点值大于两个目标节点, 向左侧查找 else if (root -&gt; val &lt; p -&gt; val &amp;&amp; root -&gt; val &lt; q -&gt; val) root = root -&gt; right; // 节点值小于两个目标节点, 向右侧查找 else return root; // 若落在两个节点的区间内, 则为要找的节点 } return root; }}; 701.二叉搜索树中的插入操作 代码随想录链接 题目 701.二叉搜索树中的插入操作 向二叉搜索树种插入含有给定值的节点. 自己的想法 题目没有要求是平衡二叉树, 所以直接按照大小顺序遍历到一个空位置进行插入即可. 题解 递归法: 1234567891011121314151617181920class Solution {private: void traversal(TreeNode* cur, TreeNode* pre, int val) { // pre 标记上一个节点 if (cur == NULL) { // 当前节点不存在, 则给上一个节点插入一个包含给定值的孩子节点 TreeNode *node = new TreeNode(val); if (val &gt; pre -&gt; val) pre -&gt; right = node; else pre -&gt; left = node; return; } if (cur -&gt; val &gt; val) traversal(cur -&gt; left, cur, val); // 给定值大于当前节点值, 向左找空位 if (cur -&gt; val &lt; val) traversal(cur -&gt; right, cur, val); // 给定值小于当前节点值, 向右找空位 return; }public: TreeNode* insertIntoBST(TreeNode* root, int val) { if (!root) root = new TreeNode(val); else traversal(root, NULL, val); return root; }}; 迭代法: (和二叉搜索树的遍历类似) 1234567891011121314151617181920class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { if (!root) { TreeNode *node = new TreeNode(val); return node; } TreeNode *pre = NULL, *cur = root; while (cur) { // 找合适的空位 pre = cur; // 标记上一个节点 if (cur -&gt; val &gt; val) cur = cur -&gt; left; else cur = cur -&gt; right; } if (pre) { // 生成节点并插入到pre的左孩子或者右孩子位置 if (pre -&gt; val &gt; val) pre -&gt; left = new TreeNode(val); else pre -&gt; right = new TreeNode(val); } return root; }}; 450.删除二叉搜索树中的节点 代码随想录链接 题目 450.删除二叉搜索树中的节点 删除二叉搜索树中给定值的节点. 自己的想法 通过二叉搜索树的查找, 先找到要删除的节点, 然后再结合左右孩子的情况调整要删除的节点之于其父节点的指针. 题解 递归法: 1234567891011121314151617181920212223242526272829class Solution {public: TreeNode* deleteNode(TreeNode* root, int key) { if (!root) return nullptr; if (root -&gt; val == key) { // 若当前节点是要被删除的节点 if (!(root -&gt; left) &amp;&amp; !(root -&gt; right)) { // 如果没有子节点, 就直接删除 delete root; return nullptr; } else if (!(root -&gt; left) || !(root -&gt; right)) { // 如果有一个子节点, 就将子节点代替原来节点 auto node = !(root -&gt; left) ? root -&gt; right : root -&gt; left; delete root; return node; } else { // 如果有两个子节点, 就在右子树中找最左侧的节点(没有左子树的节点), 将被删除的节点的左子树移动到这个节点的左孩子位置上, 并用原节点的右孩子代替被删除节点的位置. auto cur = root -&gt; right; while (cur -&gt; left) { cur = cur -&gt; left; } cur -&gt; left = root -&gt; left; auto tmp = root; root = root -&gt; right; delete tmp; return root; } } if (root -&gt; val &gt; key) root -&gt; left = deleteNode(root -&gt; left, key); // 向左查找要删除的节点 if (root -&gt; val &lt; key) root -&gt; right = deleteNode(root -&gt; right, key); // 向右查找被删除的节点 return root; }}; 还可以使用交换节点法来删除二叉树中的节点(对于所有二叉树都可以): 123456789101112131415class Solution {public: TreeNode* deleteNode(TreeNode* root, int key) { if (!root) return nullptr; if (root -&gt; val == key) { // 找到了目标节点 if (!(root -&gt; right)) return root -&gt; left; // 如果没有右孩子, 就拿左孩子来代替被删除的节点 auto cur = root -&gt; right; // 取右子树中最左侧的节点, 交换与被删除的节点的值 while (cur -&gt; left) cur = cur -&gt; left; swap(root -&gt; val, cur -&gt; val); } // 被交换至没有左子树的节点之后, 再次被遍历时, 会再次被挪到右子树的最左侧节点, 当被挪到叶子节点时再被遍历到, 会被以NULL形式覆盖掉, 完成真正的删除 root -&gt; left = deleteNode(root -&gt; left, key); // 递归删除包含给定值的节点 root -&gt; right = deleteNode(root -&gt; right, key); return root; }}; 迭代法, 删除的逻辑和上面是一样的, 只是找要被删除的节点的过程是迭代的: 1234567891011121314151617181920212223242526272829class Solution {private: TreeNode* deleteTheNode(TreeNode* target) { if (!target) return nullptr; if (!(target -&gt; right)) return target -&gt; left; auto cur = target -&gt; right; while (cur -&gt; left) { cur = cur -&gt; left; } cur -&gt; left = target -&gt; left; return target -&gt; right; }public: TreeNode* deleteNode(TreeNode* root, int key) { if (!root) return nullptr; auto cur = root; TreeNode *pre = nullptr; while (cur) { if (cur -&gt; val == key) break; pre = cur; if (cur -&gt; val &gt; key) cur = cur = cur -&gt; left; else cur = cur -&gt; right; } if (!pre &amp;&amp; root -&gt; val == key) return deleteTheNode(root); if (pre -&gt; left &amp;&amp; pre -&gt; left -&gt; val == key) pre -&gt; left = deleteTheNode(cur); if (pre -&gt; right &amp;&amp; pre -&gt; right -&gt; val == key) pre -&gt; right = deleteTheNode(cur); return root; }};","link":"/algorithm-train-day22/"},{"title":"代码随想录算法训练营第20天 | 654.最大二叉树, 617.合并二叉树, 700.二叉搜索树中的搜索, 98.验证二叉搜索树","text":"654.最大二叉树 代码随想录链接 题目 根据一个给定的数组, 使用数组中的最大值建立一个根节点, 再使用数组中最大值左侧的部分建立左子树, 使用数组中最大值右侧的部分建立右子树. 自己的想法 题目就很递归, 且给人的感觉像是前序遍历. 题解 递归法: 12345678910111213141516171819202122class Solution {public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return NULL; if (nums.size() == 1) return new TreeNode(nums[0]); // 特殊情况处理 int pivotIndex = 0, maxVal = INT_MIN; for (int i = 0; i &lt; nums.size(); i++) // 找最大值并根据最大值建立新节点. if (nums[i] &gt; maxVal) { maxVal = nums[i]; pivotIndex = i; } TreeNode *root = new TreeNode(nums[pivotIndex]); vector&lt;int&gt; leftTreeNodes(nums.begin(), nums.begin() + pivotIndex); // 左右分区 vector&lt;int&gt; rightTreeNodes(nums.begin() + pivotIndex + 1, nums.end()); root -&gt; left = constructMaximumBinaryTree(leftTreeNodes); // 递归地建立左右子树 root -&gt; right = constructMaximumBinaryTree(rightTreeNodes); return root; }}; 优化版的递归法: (主要优化在了没有建立新的数组, 每次递归时, 直接在原数组上进行分区) 12345678910111213141516171819202122232425class Solution {private: TreeNode* constructMaximumBinaryTreeRecursive(vector&lt;int&gt;&amp;nums, int left, int right) { if (left &gt;= right) return NULL; // 分区采用左闭右开区间, 左侧边界不能大于等于右侧边界 int pivotIndex = left, maxVal = INT_MIN; // 找分区中最大值并建立新节点 for (int i = left; i &lt; right; i++) if (nums[i] &gt; maxVal) { maxVal = nums[i]; pivotIndex = i; } TreeNode *root = new TreeNode(nums[pivotIndex]); root -&gt; left = constructMaximumBinaryTreeRecursive(nums, left, pivotIndex); // 根据分区建立左右子树 root -&gt; right = constructMaximumBinaryTreeRecursive(nums, pivotIndex + 1, right); return root; }public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { return constructMaximumBinaryTreeRecursive(nums, 0, nums.size()); }}; 617.合并二叉树 代码随想录链接 题目 合并两棵二叉树, 如果位置相同的节点都存在的话, 则进行值的相加, 如果一棵树的子树不存在, 则将另外一棵树上相同位置的子树复制过来. 自己的想法 两棵树一起前/中/后序遍历, 都存在则值相加, 有一棵树不存在某侧子树则使用另一棵的进行覆盖. 题解 递归法:(作为懒狗只写了中序遍历, 前序和后序只需要调整值相加的语句的位置就能完成) 123456789101112131415161718class Solution {private: TreeNode* traversal(TreeNode *root1, TreeNode* root2) { if (!root1 &amp;&amp; !root2) return nullptr; if (root1 &amp;&amp; !root2) return root1; // 处理一棵树上的一侧子树不存在而另一棵树上相应子树存在的情况 if (!root1 &amp;&amp; root2) return root2; root1 -&gt; left = traversal(root1 -&gt; left, root2 -&gt; left); // 递归合并左子树 root1 -&gt; val += root2 -&gt; val; root1 -&gt; right = traversal(root1 -&gt; right, root2 -&gt; right); // 递归合并右子树 return root1; }public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { return traversal(root1, root2); }}; 迭代法:(把要比较的节点成对地入栈比较, 像101.对称二叉树那题一样) 1234567891011121314151617181920212223242526272829303132333435class Solution {public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { if (!root1) return root2; if (!root2) return root1; stack&lt;TreeNode*&gt; st; st.push(root2); st.push(root1); while (!st.empty()) { TreeNode *node1 = st.top(); st.pop(); // 连取两个节点进行对比 TreeNode *node2 = st.top(); st.pop(); node1 -&gt; val += node2 -&gt; val; // 两个节点进行值相加 if (node1 -&gt; left &amp;&amp; node2 -&gt; left) { // 都存在左子树, 左子树入栈合并 st.push(node2 -&gt; left); st.push(node1 -&gt; left); } if (node1 -&gt; right &amp;&amp; node2 -&gt; right) { // 都存在右子树, 右子树入栈合并 st.push(node2 -&gt; right); st.push(node1 -&gt; right); } if (!(node1 -&gt; left) &amp;&amp; node2 -&gt; left) {// 处理一侧不存在的情况 node1 -&gt; left = node2 -&gt; left; } if (!(node1 -&gt; right) &amp;&amp; node2 -&gt; right) { node1 -&gt; right = node2 -&gt; right; } } return root1; }}; 700.二叉搜索树中的搜索 代码随想录链接 题目 在二叉搜索树中找到带有给定值的节点. 自己的想法 就...搜呗, (根节点)大了往左边找, 小了往右边找. 题解 递归法: 1234567891011121314class Solution {private: TreeNode* traversal(TreeNode* root, int val) { if (!root) return nullptr; if (root -&gt; val == val) return root; // 符合了就这个节点 if (root -&gt; val &gt; val) return traversal(root -&gt; left, val); // 大了往左边找 if (root -&gt; val &lt; val) return traversal(root -&gt; right, val);// 小了往右边找 return nullptr; // &quot;我不到啊&quot; }public: TreeNode* searchBST(TreeNode* root, int val) { return traversal(root, val); }}; 迭代法: 12345678910111213class Solution {public: TreeNode* searchBST(TreeNode* root, int val) { if (!root) return nullptr; TreeNode *cur = root; // 像不像遍历链表那样 while (cur) { if (cur -&gt; val == val) return cur; if (cur -&gt; val &gt; val) cur = cur -&gt; left; // 大了往左边找 else cur = cur -&gt; right; // 小了往右边找 } return nullptr; // 没找到 }}; 98.验证二叉搜索树 代码随想录链接 题目 判断给定的二叉树是否是二叉搜索树. 自己的想法 刚开始甚至还写了递归地判断左右孩子和遍历到的节点的大小关系, 这种情况就是忘了整个子树都要比根节点大/小的关系了. 自然是不行的. 看了题目的一些分析, 才回忆起来可以通过中序遍历的结果来进行判断, 又是王道上的题.都还回去了呜呜呜 题解 其实就中序遍历, 再加个遍历结果单调性的判断. 递归法: 123456789101112131415161718class Solution {private: vector&lt;int&gt; result; void traversal(TreeNode *root) { if (!root) return; traversal(root -&gt; left); result.push_back(root -&gt; val); // 中序遍历 traversal(root -&gt; right); }public: bool isValidBST(TreeNode* root) { traversal(root); for (int i = 1; i &lt; result.size(); i++) { // 遍历结果单调性判断 if (result[i] &lt;= result[i - 1]) return false; } return true; }}; 迭代法: 123456789101112131415161718192021222324252627282930class Solution {public: bool isValidBST(TreeNode* root) { if (!root) return true; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; st.push(root); while (!st.empty()) { // 中序遍历 TreeNode *node = st.top(); if (node) { st.pop(); if (node -&gt; right) st.push(node -&gt; right); st.push(node); st.push(NULL); if (node -&gt; left) st.push(node -&gt; left); } else { st.pop(); node = st.top(); st.pop(); result.push_back(node -&gt; val); } } for (int i = 1; i &lt; result.size(); i++) // 遍历结果单调性判断 if (result[i] &lt;= result[i - 1]) return false; return true; }};","link":"/algorithm-train-day20/"},{"title":"代码随想录算法训练营第21天 | 530.二叉搜索树的最小绝对差, 501.二叉搜索树中的众数, 236. 二叉树的最近公共祖先","text":"530.二叉搜索树的最小绝对差 代码随想录链接 题目 返回给定的二叉搜索树内, 节点之间最小的差值. 自己的思路 二叉搜索树的中序遍历的结果是有序的, 在其中中找相邻值最小的即可. 题解 递归法: 12345678910111213141516171819class Solution {private: vector&lt;int&gt; result; void traversal(TreeNode *root) { // 中序遍历, 记录结果 if (!root) return; traversal(root -&gt; left); result.push_back(root -&gt; val); traversal(root -&gt; right); }public: int getMinimumDifference(TreeNode* root) { traversal(root); int minGap = INT_MAX; for (int i = 1; i &lt; result.size(); i++) // 找相邻数据最小的差值 if (result[i] - result[i - 1] &lt; minGap) minGap = result[i] - result[i - 1]; return minGap; }}; 迭代法: 1234567891011121314151617181920212223242526272829303132class Solution {public: int getMinimumDifference(TreeNode* root) { if (!root) return 0; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; st.push(root); while (!st.empty()) { // 中序遍历 TreeNode *node = st.top(); if (node) { st.pop(); if (node -&gt; right) st.push(node -&gt; right); st.push(node); st.push(nullptr); if (node -&gt; left) st.push(node -&gt; left); } else { st.pop(); node = st.top(); st.pop(); result.push_back(node -&gt; val); } } int minGap = INT_MAX; for (int i = 1; i &lt; result.size(); i++) // 找最小差值 if (result[i] - result[i - 1] &lt; minGap) minGap = result[i] - result[i - 1]; return minGap; }}; 501.二叉搜索树中的众数 代码随想录链接 题目 给定一个二叉搜索树, 返回其中的众数. 自己的思路 可以将全部节点遍历一遍, 通过map记录出现次数, 再进行排序得到, 但这样就和普通的二叉树没区别了. 二叉搜索树的中序遍历是有序的, 相同的数都会排在一起, 可以通过这个特性, 在中序遍历的基础上, 找到众数. 题解 递归法: 12345678910111213141516171819202122232425262728293031class Solution {private: int maxCount = 0; // 统计出现次数最多的值出现了几次 int count = 0; // 统计当前值出现了几次 TreeNode *pre = NULL; // 标记上一个访问的节点, 判断和当前访问节点的值是否相等 vector&lt;int&gt; result; void searchBST(TreeNode *cur) { // 中序遍历 if (cur == NULL) return; searchBST(cur -&gt; left); if (pre == NULL) count = 1; // 第一个节点, pre为空的情况的处理 else if (pre -&gt; val == cur -&gt; val) count++; // 与上一个遍历的节点的值相同, 当前值出现次数+1 else count = 1; // 遇上一个点值不同, 重置出现次数 pre = cur; // pre后移 if (count == maxCount) result.push_back(cur -&gt; val); // 当前值统计次数和最大次数一致, 是可能得众数, 加入结果中 if (count &gt; maxCount) { // 若当前值出现的次数超过了前面值出现最多的次数, 证明众数的要求提高了 maxCount = count; // 更新maxCount result.clear(); // 之前的数都不是众数 result.push_back(cur -&gt; val); } searchBST(cur -&gt; right); }public: vector&lt;int&gt; findMode(TreeNode* root) { searchBST(root); return this -&gt; result; }}; 迭代法: (也是中序遍历, 甚至直接把上面对于中序遍历的中间节点的处理直接复制过来都没问题) 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: vector&lt;int&gt; findMode(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; int maxCount = 0; int count = 0; TreeNode *pre = nullptr; stack&lt;TreeNode*&gt; st; st.push(root); while (!st.empty()) { TreeNode *node = st.top(); if (node) { st.pop(); if (node -&gt; right) st.push(node -&gt; right); st.push(node); st.push(NULL); if (node -&gt; left) st.push(node -&gt; left); } else { // 和递归法中一样的处理思路 st.pop(); node = st.top(); st.pop(); if (pre == NULL) count = 1; else if (pre -&gt; val == node -&gt; val) count++; else count = 1; pre = node; if (count == maxCount) result.push_back(node -&gt; val); if (count &gt; maxCount) { maxCount = count; result.clear(); result.push_back(node -&gt; val); } } } return result; }}; 236. 二叉树的最近公共祖先 代码随想录链接 题目 给定一棵二叉树和其中的两个节点, 返回离这两个节点最近的公共祖先. 自己的思路 自己是想按照之前写二叉树的所有叶子路径那样来写这个题, 确实也实现了, 但是提交的时候就超时了. 看了卡尔哥的写法, 才发现不用写我那样复杂. 题解 自己想的通过遍历并记录路径来做的方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(!root) return nullptr; vector&lt;vector&lt;TreeNode*&gt;&gt; paths; // 记录节点的路径 vector&lt;TreeNode*&gt; p_path; // 记录p节点的路径 vector&lt;TreeNode*&gt; q_path; // 记录q节点的路径 stack&lt;TreeNode*&gt; st; // 用于遍历的栈 st.push(root); paths.push_back(vector&lt;TreeNode*&gt;{root}); bool hasFoundp = false; // 是否找到节点的标记 bool hasFoundq = false; while (!st.empty() &amp;&amp; (!hasFoundp || !hasFoundq)) { // 如果栈不为空, 且q p没有全部找到, 则继续遍历 auto node = st.top(); st.pop(); auto path = paths.back(); paths.pop_back(); if (!hasFoundp &amp;&amp; node == p) { // 如果找到了p节点, 就标记p的路径 hasFoundp = true; copy(path.begin(), path.end(), back_inserter(p_path)); } if (!hasFoundq &amp;&amp; node == q) { // 找到了q节点, 标记q的路径 hasFoundq = true; copy(path.begin(), path.end(), back_inserter(q_path)); } if (node -&gt; right) { // 右节点和其路径压栈 st.push(node -&gt; right); path.push_back(node -&gt; right); paths.push_back(path); path.pop_back(); } if (node -&gt; left) { // 左节点和其路径压栈 st.push(node -&gt; left); path.push_back(node -&gt; left); paths.push_back(path); } } int pathLength = min(p_path.size(), q_path.size()); for (int i = 1; i &lt; pathLength; i++) { // 找p, q路径中最后一个相同的节点 if (p_path[i] != q_path[i]) return p_path[i - 1]; } if (p_path[pathLength - 1] == q_path[pathLength - 1]) return p_path[pathLength - 1]; // 路径中最后一个节点相同, 则返回最后一个节点 return root; }}; 卡尔哥的思路: 其实就是通过后序递归, 先找到p, q节点, 如果从左右子树里都找到了p, q, 那么在递归中首先满足这个条件的节点, 一定就是二者的最近公共祖先. 123456789101112class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == q || root == p || !root) return root; // 如果该节点为空, 或者为p, 或q, 就返回该节点 TreeNode *left = lowestCommonAncestor(root -&gt; left, p, q); // 在左子树中找p, q的最近公共祖先 TreeNode *right = lowestCommonAncestor(root -&gt; right, p, q);// 在右子树中找 if (left &amp;&amp; right) return root; // 左右有p, q的存在, 本节点一定是祖先 if (left &amp;&amp; !right) return left;// 左子树中有目标节点, 返回左子树中的目标节点 if (!left &amp;&amp; right) return right;// 右子树中有目标节点, 返回右子树中的目标节点 return NULL; }};","link":"/algorithm-train-day21/"},{"title":"代码随想录算法训练营第23天 | 669.修剪二叉搜索树, 108.将有序数组转换为二叉搜索树, 538.把二叉搜索树转换为累加树, 二叉树总结","text":"669.修剪二叉搜索树 代码随想录链接 题目 LeetCode-669.修剪二叉搜索树 给定一个二叉搜索树和一个左闭右闭的区间, 要求将二叉搜索树中不符合的节点去除, 并保持在树中节点的相对位置. 自己的想法 刚开始是想着和昨天的题目一样, 遇见一个不符合的节点就把这个节点删掉, 试着写了一分代码, 全是Run Time Error. 在看卡尔哥的写法时, 发现自己做题目还是忽略了好些二叉搜索树的性质, 没有真正去理解(也可能是上午刷题太困了) 个人感觉这道题目非常重要的一点是: 如果遇到一个节点的值在给定区间左侧(i.e. 值小于整个区间), 那么其左子树必定是要被删除的; 同理, 如果一个节点的值在给定区间的右侧(i.e. 值大于整个区间), 那么其右子树是必定会被删除的, 可以直接忽略. 题解 递归法: 1234567891011class Solution {public: TreeNode* trimBST(TreeNode* root, int low, int high) { if (root == nullptr) return root; // 空指针直接返回 if (root -&gt; val &gt; high) return trimBST(root -&gt; left, low, high); // 如果节点值在区间右侧, 则抛弃该节点和其右子树, 用剪枝后的左子树来代替当前节点 if (root -&gt; val &lt; low) return trimBST(root -&gt; right, low, high); // 如果节点值在区间左侧, 则抛弃该节点和其左子树, 用剪枝后的右子树来代替当前节点 root -&gt; left = trimBST(root -&gt; left, low, high); // 如果当前节点的值符合要求, 就再对左右子树进行剪枝 root -&gt; right = trimBST(root -&gt; right, low, high); return root; }}; 迭代法: 12345678910111213141516171819202122232425class Solution {public: TreeNode* trimBST(TreeNode* root, int low, int high) { if (!root) return root; while (root &amp;&amp; (root -&gt; val &gt; high || root -&gt; val &lt; low)) { // 如果根节点不在目标范围内, 就移动根节点, 同时相应地抛弃一侧的子树(因为该侧子树和根节点一样, 都在给定范围之外) if (root -&gt; val &gt; high) root = root -&gt; left; else root = root -&gt; right; } TreeNode *cur = root; // 访问子树节点的指针 while (cur) { // 从根节点, 沿着左指针找下去 while (cur -&gt; left &amp;&amp; cur -&gt; left -&gt; val &lt; low) { // 找到一个不符合条件的节点, 使用其右子树来代替该节点和其左子树, 直至该位置的节点在范围内 cur -&gt; left = cur -&gt; left -&gt; right; } cur = cur -&gt; left; } cur = root; // 从根节点再次向右找不符合的节点 while (cur) { while (cur -&gt; right &amp;&amp; cur -&gt; right -&gt; val &gt; high) { // 找到一个不符合条件的节点, 使用其左子树来代替该节点和其右子树, 直至该位置的节点在范围内 cur -&gt; right = cur -&gt; right -&gt; left; } cur = cur -&gt; right; } return root; }}; 108.将有序数组转换为二叉搜索树 代码随想录链接 题目 LeetCode-108.将有序数组转换为二叉搜索树 将一个给定的有序数组转化为一棵平衡二叉树. 自己的想法 像从中序和后序遍历结果构建二叉树那样, 去区间中值, 左右两侧分别递归就可以. 题解 递归法: 12345678910111213141516class Solution {private: TreeNode* traversal(vector&lt;int&gt; &amp;nums, int left, int right) { if (left &gt; right) return nullptr; int mid = left + (right - left) / 2; // 取中间值 TreeNode *node = new TreeNode(nums[mid]); // 建立中间节点 node -&gt; left = traversal(nums, left, mid - 1); // 左侧递归 node -&gt; right = traversal(nums, mid + 1, right); // 右侧递归 return node; // 返回子树 }public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { TreeNode *root = traversal(nums, 0, nums.size() - 1); return root; }}; 迭代法: 使用三个队列, 分别记录子树的根节点, 这棵子树的左区间, 以及这棵子树的右区间. 12345678910111213141516171819202122232425262728293031323334class Solution {public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return nullptr; TreeNode *root = new TreeNode(0); queue&lt;TreeNode*&gt; nodeQue; // 子树根节点, 赋值操作在下面完成 queue&lt;int&gt; leftIndexes, rightIndexes; // 相应位置的子树的左右区间 nodeQue.push(root); // 推入根节点 leftIndexes.push(0); // 推入左区间 rightIndexes.push(nums.size() - 1); // 推入右区间 while (!nodeQue.empty()) { TreeNode *cur = nodeQue.front(); nodeQue.pop(); // 取子树的根节点和其左右区间 int left = leftIndexes.front(); leftIndexes.pop(); int right = rightIndexes.front(); rightIndexes.pop(); int mid = left + (right - left) / 2; // 求区间中值索引 cur -&gt; val = nums[mid]; // 给子树根节点赋值 if (left &lt; mid) { // 给左子树建立根节点并推入节点队列, 推入左子树的区间 cur -&gt; left = new TreeNode(0); nodeQue.push(cur -&gt; left); leftIndexes.push(left); rightIndexes.push(mid - 1); } if (right &gt; mid) { // 给右子树建立根节点并推入节点队列, 推入右子树的区间 cur -&gt; right = new TreeNode(0); nodeQue.push(cur -&gt; right); leftIndexes.push(mid + 1); rightIndexes.push(right); } } return root; }}; 能不能用栈来代替队列呢? 可以的, 无非就是使用队列时, 构建节点的顺序是从上至下, 从左至右; 使用栈时的顺序是从下至上, 从右至左. 538.把二叉搜索树转换为累加树 代码随想录链接 题目 LeetCode-538.把二叉搜索树转换为累加树 将二叉搜索树中每个节点的值都修改为整棵树中大于等于自己的节点的值之和. 自己的想法 中序遍历, 想着先遍历一下, 保存一个指针的数组, 再计算一堆应该修改的数, 最后通过遍历保存的数组把值给修改了.Too yong too simple, sometimes naive 其实中序遍历反过来就可以一次遍历完成操作, 反过来的操作刚好是由大到小遍历二叉搜索树. 题解 递归法: 12345678910111213141516class Solution {private: int sum = 0; void traversal(TreeNode *root) { if (!root) return; traversal(root -&gt; right); // 遍历右子树 sum += root -&gt; val; // 修改和 root -&gt; val = sum; // 赋值节点 traversal(root -&gt; left); // 遍历右子树 }public: TreeNode* convertBST(TreeNode* root) { traversal(root); return root; }}; 迭代法: 同样也是中序遍历反过来. 123456789101112131415161718192021222324252627282930class Solution {public: TreeNode* convertBST(TreeNode* root) { if (!root) return root; stack&lt;TreeNode*&gt; st; int sum = 0; st.push(root); while (!st.empty()) { TreeNode *node = st.top(); if (node) { st.pop(); if (node -&gt; left) st.push(node -&gt; left); st.push(node); st.push(NULL); if (node -&gt; right) st.push(node -&gt; right); } else { st.pop(); node = st.top(); st.pop(); sum += node -&gt; val; // 修改和 node -&gt; val = sum; // 赋值 } } return root; }}; 二叉树总结 代码随想录链接 二叉树算是代码随想录里第一个这么长的篇章吧. 总共60天的训练营, 后面37天都是回溯法动态规划贪心算法, 只能说是很刺激了.","link":"/algorithm-train-day23/"},{"title":"代码随想录算法训练营第28天 | 93.复原IP地址, 78.子集, 90.子集II","text":"今天题目都是自己A出来的, 不错. 93.复原IP地址 代码随想录链接 题目 LeetCode-93.复原IP地址 给定一个只包含数字的字符串, 求这个字符串所能分割成的所有合法的IPv4地址. 自己的想法 回溯法, 一个IPv4地址由四个位置组成, for循环横向扩展当前位置的长度, 长度至多为3, 如果当前位置的的字符串合法. 则推入当前的结果当中, 并纵向递归进行后续位置的分割. 结束条件是当前IP的记录满足四个位置, 且已经访问了字符串的所有字符. 题解 1234567891011121314151617181920212223242526272829303132333435363738class Solution {private: vector&lt;string&gt; result; // 所有可能的结果 vector&lt;int&gt; path; // 当前的IP划分 int pathLen = 0; // 已经划分掉的字符数 bool isValid(const string &amp;s, int start, int end) { string str = s.substr(start, end - start + 1); if (str[0] == '0' &amp;&amp; str.size() &gt; 1) return false; // 如果开头是0且不止一个字符, 也是不行的 int num = stoi(str); // 懒狗选择使用stoi来转int if (num &lt; 256 &amp;&amp; num &gt;= 0) return true; // 大于等于0, 小于256符合条件 return false; } void backtracing(const string &amp;s, int position, int startIndex) { if (path.size() == 4 &amp;&amp; pathLen == s.size()) { // 划分出了4块且所有字符都包含在内时, 才算满足条件 string addr = &quot;&quot;; for (int seg : path) addr += to_string(seg) + &quot;.&quot;; // 拼接IPv4地址 addr.pop_back(); // 去掉最后一个'.' result.push_back(addr); return; } for (int i = startIndex; i &lt; startIndex + 3 &amp;&amp; position &lt; 4 &amp;&amp; i &lt; s.size(); i++) { // 横向扩展当前位置的长度 if (isValid(s, startIndex, i)) { // 如果当前位置的取值合法, 再进行纵向递归 path.push_back(stoi(s.substr(startIndex, i - startIndex + 1))); // 人生苦短, 我选STL pathLen += i - startIndex + 1; // 统计当前划分的字符数 backtracing(s, position + 1, i + 1); // 递归 path.pop_back(); // 回溯 pathLen -= i - startIndex + 1; } } }public: vector&lt;string&gt; restoreIpAddresses(string s) { backtracing(s, 0, 0); return result; }}; 78.子集 代码随想录链接 题目 LeetCode-78.子集 给定一个没有重复元素的数组, 返回这个数组的所有子集. 自己的想法 就回溯法, 但记录结果的时机和结束递归的条件需要注意一下. 题解 12345678910111213141516171819202122class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracing(vector&lt;int&gt; &amp;nums, int startIndex) { result.push_back(path); // 不管有什么, 都记录下来 if (startIndex &gt;= nums.size()) { // 到头了, 就结束递归 return; } for (int i = startIndex; i &lt; nums.size(); i++) { // for循环横向决定当前位置包含哪个元素 path.push_back(nums[i]); backtracing(nums, i + 1); // 子集不能重复使用当前位置的元素, 传入startIndex需要是 i + 1 path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { backtracing(nums, 0); return result; }}; 90.子集II 代码随想录链接 题目 LeetCode-90.子集II 给定一个整数数组, 其中可能包含重复元素, 返回所有可能的子集. 子集中不能重复. 自己的想法 在有重复元素的前提下避免重复子集, 这是与LeetCode-40.组合总和II中一样的要求. 同样地, 我们也可以再次使用那道题避免重复的方法来解决这道题. 题解 12345678910111213141516171819202122232425class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracing(vector&lt;int&gt; &amp;nums, int startIndex, vector&lt;bool&gt; &amp;used) { result.push_back(path); // 不管有什么都记录下来 if (startIndex &gt;= nums.size()) return; for (int i = startIndex; i &lt; nums.size(); i++) { if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue; // 如果和左侧数一样, 且左侧没有被使用, 就跳过自身来避免重复 path.push_back(nums[i]); used[i] = true; // 标记当前数据已经在当前子集里了 backtracing(nums, i + 1, used); path.pop_back(); // 回溯 used[i] = false; } }public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { vector&lt;bool&gt; used(nums.size(), false); sort(nums.begin(), nums.end()); backtracing(nums, 0, used); return result; }};","link":"/algorithm-train-day28/"},{"title":"代码随想录算法训练营第24天 | 回溯法理论基础, 77.组合","text":"回溯法理论基础 代码随想录链接 什么是回溯 回溯是一种搜索的方式, 其本质是穷举, 是递归的副产品, 只要有递归就会有回溯. 回溯法难理解, 但并不高校, 因为其本质是穷举所有可能, 然后筛选出符合要求的答案, 最多只能通过剪枝来减少穷举的部分, 但不能改变其本质. 回溯能解决的问题 组合问题 N个数里找出k个数的集合(无序) 切割问题 一个字符串按照一定的规则有几种切割方式 子集问题 N个数找出K个熟的排列(有序) 排列问题 N个数按照一定的规则的全排列 棋盘问题 N皇后, 解数独等 理解回溯法 回溯法解决的问题都可以抽象为树型结构, 集合的大小就是熟的宽度, 递归的深度, 就是熟的深度. 递归需要有终止条件, 所以这棵递归树一定是一棵高度有限的树. 回溯法模板 回溯三部曲: 回溯法函数模板返回值及参数 回溯算法中函数返回值一般为void, 参数需要在写逻辑时确定需要什么参数 1void backtracing(DataType param) 回溯函数终止条件 在回溯树中的叶子节点时的处理逻辑, 搜到叶子结点, 也就找到了满足条件的一条答案, 把这个答案存放起来, 并结束本层递归. 123456if (endCondition) { /** * Store the result; */ return;} 回溯遍历过程 回溯法遍历过程 for循环横向遍历, 递归进行纵向遍历 12345for (DataType child : thisLayer) { processThisNode(); backtracing(Path, Selection); // Recursion back(); // 回溯，撤销处理结果} 综上可以得出回溯法模板框架如下: 1234567891011121314void backtracing(type&lt;A&gt; param) { if (endCondition) { /** * Store the result; */ return; } for (DataType child : thisLayer) { processThisNode(); backtracing(Path, Selection); // Recursion back(); // 回溯，撤销处理结果 }} 77.组合 代码随想录链接 题目 LeetCode-77.组合 给定两个整数 n 和 k, 返回在[1, n]范围中的所有的 K 个数的集合. 自己的想法 暴力法第24天了哥, 别暴力了 上面不是才学了回溯的理论基础吗, 这道题肯定要拿回溯来做, 回溯的层序遍历可以是找剩下的数中组合开头的数, 然后递归地往结果内加下一个k-1个数的组合. 由于求的是组合, 所以在找k-1个数的组合的时候, 就一定要指明找的边界, 不能把找过的数再次放入. 解法 123456789101112131415161718192021class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracing(int n, int k, int startIndex) { // 回溯递归 if (path.size() == k) { // 集合中满足了k个数, 则记录结果, 结束递归 result.push_back(path); return; } for (int i = startIndex; i &lt;= n; i++) { // 横向遍历 path.push_back(i); // 推入这个数 backtracing(n, k, i + 1); // 纵向递归, 回溯法 path.pop_back(); // 完成了当前这个数的组合的查找, 取出这个数 } }public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { backtracing(n, k, 1); return this -&gt; result; }}; 上面的代码仍然存在一些不必要的步骤, 进行for循环时, 如果i右侧的数不足以填满集合内剩下的空位, 那么就没有必要继续for循环下去, 据此可以进行剪枝操作: 123456789101112131415161718192021class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracing(int n, int k, int startIndex) { if (path.size() == k) { result.push_back(path); return; } for (int i = startIndex; i &lt;= n - (k - path.size() - 1); i++) { // 新增了判断是否还有足够的数来填充集合空位 path.push_back(i); backtracing(n, k, i + 1); path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { backtracing(n, k, 1); return this -&gt; result; }};","link":"/algorithm-train-day24/"},{"title":"代码随想录算法训练营第29天 | 491.递增子序列, 46.全排列, 47.全排列 II","text":"491.递增子序列 代码随想录链接 题目 LeetCode-491.递增子序列 给定一个数字序列, 返回所有递增的子序列, 每个子序列里至少有两个元素. 自己的想法 递增的子序列, 需要注意的点是这是个序列, 子序列中元素的相对位置是要保持和原序列中相对位置的. 针对于子序列中元素的相对顺序不变, 需要在回溯函数的参数中加入startIndex来标定纵向递归左侧的起始位置. 横向的for循环需要注意两个条件: * 新加入的数据必须要大于当前序列末尾的数据 * 当前位置已经出现过的元素不可以再次出现 递归的结束条件是标定的起始位置startIndex抵达了数组的边界. 当目前子序列中有两个及以上元素时, 需要将当前子序列保存到结果当中. 题解 123456789101112131415161718192021222324class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; current; void backtracing(vector&lt;int&gt; &amp;nums, int startIndex) { if (current.size() &gt;= 2) result.push_back(current); // 当前子序列长度大于2时, 保存该序列 if (startIndex &gt;= nums.size()) return; // 超越了边界, 则结束递归 unordered_set&lt;int&gt; set; // 当前位置的元素去重 for (int i = startIndex; i &lt; nums.size(); i++) { if ((current.empty() || current.back() &lt;= nums[i]) &amp;&amp; set.find(nums[i]) == set.end()) { // 当当前位置的元素大于子序列末尾元素且不重复出现时, 进行纵向递归 set.insert(nums[i]); current.push_back(nums[i]); backtracing(nums, i + 1); current.pop_back(); } } }public: vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) { backtracing(nums, 0); return result; }}; 46.全排列 代码随想录链接 题目 LeetCode-46.全排列 给定一个不含重复数字的数组, 返回其全部的全排列. 自己的想法 要求比较少, 不含重复数字的话其实就是$ P_n^n $ 个结果. 使用一个used数组来标记当前元素是否已经使用, 横向for循环决定当前位置是哪个元素, 纵向递归处理下一位置的元素. 由于是全排列, 所以for循环的起始点每次都应该是数组左侧开始. 题解 123456789101112131415161718192021222324252627class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; current; void backtracing(vector&lt;int&gt; &amp;nums, vector&lt;bool&gt; &amp;used) { if (current.size() == nums.size()) { // 如果当前数组长度已经和原数组长度相同, 证明所有元素都已加入, 需要记录结果 result.push_back(current); return; } for (int i = 0; i &lt; nums.size(); i++) { // 横向决定当前位置是哪个元素 if (!used[i]) { // 元素没有使用过时才进行递归 current.push_back(nums[i]); used[i] = true; backtracing(nums, used); current.pop_back(); used[i] = false; } } }public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;bool&gt; used(nums.size(), false); backtracing(nums, used); return result; }}; 47.全排列 II 代码随想录链接 题目 LeetCode-47.全排列 II 给定可能包含重复数字的序列, 返回不重复的全排列. 自己的想法 就是上面两道题简单缝合了一下. 需要使用一个bool数组来标记哪些位置的数据已经加入了组合, 又需要保证当前位置不重复出现同一个数. 题解 12345678910111213141516171819202122232425262728class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; current; void backtracing(vector&lt;int&gt; &amp;nums, vector&lt;bool&gt; &amp;used) { if (current.size() == nums.size()) { // current数组大小等于原数组大小, 证明所有元素均已加入, 将结果保存 result.push_back(current); return; } unordered_set&lt;int&gt; set; // 用来确保当前位置没有重复的数据出现 for (int i = 0; i &lt; nums.size(); i++) { if (set.find(nums[i]) != set.end() || used[i]) continue; // 如果for循环到的元素没有出现过, 且也没有在组合里, 就进行纵向递归. set.insert(nums[i]); // 标记出现过的元素 current.push_back(nums[i]); used[i] = true; backtracing(nums, used); current.pop_back(); used[i] = false; } }public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { vector&lt;bool&gt; used(nums.size(), false); backtracing(nums, used); return result; }};","link":"/algorithm-train-day29/"},{"title":"代码随想录算法训练营第27天 | 39.组合总和, 40.组合总和II, 131.分割回文串","text":"39.组合总和 代码随想录链接 题目 LeetCode-39.组合总和 给定一个没有重复元素的数组, 在可重复选取元素的情况下, 返回所有之和等于目标值的组合, 组合与组合之间包含的不同数字的个数必须是不同的. 自己的想法 就模板题, 按照回溯法总结的模板就可以. 题解 12345678910111213141516171819202122232425class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; current; int sum = 0; void backtracing(vector&lt;int&gt; &amp;candidates, int target, int startIndex) { if (sum &gt;= target) { if (sum == target) result.push_back(current); // 满足之和等于目标值就记录下来 return; } for (int i = startIndex; i &lt; candidates.size(); i++) { sum += candidates[i]; current.push_back(candidates[i]); backtracing(candidates, target, i); // 由于可以重复选取已经选过的值, startIndex的传参为i sum -= candidates[i]; current.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { backtracing(candidates, target, 0); return this -&gt; result; }}; 40.组合总和II 代码随想录链接 题目 LeetCode-40.组合总和II 和上题类似, 不过可以出现重复元素, 且不同位置的元素只能被选中一次. 自己的想法 直接把上题的答案拿过来是不行的, 因为要考虑位置不同的相同元素在回溯时会产生的相同组合. 可以将相同的元素排在一起, 也就是排序, 然后再通过额外的变量, 保证两个相同的元素只出现一次时, 只考虑一遍情况. 题解 1234567891011121314151617181920212223242526272829303132class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; current; int sum = 0; void backtracing(vector&lt;int&gt; &amp;candidates, int target, int startIndex, vector&lt;bool&gt; &amp;used) { if (sum &gt; target) return; if (sum == target) { result.push_back(current); return; } for (int i = startIndex; i &lt; candidates.size(); i++) { if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !used[i - 1]) continue; // 如果和左侧的值相同, 且左侧的值未被使用, 代表当前处理的情况和左侧值被选中但本位置的值未被选中的情况相同, 不应再重复考虑 sum += candidates[i]; used[i] = true; current.push_back(candidates[i]); backtracing(candidates, target, i + 1, used); // 由于每个位置的值只能取一次, 所以递归时startIndex的参数需要是i+1 sum -= candidates[i]; used[i] = false; current.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;bool&gt; used(candidates.size(), false); // 初始化一个用于标记某个位置的元素是否被取出的布尔型数组 sort(candidates.begin(), candidates.end()); // 通过排序将一样的值排列在一起 backtracing(candidates, target, 0, used); return this -&gt; result; }}; 131.分割回文串 代码随想录链接 题目 LeetCode-131.分割回文串 给定一个字符串, 要求返回所有分割方式, 每种分割方式内的分割出的子串都是回文. 自己的想法 刚开始懵了. 真的不知道咋写.但是毕竟知道是要拿回溯法写 分割字符串和上面的取组合其实是类似的. for循环横向遍历的是当前字符串不断从startIndex开始向右延长, 纵向递归的是对剩下的字符串进行分割. 在分割的过程中如果一种分割方法产生的子串不是回文, 则应该立即结束这种分割方式, 不应进行纵向递归. 题解 12345678910111213141516171819202122232425262728293031class Solution {private: vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; current; void backtracing(const string &amp;s, int startIndex) { if (startIndex &gt;= s.size()) { // 如果递归到了startIndex大于等于字符串长度的位置, 说明current内目前存的都是回文子串, 应该保存当前结果 result.push_back(current); return; } for (int i = startIndex; i &lt; s.size(); i++) { if (isPalindrome(s, startIndex, i)) { current.push_back(s.substr(startIndex, i - startIndex + 1)); // 当前以startIndex开头, 以i结尾的字符串是回文时, 才应该推入current,并进行纵向递归 } else continue; backtracing(s, i + 1); // 递归分割下一个当前子串之后一个字符开始的字符串 current.pop_back(); } } bool isPalindrome(const string &amp;s, int start, int end) { // 双指针法判断是否为回文 for (int i = start, j = end; i &lt; j; i++, j--) { if (s[i] != s[j]) return false; } return true; }public: vector&lt;vector&lt;string&gt;&gt; partition(string s) { backtracing(s, 0); return result; }};","link":"/algorithm-train-day27/"},{"title":"代码随想录算法训练营第17天 | 110.平衡二叉树, 257. 二叉树的所有路径, 404.左叶子之和","text":"110.平衡二叉树 代码随想录链接 题目 判断一个二叉树是否是平衡二叉树, 即该二叉树的任意一个子树的左右子树高度差都不超过1. 自己的想法 递归判断左右子树的高度是否满足要求. 题解 递归法： 123456789101112131415class Solution {private: int getHeight(TreeNode* node) { if (!node) return 0; int leftHeight = getHeight(node -&gt; left); // 递归判断左子树的高度 if (leftHeight == -1) return -1; // 若左子树不平衡，则直接返回-1 int rightHeight = getHeight(node -&gt; right); // 递归判断右子树的高度 if (rightHeight == -1) return -1; // 若右子树不平衡，则直接返回-1 return abs(leftHeight - rightHeight) &gt; 1 ? -1 : 1 + max(leftHeight, rightHeight); // 若左右子树平衡，根据左右子树高度差判断 }public: bool isBalanced(TreeNode* root) { return getHeight(root) == -1 ? false : true; }}; 迭代法： 123456789101112131415161718192021222324252627282930313233343536class Solution {private: int getDepth(TreeNode* cur) { // 层序遍历，获得输入节点的高度 if (!cur) return 0; int depth = 0; queue&lt;TreeNode *&gt; que; que.push(cur); while (!que.empty()) { int qsize = que.size(); depth++; for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return depth; }public: bool isBalanced(TreeNode* root) { if (!root) return true; stack&lt;TreeNode *&gt; st; st.push(root); while (!st.empty()) { // 先序遍历 TreeNode *node = st.top(); st.pop(); if (abs(getDepth(node -&gt; left) - getDepth(node -&gt; right)) &gt; 1) { return false; } // 判断左右子树高度差是否大于一 if (node -&gt; right) st.push(node -&gt; right); if (node -&gt; left) st.push(node -&gt; left); } return true; }}; 这个地方的迭代法重复计算了好些层的数值，效率没有上面递归法高。 257.二叉树的所有路径 代码随想录链接 题目 返回从根节点出发到达每个叶子节点的路径。 自己的想法 前序遍历，访问一个节点的操作是判断其是否为叶子节点，若为叶子节点，则从根节点到这个节点的路径记录下来。 题解 递归法： 12345678910111213141516171819202122232425262728293031class Solution {private: void traversal(TreeNode *cur, vector&lt;int&gt; &amp;path, vector&lt;string&gt; &amp;result) { path.push_back(cur -&gt; val); // 访问到这个节点时，再将该节点加入路径 if (!(cur -&gt; left) &amp;&amp; !(cur -&gt; right)) { // 如果是叶子节点，就记录路径 string sPath; for (int i = 0; i &lt; path.size() - 1; i++) { sPath += to_string(path[i]); sPath += &quot;-&gt;&quot;; } sPath += to_string(cur -&gt; val); result.push_back(sPath); } if (cur -&gt; left) { // 递归左孩子 traversal(cur -&gt; left, path, result); path.pop_back(); // 递归左子树完毕后，将左孩子从路径中去除 } if (cur -&gt; right) { // 递归右孩子 traversal(cur -&gt; right, path, result); path.pop_back(); // 递归右子树完毕后，将右孩子从路径中去除 } }public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) { vector&lt;string&gt; result; vector&lt;int&gt; path; if (!root) return result; traversal(root, path, result); return result; }}; 迭代法： 前序遍历，并使用栈来记录当前遍历从根节点出发的路径。 12345678910111213141516171819202122232425262728class Solution {public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) { vector&lt;string&gt; result; stack&lt;string&gt; pathSt; stack&lt;TreeNode*&gt; st; if (!root) return result; st.push(root); pathSt.push(to_string(root -&gt; val)); while (!st.empty()) { // 使用栈来遍历节点 TreeNode *node = st.top(); st.pop(); string path = pathSt.top(); pathSt.pop(); if (!(node -&gt; left) &amp;&amp; !(node -&gt; right)) { result.push_back(path); } // 如果当前节点是椰子节点, 就记录下来该节点的路径 if (node -&gt; right) { st.push(node -&gt; right); pathSt.push(path + &quot;-&gt;&quot; + to_string(node -&gt; right -&gt; val)); } // 栈内推入节点和节点的路径 if (node -&gt; left) { st.push(node -&gt; left); pathSt.push(path + &quot;-&gt;&quot; + to_string(node -&gt; left -&gt; val)); } } return result; }}; 404.左叶子之和 代码随想录链接 题目 返回给定的二叉树的所有左叶子结点的值之和. 自己的想法 在遍历的时候加一个判断, 如果左孩子存在且是叶子结点, 就将左孩子的值加和. 题解 递归法: 1234567891011121314class Solution {public: int sumOfLeftLeaves(TreeNode* root) { if (!root) return 0; if (!(root -&gt; left) &amp;&amp; !(root -&gt; right)) return 0; int leftVal = sumOfLeftLeaves(root -&gt; left); // 求左子树中的左叶子结点值之和 if (root -&gt; left &amp;&amp; !(root -&gt; left -&gt; left) &amp;&amp; !(root -&gt; left -&gt; right)) { // 如果左孩子是个叶子结点, 将其值加和 leftVal += root -&gt; left -&gt; val; } int rightVal = sumOfLeftLeaves(root -&gt; right); // 求右子树中左叶子结点值之和 return leftVal + rightVal; }}; 迭代法: 1234567891011121314151617181920212223242526class Solution {public: int sumOfLeftLeaves(TreeNode* root) { int result = 0; if (!root) return result; stack&lt;TreeNode *&gt; st; st.push(root); while (!st.empty()) { // 统一写法的中序遍历 TreeNode *node = st.top(); if (node) { st.pop(); st.push(node); st.push(NULL); if (node -&gt; right) st.push(node -&gt; right); if (node -&gt; left) st.push(node -&gt; left); } else { // &quot;访问&quot;一个节点, 判断左孩子是不是叶子结点 st.pop(); node = st.top(); st.pop(); if (node -&gt; left &amp;&amp; !(node -&gt; left -&gt; left) &amp;&amp; !(node -&gt; left -&gt; right)) result += node -&gt; left -&gt; val; } } return result; }};","link":"/algorithm-train-day17/"},{"title":"代码随想录算法训练营第3天 | 链表基础，203.移除链表元素，707.设计链表，206.反转链表","text":"链表理论 链表，顾名思义，是链状的数据的集合。在计算机编程语言当中，链表通常的表现形式为： 单链表，图源自代码随想录 根据不同的节点构成，链表可以被分为： 单链表 如上面的图所示，即为单链表，“单”指的是单向，即一个节点除了所存储的数据外，只保留其下一个节点的指针。 双链表 在单链表的基础上，在每个节点上增加一个指向上一个节点的指针，将根据这个节点能查询到的节点扩展为前后节点。 双向链表 循环链表 在双链表或者单链表的基础上，使链表首尾相连，就形成了一个循环链表。 循环链表 链表的存储方式与数组不同，数组通常是连续存储的，通过索引和数组起始位置即可以\\(O(1)\\)的时间访问到指定的数据，但链表中的节点不是连续存储的，需要从链首指针开始，依次查询到指定位置才可以，需要花费\\(O(n)\\)的时间。 链表存储示意图 根据链表的定义，一个常见的单链表的节点可以用C++表示为： 12345struct Node* { int data; // 该节点所存储的数据 Node* next; // 指向下一个节点的指针 Node(int x) : data(x), next(nullptr) {} // 节点的构造函数，可选}; 一个常见的双链表节点可以用C++表示为： 123456struct Node* { int data; // 该节点所存储的数据 Node* prev; // 指向前一个节点的指针 Node* next; // 指向下一个节点的指针 Node(int x) : data(x), prev(nullptr), next(nullptr) {} // 节点的构造函数，可选}; 203.移除链表元素 代码随想录链接 题目 LeetCode-203 删除链表中等于给定值的所有节点。 自己的想法 自己首先想到的还是使用链表原有的头和尾来完成，对头进行单独的判断处理，如果头携带值就等于给定值，则不断地把头设置为下一个节点，当头所携带的值不是给定值之后，再对链表后面进行处理，自己写的版本即为解法一。 解法一 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { ListNode* cur = NULL; // 为了保存当前使用的节点而设立的一个指针 while (head != NULL &amp;&amp; head -&gt; val == val) { // 如果头指针指向的节点携带的值等于给定值 cur = head; // 保存头结点的地址 head = head -&gt; next; // 将头指向下一个节点，使下一个节点成为头结点，这一步之后原来的头结点已经被剥离链表 delete cur; // 释放掉原来头结点的空间 } cur = head; // 从头结点开始遍历，此时头结点的值不等于给定值，所以我们下面只需要看cur -&gt; next的值是否等于给定值 while (cur != NULL) { // 当遍历节点不为空时 if (cur -&gt; next != NULL &amp;&amp; cur -&gt; next -&gt; val == val) { // 如果当前节点存在下一个节点且下一个节点的数据等于给定值 ListNode* toDel = cur -&gt; next; // 标记需要被删除的节点 cur -&gt; next = toDel -&gt; next; // 更新当前节点的next指针，将其指向被删除节点的下一个节点，此步之后被删除节点已被剥离链表 delete toDel; // 释放被删除节点的空间 } else { // 如果当前节点的下一个节点不存在或者其值不等于给定值 cur = cur -&gt; next; // 则移动节点 } } return head; // 返回链表表首指针 }}; 由于遍历了整个链表，故时间复杂度为\\(O(n)\\)，使用了常数个额外变量，空间复杂度为\\(O(1)\\)。 解法二 下面这种方法的思想和上面是一样的，只不过使用了一个假表首来使得代码实现起来比较简单。之前学过但是自己想的时候就是想不起来这种做法 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); dummyHead -&gt; next = head; ListNode* cur = dummyHead; while (cur -&gt; next != NULL) { if (cur -&gt; next -&gt; val == val) { ListNode* toDel = cur -&gt; next; cur -&gt; next = toDel -&gt; next; delete toDel; } else { cur = cur -&gt; next; } } head = dummyHead -&gt; next; delete dummyHead; return head; }}; 由于遍历了整个链表，故时间复杂度为\\(O(n)\\)，使用了常数个额外变量，空间复杂度为\\(O(1)\\)。 707.设计链表 代码随想录链接 题目 Leetcode-707 就是实现链表的增删查功能，改太简单了。上过数据结构的同学应该能非常熟练地完成才对。 自己的思考 尽量地多使用伪表首来实现功能，让代码的逻辑看起来更清晰一些。 解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyLinkedList {public: struct Node { int val; Node* next; Node(int val): val(val), next(nullptr){} }; MyLinkedList() { _dummyHead = new Node(0); // 内部实现一个假表首 _size = 0; // 内部的变量，用于存储当前链表的大小 } int get(int index) { if (index &gt;= _size || index &lt; 0) return -1; // 在index不正确时，按照题目要求返回-1 Node* cur = _dummyHead -&gt; next; // 声明一个用于遍历链表的节点 while (index--) cur = cur-&gt;next; // 根据index定位到节点 return cur -&gt; val; // 返回节点值 } void addAtHead(int val) { Node* toAdd = new Node(val); // 实例化一个新的节点来存储值 toAdd -&gt; next = _dummyHead -&gt; next; // 将新的节点的next指针指向当前的（真）头指针，让头节点成为其下一个节点 _dummyHead -&gt; next = toAdd; // 将假表首的next指针指向新的节点，代表新节点成为了（真）头指针 _size++; // 别忘了更新链表的大小 } void addAtTail(int val) { Node* cur = _dummyHead; // 依次遍历到链表的末尾，实例化一个新的节点，并将原末尾节点的next指针指向新的节点 while (cur -&gt; next != NULL) cur = cur -&gt; next; Node* toAdd = new Node(val); cur -&gt; next = toAdd; _size++; } void addAtIndex(int index, int val) { // 类似于get函数的做法，先定位到index指向的节点，然后根据题意将节点插入在该节点之前（修改前节点的next指针和新节点的next指针） if (index &gt; _size) return; if (index &lt; 0) index = 0; Node* toAdd = new Node(val); Node* cur = _dummyHead; while (index--) cur = cur -&gt; next; toAdd -&gt; next = cur -&gt; next; cur -&gt; next = toAdd; _size++; } void deleteAtIndex(int index) { // 根据index定位到节点，通过将前一个节点的next指针修改为要删除节点的下一个节点的地址来完成删除 if (index &gt;= _size || index &lt; 0 ) return; Node* cur = _dummyHead; while (index--) cur = cur -&gt; next; Node* todel = cur -&gt; next; cur -&gt; next = todel -&gt; next; delete todel; // 释放节点空间 _size--; }private: int _size; Node* _dummyHead;}; 206.反转链表 代码随想录链接 题目 LeetCode-206 将一个给定的单链表的节点顺序依次翻转过来。 自己的思考 首先想到的是生成一个新的链表，依次分别将原链表中的数据不断在新链表的头部进行添加。但考虑到这样会造成额外的空间开销，就考虑使用链表的现有节点进行逆转。 解法 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { if (head == NULL) return NULL; // 处理空表的特殊情况 if (head -&gt; next == NULL) return head; // 处理只有一个节点的特殊情况 ListNode* dummyHead = new ListNode(0); // 使用假表首 ListNode* cur = head; // 使用一个当前节点的指针 while (cur != NULL) { // 循环条件 ListNode* tmp = cur; // 使用一个临时指针来标记当前节点A cur = cur -&gt; next; // 将当前节点向后移动，标记原链表中A的下一个节点 tmp -&gt; next = dummyHead -&gt; next; // 将A的next指针指向假表首的下一个节点 dummyHead -&gt; next = tmp; // 使A成为新的表首 } return dummyHead -&gt; next; // 真表首是假表首的next指针所指向的节点 }}; 遍历了链表，时间复杂度为\\(O(n)\\)；由于没有产生新的链表，空间复杂度为\\(O(1)\\)。","link":"/algorithm-train-day3/"},{"title":"代码随想录算法训练营第30天 | 332.重新安排行程, 51.N皇后, 37.解数独, 回溯法总结","text":"332.重新安排行程 代码随想录链接 题目 LeetCode-332.重新安排行程 给定几张机票, 从\"JFK\"出发, 将这些行程进行先后顺序的安排, 返回字母顺序最小的行程安排. 自己的想法 自己刚开始还想着用used布尔型数组, 来进行一个简单的排列组合, 最后在所有可以的行程内进行一个排序求出字母顺序最小的路程, 写出来之后过了给定的测试. 但是遇到比较大的输入样例就超时了, 不知道是环路了还是怎么样(理论上来讲给所有机票都加了used应该不会环路吧) 看了卡哥的思路才发现好像不用写那么麻烦hhh. 题解 自己的写法: (过了部分测试样例) 12345678910111213141516171819202122232425262728293031323334353637383940414243bool cmp(const vector&lt;string&gt; &amp;a, const vector&lt;string&gt; &amp;b) { for (int i = 0; i &lt; b.size(); i++) { if (a[i] == b[i]) continue; return a[i] &lt; b[i]; } return false;}class Solution {private: vector&lt;vector&lt;string&gt;&gt; possibleSolution; vector&lt;string&gt; path; int ticketUsed = 0; int totalTickets; void backtracing(vector&lt;vector&lt;string&gt;&gt; &amp;tickets, vector&lt;bool&gt; &amp;used, string airport) { if (ticketUsed == tickets.size()) { possibleSolution.push_back(path); return; } for (int i = 0; i &lt; tickets.size(); i++) { if (tickets[i][0] == airport &amp;&amp; !used[i]) { used[i] = true; ticketUsed++; path.push_back(tickets[i][1]); backtracing(tickets, used, tickets[i][1]); used[i] = false; ticketUsed--; path.pop_back(); } } }public: vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) { this -&gt; totalTickets = tickets.size(); vector&lt;bool&gt; used(tickets.size(), false); path.push_back(&quot;JFK&quot;); backtracing(tickets, used, &quot;JFK&quot;); sort(possibleSolution.begin(), possibleSolution.end(), cmp); return possibleSolution[0]; }}; AC了的代码: 1234567891011121314151617181920212223242526272829303132class Solution {private: unordered_map&lt;string, map&lt;string, int&gt;&gt; targets; // 使用这个结构来存储两个机场之间还剩几张机票, 后面使用map可以使得key按从小到大顺序存储, 不用再额外处理多个结果去字典排序最小的情况 bool backtracing(int ticketNum, vector&lt;string&gt; &amp;result) { if (result.size() == ticketNum + 1) { // result个数等于机场票数+1时证明用完了所有机票, 保存结果 return true; } for (pair&lt;const string, int&gt; &amp;target : targets[result.back()]) { // 取当前机场出发的机票, 按目的地进行遍历 if (target.second &gt; 0) { // 如果到一个目的地还有票没用完 result.push_back(target.first); // 回溯法开始, 在路径中推入目的地 target.second--; // 没用过的票数-1 if (backtracing(ticketNum, result)) return true; // 如果纵向递归找到了答案, 就立刻返回 result.pop_back(); // 否则回溯 target.second++; } } return false; // 没找到答案, 结束本层循环 }public: vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) { vector&lt;string&gt; result; for (const vector&lt;string&gt; &amp;vec : tickets) { // 根据给定的机票处理来统计机场与机场之间的票数 targets[vec[0]][vec[1]]++; } result.push_back(&quot;JFK&quot;); // 按题目要求, 从&quot;JFK&quot;出发 backtracing(tickets.size(), result); return result; }}; 51. N皇后 代码随想录链接 题目 LeetCode-51. N皇后 在一个\\(n * n\\)的棋盘里, 放入\\(n\\)个皇后, 要求同行同列以及同一斜线上不能存在其他皇后, 返回所有可能的摆放方式. 自己的想法 求所有可能的情况, 就很像是需要使用回溯法来解决的问题. 横向的for循环可以来确定一行上一个皇后应该摆放在哪里, 纵向的递归探索下一行, 且只当当前行摆放位置符合要求时, 才进行纵向递归. 题解 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {private: vector&lt;vector&lt;string&gt;&gt; result; // 保存所有可能的结果 void backtracing(int n, int row, vector&lt;string&gt; &amp;board) { if (row == n) { // 纵向递归超过了最后一行, 证明前面行都被填写了, 保存结果并结束本次递归 result.push_back(board); return; } for (int i = 0; i &lt; n; i++) { // for循环横向确定本行的皇后要放在哪里 if (isPositionAvailable(row, i, n, board)) { // 若遍历到的位置合适, 则进行纵向回溯递归 board[row][i] = 'Q'; backtracing(n, row + 1, board); board[row][i] = '.'; } } } bool isPositionAvailable(int x, int y, int n, vector&lt;string&gt; &amp;board) { // 判断给定的位置是否符合摆放一个皇后的要求 int curx = x, cury = y; while (--curx &gt; -1 &amp;&amp; --cury &gt; -1) { // 找左上方的斜线 if (board[curx][cury] == 'Q') return false; } curx = x; cury = y; while (--curx &gt; -1 &amp;&amp; ++cury &lt; n) { // 找右上方的斜线 if (board[curx][cury] == 'Q') return false; } curx = -1; cury = y; while (++curx &lt; x) { // 找同一列 if (board[curx][cury] == 'Q') return false; } return true; /** * 为啥不找左下和右下呢, 因为纵向递归还没走到那里, 还没填到那些位置 */ }public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { vector&lt;string&gt; board(n, string(n, '.')); backtracing(n, 0, board); return result; }}; 37. 解数独 代码随想录链接 题目 LeetCode-37. 解数独 找到一种填充方式, 来解决数独问题. 自己的想法 求填充方法, 还是回溯法. 横向的for循环来确定一个空位上应该填什么, 纵向的递归来找下一个空位填数字, 同样是在填的合适的时候, 才填并进行递归的, 所以还需要一个函数来判断某个位置填一个数是否可行. 题解 1234567891011121314151617181920212223242526272829303132333435363738class Solution { bool backtracing(vector&lt;vector&lt;char&gt;&gt; &amp;board) { for (int i = 0; i &lt; board.size(); i++) { for (int j = 0; j &lt; board[0].size(); j++) { if (board[i][j] == '.') { // 找一个空位置 for (char c = '1'; c &lt;= '9'; c++) { // 对这个空位置分别试图填进去不同的数字 if (isPlaceAvailable(i, j, c, board)) { // 如果一个数字填到这里合适的话, 就填入并进行递归 board[i][j] = c; if (backtracing(board)) return true; // 找到了一种解法的话就返回true, 停止搜索 board[i][j] = '.'; } } return false; // 当前位置没找到合适的数, 返回false } } } return true; // 所有位置都填完了, 返回true } bool isPlaceAvailable(int row, int col, char c, vector&lt;vector&lt;char&gt;&gt; &amp;board) { // 判断在一个位置上填一个数是否合适 for (int i = 0; i &lt; board[0].size(); i++) // 横向找是否有相同的 if (board[row][i] == c) return false; for (int i = 0; i &lt; board.size(); i++) // 纵向找是否有相同的 if (board[i][col] == c) return false; int startCol = (col / 3) * 3; // 计算给定的位置的3x3方块的左上方起始点 int startRow = (row / 3) * 3; for (int i = startRow; i &lt; startRow + 3; i++) // 判断在3x3方格内是否有相同的数 for (int j = startCol; j &lt; startCol + 3; j++) if (board[i][j] == c) return false; return true; }public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { backtracing(board); }}; 回溯法总结 代码随想录链接 回溯法解决的问题主要有: 求组合 LeetCode-77.组合 LeetCode-17.电话号码的字母组合 LeetCode-39.组合总和 LeetCode-40.组合总和II LeetCode-216.组合总和III 求排列 LeetCode-46.全排列 LeetCode-47.全排列 II LeetCode-491.递增子序列 LeetCode-332.重新安排行程 求子集 LeetCode-78.子集 LeetCode-90.子集II 填充问题 LeetCode-37. 解数独 LeetCode-51. N皇后","link":"/algorithm-train-day30/"},{"title":"代码随想录算法训练营第32天 | 122.买卖股票的最佳时机II, 55. 跳跃游戏, 45.跳跃游戏II","text":"122.买卖股票的最佳时机II 代码随想录链接 题目 LeetCode-122.买卖股票的最佳时机II 给定一个整数数组, 代表一支股票连续几日的价格, 每天可以进行一次买入和一次卖出操作, 求买卖这只股票能获得的最大利润. 自己的想法 从贪心算法的角度出发, 只有将每次买入和卖出时的差值最大化, 才能使得最后的利润最大化. 假如第0天买入, 第3天卖出, 那么本次的收益为prices[3] - prices[0]. 而如果将这个时间段进行分解, 就相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0]), 也就是相邻两天的差值. 这样我们就可以把这个问题分割为相邻两天之差的问题. 如果要想让利润最大化, 就需要把所有正值的差值收入囊中. 题解 1234567891011class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int sum = 0; for (int i = 1; i &lt; prices.size(); i++) { int diff = prices[i] - prices[i - 1]; // 计算相邻两天的差值 if (diff &gt; 0) sum += diff; // 求正差值之和 } return sum; }}; 55. 跳跃游戏 代码随想录链接 题目 LeetCode-55. 跳跃游戏 给定一个数组, 代表在每个索引位置能够一次前进的步数, 判断能否抵达数组终点. 自己的想法 每一步都有自己的索引和从当前位置可以迈出多少步的数字, 所以在不考虑怎么走的前提下, 就可以在覆盖范围内, 不断计算最大的覆盖范围, 如果范围囊括了最后一个位置, 就满足了条件. 题解 123456789101112class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) return true; int cover = 0; // 记录覆盖范围 for (int i = 0; i &lt;= cover; i++) { // 不断更新最大的覆盖范围 cover = max(cover, i + nums[i]); if (cover &gt;= nums.size() - 1) return true; } return false; }}; 45.跳跃游戏II 代码随想录链接 题目 LeetCode-45.跳跃游戏II 和上面的题目给定的数据相同, 但求至少需要几步可以到达终点. 自己的想法 题解 12345678910111213141516class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) return 0; int cover = 0, step = 0, currentIndex = 0; for (int i = 0; i &lt; nums.size(); i++) { cover = max(cover, i + nums[i]); // 计算能覆盖的最大范围 if (i == currentIndex) { // 如果当前遍历到了上次前进的位置, 就根据当前判定的最大范围前进 if (i == nums.size() - 1) break; // 如果已经是最后一位了, 就结束 step++; currentIndex = cover; } } return step; }};","link":"/algorithm-train-day32/"},{"title":"代码随想录算法训练营第31天 | 贪心理论基础, 455.分发饼干, 376.摆动序列, 53.最大子序和","text":"贪心理论基础 代码随想录链接 贪心的本质:由不断地取局部最优, 最终达到全局最优. 什么时候用贪心呢? 不好意思, 贪心不像回溯那样有固定的套路. 贪心的关键点在于通过不断地求解局部最优而达到整体最优的效果, 所以如果不能举出来局部最优影响最终的整体最优的反例, 则可以试试贪心算法. 贪心算法的一般的解题步骤: * 将问题分解为若干子问题 * 找出合适的贪心策略 * 求解每个问题的最优解 * 将局部最优解堆叠为全局最优解 455.分发饼干 代码随想录链接 题目 LeetCode-455.分发饼干 给定两个数组, 第一个数组表示孩子们的胃口, 第二个数组表示饼干们能满足的胃口的大小, 在每个孩子只能分得一块饼干的前提下, 求最多能满足几个孩子的胃口. 自己的想法 如果要满足最多的孩子, 应该从胃口最小的孩子开始, 依次取满足其胃口且最小的饼干, 这样能保证胃口小的孩子使用胃口小的饼干满足, 胃口大的孩子能够用较大的饼干满足. 题解 有两种写法, 首先是自己A出来的: 12345678910111213141516171819class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { vector&lt;bool&gt; used(s.size(), false); // 表示饼干有没有被分配掉 int satisfied = 0; // 满足的孩子的个数 sort(g.begin(), g.end()); // 孩子的胃口大小以及饼干的大小都由小到大排序 sort(s.begin(), s.end()); for (int i = 0; i &lt; g.size(); i++) {// 遍历每个孩子, 找适合他们的且最小的未被分配的饼干 int sizeNeeded = g[i]; for (int j = 0; j &lt; s.size(); j++) if (s[j] &gt;= sizeNeeded &amp;&amp; !used[j]) { used[j] = true; satisfied++; break; } } return satisfied; }}; 由于孩子们胃口大小和饼干大小都进行了排序, 所以当一个位置的饼干满足了一个胃口较小的孩子之后, 下一个进行满足的孩子应得到的饼干应该在上一个孩子得到的饼干的右侧, 所以可以将两层for循环简化为一层.双指针法 123456789101112131415161718class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { int satisfied = 0; sort(g.begin(), g.end()); // 胃口大小和饼干大小都由小到大排序 sort(s.begin(), s.end()); int cookieIndex = 0; for (int i = 0; i &lt; g.size(); i++) { int sizeNeeded = g[i]; while (cookieIndex &lt; s.size() &amp;&amp; sizeNeeded &gt; s[cookieIndex]) cookieIndex++; // 移动饼干的指针到满足孩子胃口的第一个 if (cookieIndex &lt; s.size() &amp;&amp; sizeNeeded &lt;= s[cookieIndex]) { // 如果数据合法, 且饼干满足当前孩子的胃口, 则给予这个孩子, 饼干指针右移一位 satisfied++; cookieIndex++; } } return satisfied; }}; 376.摆动序列 代码随想录链接 题目 LeetCode-376.摆动序列 给定一个数组, 求连续的两个数的差值是正负数交替的子序列最长的长度. 子序列在原数组中不要求一定连续. 自己的想法 先计算出来整个数组的两个数的差值, 作为一个数组, 然后再在这个数组里来找正负值交替的子序列, 最后看找出的正负值交替的子序列的最长长度. 题解 自己A出来的: 123456789101112131415161718192021222324252627282930313233343536class Solution {public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; diffs; if (nums.size() == 1) return true; int firstPositiveIndex = INT_MAX, firstNegativeIndex = INT_MAX; // 标记在差值数组中最左侧的正值和负值的位置 for (int i = 1; i &lt; nums.size(); i++) { // 计算差值数组 int diff = nums[i] - nums[i - 1]; if (diff &gt; 0) { firstPositiveIndex = min(i - 1, firstPositiveIndex); } if (diff &lt; 0) { firstNegativeIndex = min(i - 1, firstNegativeIndex); } diffs.push_back(diff); } vector&lt;int&gt; pathPos; // 找开头是正值的子序列 int needPositive = true; for (int i = firstPositiveIndex; i &lt; diffs.size(); i++) { if ((needPositive &amp;&amp; diffs[i] &gt; 0) || (!needPositive &amp;&amp; diffs[i] &lt; 0)) { // 满足正负值交替时, 才推入序列 pathPos.push_back(diffs[i]); needPositive = !needPositive; } } vector&lt;int&gt; pathNeg; // 找开头是负值的子序列 needPositive = false; for (int i = firstNegativeIndex; i &lt; diffs.size(); i++) { if ((needPositive &amp;&amp; diffs[i] &gt; 0) || (!needPositive &amp;&amp; diffs[i] &lt; 0)) { // 满足正负值交替时, 才推入序列 pathNeg.push_back(diffs[i]); needPositive = !needPositive; } } return pathNeg.size() &gt; pathPos.size() ? pathNeg.size() + 1 : pathPos.size() + 1; // 返回较长的序列的长度, 因为上面计算的是差值序列, 对应到原数组的子序列的话, 长度要 + 1 }}; 感觉上面这段代码如果非要从贪心的方面来说的话, 就是为了尽可能延长子序列的长度, 就尽可能地在左侧找子序列的下一个数字. 卡哥的方法只需要遍历一遍就行, 通过对比前一个差值和当前差值是否异号. 就能判断出来最长的长度. 1234567891011121314151617181920212223class Solution {public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt;= 1) return nums.size(); int curDiff = 0; // 当前差值 int preDiff = 0; // 上一个差值 int result = 1; // 最终结果, 起始值为1的原因和上面的写法中return那句后面+1一样 for (int i = 0; i &lt; nums.size() - 1; i++) { curDiff = nums[i + 1] - nums[i]; // 计算当前差值 if ((preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)) { // 当前差值和上一个差值异号, 符合条件 result++; // 长度+1 preDiff = curDiff; // 更改差值标记 } /** * 为什么preDiff要在上面的括号内进行更改, 而不是每一次都更改preDiff呢? * 因为我们最终的目的是求差值异号的子序列, 不异号的时候没有更改的必要, 相当于子序列中没有出现过跳过的这些数字. */ // } return result; }}; 贪心应该也是贪在试图在最左侧找符合条件的数字罢. 53.最大子序和 代码随想录链接 题目 LeetCode-53.最大子序和 给定一个整数数组, 找到其中和最大的连续子数组, 返回其和的值. 自己的想法 暴力法, 两个for循环 再说贪心, 局部最大, 并记录最大的连续和, 就能得到结果. 当当前的连续和下降到负数的时候, 重置连续和为0, 也就是变相更改了区间的左侧. 设另一个数result来保存结果, 并在当前连续和大于其时, 更新为当前连续和, 也是变相地更改了区间右侧. 题解 123456789101112class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int sum = 0, result = INT_MIN; for (int i = 0; i &lt; nums.size(); i++) { sum += nums[i]; // 计算当前区间的连续和 result = max(sum, result); // 若发现了更大的连续和, 则更新结果 if (sum &lt; 0) sum = 0; // 若连续和小于0, 加上下一个数之后, 和只会比下一个数单独的序列更小, 所以应被舍弃 } return result; }};","link":"/algorithm-train-day31/"},{"title":"代码随想录算法训练营第35天 | 860.柠檬水找零, 406.根据身高重建队列, 452.用最少数量的箭引爆气球","text":"860.柠檬水找零 代码随想录链接 题目 LeetCode-860.柠檬水找零 一杯柠檬水售价5元, 顾客们会给5元, 10元, 20元的钱, 按照先后顺序组成一个数组, 没有额外零钱, 求能否完成找零任务. 自己的想法 统计一下5元和10元的钱的数量, 遇到5元就只统计, 遇到10元需要统计并试图使用一张5元来找零, 找零不成功则返回false, 遇到20元时不用统计, 先试图用1张10元和1张5元来找零, 不成功的话再使用3张5元找零, 仍然不成功的话则找零失败. 题解 1234567891011121314151617181920212223242526class Solution {public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) { int count5 = 0, count10 = 0; for (int b : bills) { // 遍历账单 if (b == 5) count5++; // 统计5元数量 if (b == 10) { // 统计10元数量 count10++; if (count5) count5--; else return false; } if (b == 20) { // 遇到20元时 if (count10) { // 先试图用1张10元和1张5元找零 if (count5) { count10--; count5--; continue; // 找零成功, 则继续下一个账单 } } if (count5 &gt;= 3) count5 -=3; // 试图用三张5元找零 else return false; } } return true; }}; 406.根据身高重建队列 代码随想录链接 题目 LeetCode-406.根据身高重建队列 针对一群人的身高的队列给定一个乱序数组, 数组中每个元素包含两个元素, 其中第一位元素表示其身高, 第二位元素表示队伍前面有多少身高大于等于自己的人, 返回表示实际队伍的数组. 自己的想法 两个维度, 和昨天做的根据评分来给糖果的题目有点像, 同样应该是先集中考虑一个维度再考虑另一个维度. 先根据前面有几个人不比自己低来排序的话, 排不出来什么, 所以应该先根据身高排序. 先根据身高排序, 由于第二个维度是前面不比自己低的人有几个, 所以身高就按照从大到小排, 排序完成之后, 再遍历排完序的数组, 根据第二个维度的值插入到相应位置即可. 题解 123456789101112131415161718class Solution {static bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) { // 身高排序, 同身高的第二个维度小的在前 if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &gt; b[0];}public: vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) { sort(people.begin(), people.end(), cmp); // 对身高排序 list&lt;vector&lt;int&gt;&gt; result; // 使用list降低插入时的时间复杂度 for (int i = 0; i &lt; people.size(); i++) { // 遍历排序后的数组, 按照第二个维度插入元素 int pos = people[i][1]; auto it = result.begin(); while (pos--) it++; result.insert(it, people[i]); } return vector&lt;vector&lt;int&gt;&gt;(result.begin(), result.end()); }}; 452.用最少数量的箭引爆气球 代码随想录链接 题目 LeetCode-452.用最少数量的箭引爆气球 给定一组气球的在x轴上的投影范围, 计算至少垂直于X轴发射几支箭才能使得所有气球爆炸. 自己的想法 要计算至少需要多少支箭才能引爆所有气球, 就需要让一支箭尽可能多地引爆多个气球. 对于气球给定的范围, 我们可以将这些气球从左往右进行一个排序, 将有重叠的气球的右边界修整到一致, 使得这些气球能被一支箭引爆. 题解 1234567891011121314151617181920class Solution {static bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) { return a[0] &lt; b[0];}public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) { if (points.size() == 0) return 0; int result = 1; // 若气球数量不为0, 则至少需要一支箭 sort(points.begin(), points.end(), cmp); // 将气球按照左侧索引进行排序 for (int i = 1; i &lt; points.size(); i++) { if (points[i][0] &gt; points[i - 1][1]) result++; // 如果相邻两个气球没有重复的, 则需要的箭数要+1 else points[i][1] = min(points[i - 1][1], points[i][1]); // 如果有重复的部分, 则将第二个气球的右边界收缩到第一个气球的右边界, 方便对于后序气球的判断 /** * 那要是有三个气球有重叠部分呢? * 这样在第三个气球与第二个气球对比时, 第三个气球的右边界也会修正, 代表这些气球已经被对齐的目的气球的同一支箭来引爆 */ } return result; }};","link":"/algorithm-train-day35/"},{"title":"代码随想录算法训练营第37天 | 738.单调递增的数字, 968.监控二叉树","text":"738.单调递增的数字 代码随想录链接 题目 LeetCode-738.单调递增的数字 定义左位数字小于等于右位数字的整数为单调递增整数, 给定一个整数, 返回小于等于该整数的最大的单调递增整数. 自己的想法 如果要求最大的小于给定数字的单调递增数, 应该从后向前遍历, 遇到前一位数字大于后一位数字时, 前一位数字要-1且后位数字要变为9, 这样能保证这两位数字满足单调递增且是小于原数字的最大单调递增数, 这样就做到了局部最优. 由局部最优推广到全局最优, 就从后向前遍历并不断进行此类操作. 题解 12345678910111213141516class Solution {public: int monotoneIncreasingDigits(int n) { string numStr = to_string(n); int pos = numStr.size(); for (int i = numStr.size() - 1; i &gt; 0; i--) { // 从后向前遍历, 遇见前位数字大于后位数字的情况就将前位数字减一 if (numStr[i - 1] &gt; numStr[i]) { pos = i; numStr[i - 1]--; } } for (int i = pos; i &lt; numStr.size(); i++) // 将最后一次遇到前位数字大于后位数字情况的位置之后的所有数字改为9 numStr[i] = '9'; return stoi(numStr); }}; 968.监控二叉树 代码随想录链接 题目 LeetCode-968.监控二叉树 给定一棵二叉树, 一个节点安装了监控后可以监测到其自身, 父节点以及子节点, 求至少使用多少个监控能够将整个二叉树覆盖. 自己的想法 还是要遍历. 一个节点可能有三种情况, 无覆盖, 装了摄像头, 被其他节点的摄像头覆盖到. 如果要让使用的摄像头最少, 叶子节点一定不能装摄像头(因为这样一个摄像头能覆盖到的节点最少), 为了确保这点, 应该由底向上进行遍历, 所以应该是后序遍历. 题解 1234567891011121314151617181920class Solution {private: int result; // 结果 int traversal(TreeNode* cur) { // 递归函数, 0 代表无覆盖, 1 代表装有摄像头, 2代表被覆盖 if (cur == NULL) return 2; // 如果当前是空节点, 应该返回被覆盖, 避免对其他节点的覆盖造成影响 int left = traversal(cur -&gt; left); // 查找左子节点的状态 int right = traversal(cur -&gt; right); // 查询右子节点的状态 if (left == 2 &amp;&amp; right == 2) return 0; // 如果两个孩子都是被覆盖而没有摄像头, 说明当前位置没有覆盖, 返回0 else if (left == 0 || right == 0) { // 如果至少有一个孩子没有覆盖, 当前位置就需要安装一个摄像头, 并告知父节点 result++; return 1; } else return 2; // 上面两种情况都不符合, 就说明该节点也已经被覆盖 }public: int minCameraCover(TreeNode* root) { if (traversal(root) == 0) result++; return result; }};","link":"/algorithm-train-day37/"},{"title":"代码随想录算法训练营第25天 | 216.组合总和III, 17.电话号码的字母组合","text":"216.组合总和III 代码随想录链接 题目 LeetCode-216.组合总和III 使用\\([1, 9]\\)范围内的k个正整数, 找出这k个正整数之和等于n的所有组合. 自己的想法 和昨天的题一样, 回溯套模板呗. 题解 123456789101112131415161718192021222324252627class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; // 记录符合条件的集合 vector&lt;int&gt; current; // 记录回溯过程中的集合 int sum = 0; // 记录集合之和 void backtracing(int k, int n, int start) { if (current.size() == k) { // 集合含有k个元素时, 判断之和是否满足条件 if (sum == n) { result.push_back(current); } return; // 无论满不满足条件, 都进行回溯 } for (int i = start + 1; i &lt;= n - sum &amp;&amp; i &lt; 10; i++) { // 横向遍历, 确定集合中下一个位置上填什么 current.push_back(i); // 推入集合下一个位置上的数 sum += i; // 修改集合之和 backtracing(k, n, i); // 迭代来填充下下个位置 current.pop_back(); // 回溯, 弹出下个位置的数字 sum -= i; // 对应修改集合之和 } }public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { backtracing(k, n, 0); return result; }}; 17.电话号码的字母组合 代码随想录链接 题目 LeetCode-17.电话号码的字母组合 给定一个包含2-9的字符串, 返回其中能代表的所有字母组合, 2-9与字母的映射关系与功能机按键相同.暴露年龄 自己的想法 与上一题相似, 多加一些判断即可. 题解 1234567891011121314151617181920212223242526272829303132333435class Solution {private: vector&lt;string&gt; result; // 符合条件的结果的集合 string path = &quot;&quot;; // 记录当前字符串 const string letterMap[10] = { // 记录键盘数字与字符的映射 &quot;&quot;, // 0 &quot;&quot;, // 1 &quot;abc&quot;, // 2 &quot;def&quot;, // 3 &quot;ghi&quot;, // 4 &quot;jkl&quot;, // 5 &quot;mno&quot;, // 6 &quot;pqrs&quot;, // 7 &quot;tuv&quot;, // 8 &quot;wxyz&quot;, // 9 }; void backtracing(string digits, int letterIndex) { if (path.size() == digits.size() &amp;&amp; digits.size()) { // 当前字符串与数字字符串等长且不为0时, 推入结果 result.push_back(path); return; } if (letterIndex &gt;= digits.size()) return; // 防止下方遍历越界 int currentDigits = digits[letterIndex] - '0'; // 取当前函数的数组, 并字符char转化为int for (int i = 0; i &lt; letterMap[currentDigits].size(); i++) { // 横向遍历当前函数的数字可以代表的字符 path += letterMap[currentDigits][i]; // 推入字符 backtracing(digits, letterIndex + 1); // 填充下一位置 path.pop_back(); // 弹出字符, 进行下次循环 } }public: vector&lt;string&gt; letterCombinations(string digits) { backtracing(digits, 0); return this -&gt; result; }};","link":"/algorithm-train-day25/"},{"title":"代码随想录算法训练营第39天 | 62.不同路径, 63.不同路径 II","text":"62.不同路径 代码随想录链接 题目 LeetCode-62.不同路径 在一个网格中, 机器人每次只能向下或向右移动一步, 求到达网格右下方有多少种走法. 自己的想法 对于一个网格来说, 到达这个位置的走法是到达上方位置的走法和左侧位置走法之和, 故有递推公式\\[dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\] 对于网格第一排和第一列的网格来说, 走法只有一种, 故\\(dp[i][0]\\)和\\(dp[0][j]\\)应该初始化为1. 题解 1234567891011121314class Solution {public: int uniquePaths(int m, int n) { vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) // 初始化第一列 dp[i][0] = 1; for (int j = 0; j &lt; n; j++) // 初始化第一行 dp[0][j] = 1; for (int i = 1; i &lt; m; i++) // 递推填充dp for (int j = 1; j &lt; n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; }}; 63.不同路径 II 代码随想录链接 题目 LeetCode-63.不同路径 II 与上面那题相似, 不过中间加了不可抵达的区域. 自己的想法 同样地处理方式就可以了, 不过就是在遇到障碍物时, 不计算障碍物的dp, 让其一直保持为0. 题解 12345678910111213141516171819class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); if (obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1]) // 起始位置为障碍物的话指定不行 return 0; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m &amp;&amp; !obstacleGrid[i][0]; i++) // 初始化第一列到有石头的位置 dp[i][0] = 1; for (int j = 0; j &lt; n &amp;&amp; !obstacleGrid[0][j]; j++) // 初始化第一列到有石头的位置 dp[0][j] = 1; for (int i = 1; i &lt; m; i++) // 递推计算dp for (int j = 1; j &lt; n; j++) if (obstacleGrid[i][j]) continue; // 有石头的地方保持为0 else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; }};","link":"/algorithm-train-day39/"},{"title":"代码随想录算法训练营第38天 | 动态规划理论基础, 509.斐波那契数, 70.爬楼梯, 746.使用最小花费爬楼梯","text":"动态规划理论基础 代码随想录链接 动态规划, 如果一个问题有很多重叠的子问题时, 最好的方法是使用动态规划. 动态规划的每个状态一定是由上一个状态推导出来, 区分与贪心算法, 贪心算法没有状态推导. 动态规划的解题步骤: 确定dp数组和下标的含义 确定递推公式 dp数组的初始化 确定遍历数据 举例推导dp数组 509.斐波那契数 代码随想录链接 题目 LeetCode-509.斐波那契数 斐波那契数, 公式甚至直接给出来了. 自己的想法 根据给出的公式, 直接算就行. 解法 1234567891011class Solution {public: int fib(int n) { if (n &lt; 2) return n; vector&lt;int&gt; nums(n + 1, 0); nums[1] = 1; for (int i = 2; i &lt; nums.size(); i++) // 递推所有数据, 直到F[n] nums[i] = nums[i - 1] + nums[i - 2]; return nums[n]; }}; 时间复杂度为\\(O(n)\\), 空间复杂度为\\(O(1)\\). 70.爬楼梯 代码随想录链接 题目 LeetCode-70.爬楼梯 有n阶台阶才能到达楼顶, 每次能上1或者2个台阶, 返回有多少种方法可以爬到楼顶. 自己的想法 每次都爬1或者2个台阶, 就是一个递推公式, 爬到第n个台阶的方法数是爬到第n-1层台阶和n-2层台阶的方法数之和. 故有\\[F(n)=F(n-1)+F(n-2)\\] 解法 12345678910111213141516class Solution {public: int climbStairs(int n) { vector&lt;int&gt; nums(n); int dp[2]; if (n == 1) return 1; dp[0] = 1; // 初始化dp值 dp[1] = 2; for (int i = 2; i &lt; n; i++) { // 根据递推公式计算值 int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; }}; 时间复杂度为\\(O(n)\\), 空间复杂度为\\(O(1)\\). 746.使用最小花费爬楼梯 代码随想录链接 题目 LeetCode-746.使用最小花费爬楼梯 给定爬每个台阶的费用, 每支付一次费用可以往上爬一个或者两个台阶, 求爬到楼顶的最少花费. 自己的想法 递推公式也给出来了, 爬到第n个台阶的花费是\\[F(n) = min((F(n-1) + cost[n-1]), (F(n-2)+cost[n-2]))\\] 解法 12345678910class Solution {public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; dp(cost.size() + 1, 0); dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt;= cost.size(); i++) dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); return dp.back(); }}; 时间复杂度为\\(O(n)\\), 空间复杂度为\\(O(n)\\). 还有另外一种写法: (此时的dp是指从开始到爬完当前位置的台阶需要多少花费)好奇怪的想法 12345678910class Solution {public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; dp(cost.size(), 0); dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i &lt; cost.size(); i++) dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]; return min(dp[cost.size() - 1], dp[cost.size() - 2]); }};","link":"/algorithm-train-day38/"},{"title":"代码随想录算法训练营第36天 | 435.无重叠区间, 763.划分字母区间, 56.合并区间","text":"435.无重叠区间 代码随想录链接 题目 LeetCode-435.无重叠区间 给定区间的集合, 返回使得剩余区间不重叠而需要移除的最少区间数量 自己的思路 和昨天气球那题有点像, 气球的题目事实上求的是有几个能聚合在一起的重叠区间, 所以其实将返回值修改为区间总数减去聚合在一起的重叠区间的个数即可. 或者也可以先把区间按起始位置从小到大排列, 然后记录重叠的区间的个数. 题解 气球那题改的解法: 12345678910111213141516171819class Solution {static bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) { return a[0] &lt; b[0];}public: int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { if (intervals.size() &lt; 2) return 0; sort(intervals.begin(), intervals.end(), cmp); // 按起始位置排序 int count = 1; // 记录聚合的个数 for (int i = 1; i &lt; intervals.size(); i++) { if (intervals[i][0] &lt; intervals[i - 1][1]) { // 如果有重合, 就把重合的部分聚在一起(右区间聚拢) intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); } else { // 否则就新增聚合区间的个数 count++; } } return intervals.size() - count; // 区间的个数减去聚合区间的个数即为需要去除的区间数 }}; 记录重叠区间的个数: 123456789101112131415161718192021class Solution {static bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) { return a[0] &lt; b[0];}public: int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { if (intervals.size() &lt; 2) return 0; sort(intervals.begin(), intervals.end(), cmp); int count = 0; int end = intervals[0][1]; // 取第一个区间的右侧为分割点 for (int i = 1; i &lt; intervals.size(); i++) { if (intervals[i][0] &lt; end) { // 如果有重叠, 更新分割点 end = min(end, intervals[i][1]); count++; } else { // 没重叠就将分割点置为当前点的右侧 end = intervals[i][1]; } } return count; }}; 763.划分字母区间 代码随想录链接 题目 LeetCode-763.划分字母区间 给定一个字符串, 将这个字符串划分为尽可能多的片段, 同一个字母最多出现在一个片段当中, 划分的结果按顺序连接起来依然是原字符串, 返回划分的片段的长度. 自己的思路 自己的想法是先将每个字母出现的起始和结束位置记录下来, 转化为合并重叠区间的问题. 也写出来了一个代码, 但是好像和题目的思想可能表述的不是很明白, 如果把只出现了一次的字母单独分段, 在一些情况下是对的, 一些情况下是错的, 所以还是把自己写的贴出来吧. 题解 自己写的(没有AC): 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {static bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) { return a[0] &lt; b[0];}public: vector&lt;int&gt; partitionLabels(string s) { vector&lt;int&gt; result; vector&lt;vector&lt;int&gt;&gt; intervals(26, vector&lt;int&gt;(2, -1)); for (int i = 0; i &lt; s.size(); i++) { // 统计26个字母起始区间 int pos = s[i] - 'a'; if (intervals[pos][0] == -1) intervals[pos][0] = i; intervals[pos][1] = i; } for (int i = 0; i &lt; intervals.size(); i++) { // 删除没有出现的字母的数据 if (intervals[i][0] == -1) intervals.erase(intervals.begin() + i--); } sort(intervals.begin(), intervals.end(), cmp); for (int i = 0; i &lt; intervals.size(); i++) { // 合并只出现了一次的字母到其他项 if (intervals[i][0] == intervals[i][1]) { if (i == intervals.size() - 1) intervals[i - 1][1] = intervals[i][0]; else intervals[i + 1][0] = intervals[i][1]; intervals.erase(intervals.begin() + i--); } } sort(intervals.begin(), intervals.end(), cmp); int start = 0, end = intervals[0][1]; for (int i = 1; i &lt; intervals.size(); i++) { // 合并区间 if (intervals[i][0] &lt; intervals[i - 1][1]) end = max(intervals[i][1], end); // 有重叠时, 就把区间右侧进行扩展 else { // 没重叠时就记录分段数据 result.push_back(end - start + 1); start = intervals[i][0]; end = intervals[i][1]; } } result.push_back(end - start + 1); return result; }}; 卡哥的方法, 先统计每个字符出现的最后区间, 再重新遍历, 如果遇到了之前遍历过的所有字母的最远边界, 说明当前位置就是分割点. 123456789101112131415161718192021class Solution {static bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) { return a[0] &lt; b[0];}public: vector&lt;int&gt; partitionLabels(string s) { int lastPos[26] = {0}; for (int i = 0; i &lt; s.size(); i++) // 记录所有字母的最后出现位置 lastPos[s[i] - 'a'] = i; vector&lt;int&gt; result; int left = 0, right = 0; for (int i = 0; i &lt; s.size(); i++) { right = max(right, lastPos[s[i] - 'a']); if (i == right) { // 如果当前位置就是前面所有字母的最远边界, 就进行分割 result.push_back(right - left + 1); left = i + 1; } } return result; }}; 56.合并区间 代码随想录链接 题目 LeetCode-56.合并区间 对给定的区间中出现的重叠的区间进行合并, 区间是左闭右闭区间. 自己的思路 卡哥说这道题在今天的题中比较难, 我倒觉得还算简单的, 一次就A出来了. 同样还是先左边界排序, 右边界再判断是否重合及合并. 题解 123456789101112131415161718192021222324class Solution {static bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) { if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &lt; b[0];}public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { sort(intervals.begin(), intervals.end(), cmp); vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; range; // 标记当前在合并的区间的左右边界 range.push_back(intervals[0][0]); range.push_back(intervals[0][1]); for (int i = 1; i &lt; intervals.size(); i++) { if (intervals[i][0] &lt;= range[1]) range[1] = max(range[1], intervals[i][1]); // 如果当前遍历的区间与在合并的区间有重合部分, 就更新在合并的区间的右边界 else { // 不重合的话就记录前面的区间, 开始下一个区间的合并 result.push_back(range); range[0] = intervals[i][0]; range[1] = intervals[i][1]; } } result.push_back(range); return result; }};","link":"/algorithm-train-day36/"},{"title":"代码随想录算法训练营第34天 | 1005.K次取反后最大化的数组和, 134. 加油站, 135. 分发糖果","text":"1005.K次取反后最大化的数组和 代码随想录链接 题目 LeetCode-1005.K次取反后最大化的数组和 给定一个整数数组和一个数字K, 要求选取K次, 每次都将该数置为其负数, 返回K次选择后的最大值. 自己的想法 将所有值按照绝对值的大小从大到小进行排列, 从左至右遍历, 先将绝对值大的负数置为正数, 多余的选择次数全部用在最后一个数(即绝对值最小的数)上. 题解 12345678910111213141516171819class Solution {static bool absCmp(int a, int b) { // 自定义sort的排序 return abs(a) &gt; abs(b);}public: int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) { sort(nums.begin(), nums.end(), absCmp); // 将所有数字按照绝对值的大小从大到小进行排序 for (int i = 0; i &lt; nums.size(); i++) { // 遍历并将负值置为正数 if (nums[i] &lt; 0 &amp;&amp; k &gt; 0) { nums[i] *= -1; k--; } } while (k--) nums[nums.size() - 1] *= -1; // 将多余的次数用在绝对值最小的数上 int sum = 0; for (int i = 0; i &lt; nums.size(); i++) sum += nums[i]; // 求和 return sum; }}; 134.加油站 代码随想录链接 题目 LeetCode-134.加油站 给定一个gas和cost数组, 分别表示加油站的油量和开往下一个加油站所需要的油量, 所有加油站可以看成一个回路, 求从何处出发可以绕环路一周, 若不能绕行一周, 则返回-1. 自己的想法 如果gas数组之和小于cost数组之和, 则无论如何也无法行驶一周. 如果gas数组之和大于等于cost数组之和, 则可以找到一个起始位置完成一周的行驶. 在这种情况下, 可以假设从0位置出发, 求rest[i] = gas[i] - cost[i]之和, 如果在一个位置上, 该和小于0, 则证明从0处出发无法到达此位置, 需要将起始位置置为下一个加油站, 并重新计算rest[i]之和. 遍历完成后即能得到可行的起始位置. 题解 解法一:(就是上面描述的方法) 123456789101112131415161718192021222324class Solution {public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) { int curSum = 0; int total = 0; int pos = 0; for (int i = 0; i &lt; gas.size(); i++) { int rest = gas[i] - cost[i]; curSum += rest; // 计算从上一个设想位置出发的rest之和, 判断该位置出发是否可行 total += rest; // 计算全路程的油量, 判断是否有可能完成一周绕行 if (curSum &lt; 0) { // 如果上个出发位置不可行, 就更换为下一个出发位置 pos = i + 1; curSum = 0; /** * 为什么不将当前位置设为下一个出发位置呢? * 在进行当前位置的计算时, curSum是大于等于0的, 计算完当前位置之后, curSum小于0, 证明当前位置一定有rest[i] &lt; 0, 一定不适合出发, 所以需要置到下一个位置为起始位置. */ } } if (total &lt; 0) return -1; // 环路剩余油量不满足环路消耗量, 无法绕行 return pos; }}; 解法二: 12345678910111213141516171819202122class Solution {public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) { int curSum = 0; int minSum = INT_MAX; for (int i = 0; i &lt; gas.size(); i++) { // 计算环路油量剩余是否大于0, 以及找到从0出发时最小剩余油量 int rest = gas[i] - cost[i]; curSum += rest; minSum = min(curSum, minSum); } if (curSum &lt; 0) return -1; // 环路油量不足, 无法绕行 if (minSum &gt;= 0) return 0; // 从0处出发没有遇到油不足的情况, 可行 for (int i = gas.size() - 1; i &gt;= 0; i--) { // 从后往前计算剩余油量之和, 找出第一个之和能将minSum置为非负数的位置, 从该位置出发可行 int rest = gas[i] - cost[i]; minSum += rest; if (minSum &gt;= 0) { return i; } } return -1; }}; 135.分发糖果 代码随想录链接 题目 LeetCode-135.分发糖果 给N个孩子分糖果, 给定N个孩子的评分, 相邻两个孩子中分数较高的孩子需要获得更多的糖果, 每个孩子都需要获得至少一个糖果, 求所需的最少糖果. 自己的想法 评分较高需要从左右两侧来看, 两边一起考虑一定会有些问题. 可以先从前往后考虑每个孩子与左侧对比, 再从后往前, 将每个孩子的平分与右侧孩子对比. 题解 12345678910111213141516171819class Solution {public: int candy(vector&lt;int&gt;&amp; ratings) { vector&lt;int&gt; candyNum(ratings.size(), 1); // 每个孩子至少一个糖果 for (int i = 1; i &lt; candyNum.size(); i++) // 每个孩子与左侧孩子对比 if (ratings[i] &gt; ratings[i - 1]) candyNum[i] = candyNum[i - 1] + 1; for (int i = candyNum.size() - 2; i &gt;= 0; i--) // 每个孩子与右侧孩子对比 if (ratings[i] &gt; ratings[i + 1]) candyNum[i] = max(candyNum[i], candyNum[i + 1] + 1); int sum = 0; for (int i = 0; i &lt; candyNum.size(); i++) // 求和 sum += candyNum[i]; return sum; }};","link":"/algorithm-train-day34/"},{"title":"代码随想录算法训练营第42天 | 0-1背包理论基础, 416.分割等和子集","text":"0-1背包理论基础 代码随想录链接-二维dp数组 代码随想录链接-一维dp数组 0-1背包问题指的是类如: 有\\(n\\)件物品和一个最多能装下重量为\\(w\\)的背包, 第\\(i\\)件物品的重量是\\(weight[i]\\), 价值为\\(value[i]\\). 每一件物品只能用一次, 求解将哪些物品装入背包里, 物品总价值最大. 使用动态规划解决0-1背包问题时，主要有两种dp数组的形式： 二维dp数组 动态规划五部曲： * 确定dp数组及下标的含义 有一种写法, \\(dp[i][j]\\)表示从下标\\([0-i]\\)中的物品里任意取， 放进容量为\\(j\\)的背包, 价值总和最大值是多少. 确定递推公式 \\(dp[i][j]\\)的确定取决于下面两种情况: 物品\\(i\\)不放入, 此时\\(dp[i][j] == dp[i-1][j]\\), 背包的重量和价值与物品\\(i\\)无关. 物品\\(i\\)放入, 此时的\\(dp[i][j] == dp[i - 1][j - weight[i]] + value[i]\\), 即背包容量为不含有当前物品时的最大价值加上本物品的价值 所以递推公式有: \\[dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])\\] dp数组的初始化 如果\\(j\\)为0时, 背包价值一定为0, 所以\\(dp[i][0]\\)要初始化为0, 如果\\(i\\)为0时, 在\\(j\\)大于\\(value[0]\\)时, 一定有\\(dp[0][j] == 0\\). 其余数字都是由这些推导出来, 初始化为0就好. 遍历顺序 先遍历物品, 再遍历背包罢(代码随想录里有先遍历背包容量的, 二刷再记) 1234567 // weight数组的大小 就是物品个数for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); }} 举例推导 懒了 一维dp数组 对于一维dp数组来说, 同样有上面五步: 确定dp数组定义 \\(dp[j]\\)表示容量为j的背包, 所背物品价值的最大值 dp数组的递推公式 同样也是放物品\\(i\\)与不放物品\\(i\\), 有\\[dp[j] = max(dp[j], dp[j - weight[i]] + value[i])\\] dp数组的初始化 \\(dp[0]\\)一定初始化为0, 因为此时背包容量为0. 对于其他位置的值, 根据递推公式可知如果给定物品的价值都是正整数, 初始化为0即可. 遍历顺序 先遍历物品, 再遍历背包容量 12345for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} 注意这时候遍历背包容量的顺序与二维的不同, 要从大到小来遍历, 目的是为了保证物品\\(i\\)只被放入一次. 举例推导 又懒了 416.分割等和子集 代码随想录链接 题目 LeetCode-416.分割等和子集 给定一个只包含正整数的飞空数组, 判断是否可以将其分割为两个等和子集. 自己的想法 那其实就是判断能否用里面的价值与重量相等的物品, 装到容量为sum / 2的背包里, 且装满时总和为sum / 2. 使用一维dp数组, 可以得到递推公式为\\[dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\\] 题解 123456789101112131415161718class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = 0; vector&lt;int&gt; dp(nums.size() * 100 + 1, 0); // 根据给定的信息来初始化数组 for (int i = 0; i &lt; nums.size(); i++) // 求原数组之和 sum += nums[i]; if (sum % 2) // 若和为奇数, 必不能满足条件 return false; int target = sum / 2; for (int i = 0; i &lt; nums.size(); i++) // 先遍历物品, 再遍历重量 for (int j = target; j &gt;= nums[i]; j--) dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); if (dp[target] == target) // 如果最后容量为sum / 2的位置上, 最多能装sum / 2价值的物品, 则满足条件 return true; return false; }};","link":"/algorithm-train-day42/"},{"title":"代码随想录算法训练营第41天 | 343.整数拆分, 96.不同的二叉搜索树","text":"343.整数拆分 代码随想录链接 题目 LeetCode-343.整数拆分 给定一个正整数, 返回将该正整数分拆之后各个数之积的最大值. 自己的想法 还是递推, 递推公式可以为\\(dp[i]=max((i - j) * j, dp[i - j] * j)\\), 其中dp代表的意思是i分拆之后各数之积的最大值. 题解 1234567891011class Solution {public: int integerBreak(int n) { vector&lt;int&gt; dp(n + 1); dp[2] = 1; for (int i = 3; i &lt;= n; i++) // 从i等于3开始计算 for (int j = 1; j &lt;= i / 2; j++) // 计算到i/2, 省略另一半重复的计算 dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)); return dp[n]; }}; 96.不同的二叉搜索树 代码随想录链接 题目 LeetCode-96.不同的二叉搜索树 给定一个整数n, 求由n个值为1到n的节点组成的互不相同的二叉搜索树有几种. 自己的想法 二叉搜索树的每一个子树也都是二叉搜索树，利用这一点可以得到递推公式\\(dp[i]+=dp[i-j]*dp[j-1]\\),其中\\(dp[i]\\)表示以\\(i\\)为头节点的树的数量. 题解 1234567891011class Solution {public: int numTrees(int n) { vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for (int i = 1; i &lt;= n; i++) // 根据递推公式计算 for (int j = 1; j &lt;= i; j++) // 计算所有左右子树可能的组合数 dp[i] += dp[j - 1] * dp[i - j]; return dp[n]; }};","link":"/algorithm-train-day41/"},{"title":"代码随想录算法训练营第4天 | 24. 两两交换链表中的节点， 19.删除链表的倒数第N个节点，面试题 02.07. 链表相交，142.环形链表II，链表总结","text":"24.两两交换链表中的节点 代码随想录链接 题目 LeetCode-24 给定一个链表，将奇数位与相邻右侧偶数位的节点进行翻转。 自己的想法 使用假表头，遍历时使用一个cur指针指向在需要交换的一对节点的前面一个节点，然后对这一对节点的位置进行交换。 解法 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0, head); // 一个假表头，并使用构造函数将next指向head节点 ListNode* cur = dummyHead; // cur指针用于遍历链表 while(cur != NULL &amp;&amp; cur -&gt; next != NULL) { // 如果cur指针为空，或者cur节点后没有节点的话，就跳出循环 if (cur -&gt; next -&gt; next == NULL) break; // 如果cur指针指向的节点没有一对节点的话，结束 ListNode* first = cur -&gt; next; // 取cur指向的节点后的第一个节点，即奇数位节点 ListNode* second = first -&gt; next; // 取要交换的偶数位节点 ListNode* third = second -&gt; next; // 取偶数位节点后的节点 cur -&gt; next = second; // 将偶数位节点向前置，置于奇数位节点之前 second -&gt; next = first; // 将奇数位节点置于偶数位节点之后 first -&gt; next = third; // 将原来偶数位节点之后的节点置于奇数位节点之后 cur = first; // 移动cur指针 } return dummyHead -&gt; next; // 返回真表头 }}; 对链表进行遍历，时间复杂度为\\(O(n)\\)；使用了常数个额外变量，空间复杂度为\\(O(1)\\)。 19.删除链表中的倒数第N个节点 代码随想录链接 题目 LeetCode-19 给定一个单链表，删除倒数第n个节点。 自己的想法 双指针么，根据给定的n，使快指针先走对应的\\((n - 1)\\)步, 然后快慢指针再一起移动，当慢指针移动到末尾节点时，慢指针指向的就是要删除的节点。 为什么是\\((n - 1)\\)步呢，因为这里的想法是使得fast指向最后一个节点时停止，而不是fast为NULL时停止，在这种条件下，fast和slow指针之间的步数差距应该是\\((n - 1)\\)步，举个例子，如果要删除倒数第2个节点，当fast指向末尾节点时，slow指向的是fast前的一个节点，此时fast和slow之间的步数差距不是2，而是1。 为了能在单链表中正确删除给定位置的节点，还可以让fast在寻找末尾的时候少走一步，这样fast和slow指针一起移动结束之时，slow指针指向的是要被删除的节点之前的节点，便于进行链表操作。 解法 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0, head); // 利用构造函数声明一个假表头并让其next指针指向head节点 ListNode* slow = dummyHead, *fast = dummyHead; // 快慢指针 n--; // 计算步数差 while (n-- &amp;&amp; fast != NULL) fast = fast -&gt; next; // 让fast指针先走 while (fast -&gt; next != NULL &amp;&amp; fast -&gt; next -&gt; next != NULL) { // 当fast指针在倒数第二个节点的时候就停下来，这样slow就在要删除的节点的上一个节点停下来了 fast = fast -&gt; next; // slow和fast指针同时前进 slow = slow -&gt; next; } ListNode* toDel = slow -&gt; next; // 根据上面的思路，此时slow节点的next指针指向的就是要删除的节点，在此标注 slow -&gt; next = toDel -&gt; next; // 将slow节点的next指针指向要删除的节点的下一个节点，将要删除的节点剥离链表 delete toDel; // 释放删除的节点的内存空间 return dummyHead -&gt; next; // 返回真表头 }}; 上面的这个代码实现和代码随想录里的C++代码实现有些许的不同，主要区别是在如何处理fast指针的位置，使得slow指针能够停留在要删除的节点的上一个节点处。代码随想录里的做法循环的跳出条件是，fast为空时，slow指针要指向被删除节点的上一个节点，所以fast指针不仅要比slow指针多走n步，甚至还要再多1步；而上面的实现中，fast指针最终停在了末尾节点的上一个节点。作用是一样的。 上面的实现中，时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)。 链表相交 代码随想录链接 题目 LeetCode-面试题02.07 给定两个链表，要求找到两个链表重合部分的起始节点。王道考研资料数据结构书上的题。 自己的想法 先通过遍历两个链表，获得两个链表分别的长度，再让长链表的遍历指针先走等于长度差的步数，接着让长短链表的遍历指针同时移动，当这两个指针指向同一个节点时，就找到了重合相交部分的起始节点。 解法 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *dummyA = headA, *dummyB = headB; // 假表头 ListNode *curA = dummyA, *curB = dummyB; // 用来计算长度的遍历指针 int lengthA = 0, lengthB = 0; // 长度的变量 while (curA != NULL &amp;&amp; curA -&gt; next != NULL) { // 查A的长度 curA = curA -&gt; next; lengthA++; } while (curB != NULL &amp;&amp; curB -&gt; next != NULL) { // 查B的长度 curB = curB -&gt; next; lengthB++; } ListNode *curLongerList = lengthA &gt;= lengthB ? dummyA : dummyB; // 根据长度对比，分别确定长链表和锻炼表 ListNode *curShorterList = lengthA &lt; lengthB ? dummyA : dummyB; int steps = lengthA &gt;= lengthB ? (lengthA - lengthB) : (lengthB - lengthA); // 计算步数差 while (steps--) curLongerList = curLongerList -&gt; next; // 长链表先走 while (curLongerList &amp;&amp; curShorterList) { // 长短链表遍历指针同时移动 if (curLongerList == curShorterList) return curLongerList; // 当两条链表的遍历指针指向同一个节点时，返回该节点指针 curLongerList = curLongerList -&gt; next; // 否则，两个指针继续移动 curShorterList = curShorterList -&gt; next; } return NULL; // 如果一直没有指向同一个节点，证明两链表无相交部分 }}; 和代码随想录上的C++实现也还是有些许的差别，主要是在确定长短链表那里。 上面的实现遍历了两次链表，时间复杂度为\\(O(2 * n) = O(n)\\)，使用了常数个变量，空间复杂度为\\(O(1)\\)。 142.环形链表II 代码随想录链接 题目 LeetCode-142 给定一个链表，返回链表内环形结构开始的节点。若无环，则返回 NULL 。 这道题目不要太熟悉啊，也是王道考研资料的数据结构书上面的题，可能是链表部分练习题的最后一道大题来着。并不耽误我这次一开始自己没做出来。 自己的想法 双指针法，快指针一次走两步，慢指针一次走一步。当快慢指针相遇时，证明有环状结构存在。此时，快指针的步数是慢指针步数的两倍。 示意图，图源代码随想录 设链表入环前的长度为\\(x\\)，链表环的入口到快慢指针相遇的地方长度为\\(y\\)，相遇之处从沿快慢指针前进方向距环的入口的长度为\\(z\\)，可得以下公式： \\begin{equation} 2 * (x + y) = x + n * (x + y) + z \\end{equation} 其中，\\(n\\)为快指针进入环结构之后，完整走完了几次环结构。 根据上面的式子，可得： \\begin{equation} x = (n - 1) * (y + z) + z \\end{equation} \\((y + z)\\)等于一个环结构的长度，我们假设\\(n = 1\\)，即快指针完整走完了一次环结构后才与慢指针相遇，可得： \\begin{equation} x = z \\end{equation} 此时若新设立一个指针，从链表表头开始，与慢指针同时一步一步前进，则当慢指针走过\\(z\\)步，新指针走过\\(x\\)步时，慢指针和新指针将在环结构入口处相遇。 若\\(n &gt; 1\\)，同样在链表表头设立一个新指针，此时新指针与慢指针的距离为\\((x + y)\\)。由上面的式子可得： \\begin{equation} x + y = (n - 1) * (y + z) + z + y = n * (y + z) \\end{equation} 即此时新指针与慢指针的差距为环形结构的长度的\\(n\\)倍，在新指针与慢指针同时一步一步前进的条件下，两者最终还是会在环装结构入口处相遇。 解法 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *detectCycle(ListNode *head) { ListNode *fast = head, *slow = head; while (fast != NULL &amp;&amp; fast -&gt; next != NULL) { slow = slow -&gt; next; fast = fast -&gt; next -&gt; next; if (slow == fast) break; } if (fast == NULL || fast -&gt; next == NULL) return NULL; ListNode *prob = head; while (prob != slow) { prob = prob -&gt; next; slow = slow -&gt; next; } return prob; }}; 不知道怎么说这个时间复杂度为好。。。空间复杂度为\\(O(1)\\)。 链表总结 两天干完链表。感觉链表的内容确实不算那种非常难的知识。最起码给我这个计算机科班的人感觉像是在复习。或这就是为什么卡哥给算法训练营中数组和链表都只安排了两天吧。 链表基础 链表的种类分为： 单链表 双链表 循环链表 链表的存储方式：分散存储，依靠相邻节点之间的指针保持联系。 常见题目 虚拟头节点 虚拟头结点主要使用在单链表遍历过程中需要使用前一个节点才能进行操作时。不使用虚拟头结点也能做，就是要单独处理头结点的情况；而使用虚拟头结点，能够在后续的代码中简化实现。 例题： 代码随想录--LeetCode 203.移除链表元素 链表增删改查 既然是个数据结构嘛，免不了要进行增删（改）查，为什么把改单独括起来呢，因为改的前一步往往是要查。 这种题目考的是链表的一些基础操作，虽然看起来简单，但是非常重要，而且经常会在小地方出错而导致代码不能AC。 例题： 代码随想录--LeetCode 707.设计链表 反转链表 将链表的本末倒置。考察对于链表操作的熟练程度，方法主要有递归法和迭代法。 例题： 代码随想录--LeetCode 206.反转链表 删除倒数第N个节点 双指针法。理清快慢指针之间的关系即可。 例题： 代码随想录--LeetCode 19.删除链表的倒数第N个节点 链表相交 找清楚链表相同的部分，将不同的部分予以对齐。 例题： 代码随想录--LeetCode 面试题 02.07 链表相交 环形链表 这种题目主要是数学公式的推导，实现并非难点。 例题： 代码随想录--LeetCode 142.环形链表II","link":"/algorithm-train-day4/"},{"title":"代码随想录算法训练营第44天 | 完全背包理论基础, 518.零钱兑换 II, 377.组合总和 Ⅳ","text":"完全背包理论基础 代码随想录链接 完全背包和0-1背包的区别在于， 0-1背包问题中每个待取物品只有一个, 只存在被取与不取两个状态, (所以才是0-1背包). 而完全背包问题中, 每一件物品都有无数件, 除了被取与不取两个状态外还有很多种取了不同件的状态. 完全背包与0-1区别在于遍历顺序上, 完全背包的遍历方式主要为: 1234// 外层for循环遍历物品, 内层for循环逆向遍历背包容量for (int i = 0; i &lt; weight.size(); i++) for (int j = bagSize; j &gt;= weight[i]; j--) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 而完全背包的遍历方式: 1234// 外层for循环遍历物品, 内层for循环正向遍历背包容量for (int i = 0; i &lt; weight.size(); i++) for (int j = weight[i]; j &lt;= bagSize; j++) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 518.零钱兑换 II 代码随想录链接 题目 LeetCode-518.零钱兑换 II 给定不同面额的硬币和一个总金额, 使用任意数量的硬币来凑成总金额, 求可以凑成的组合数. 分析 这道题就是完全背包问题, 且是组合问题, 不是排序问题. 动态规划五部曲: 确定dp数组及下标的含义 dp[j]: 凑成j金额的组合数为dp[j] 确定递推公式 dp[j]就是所有dp[j - coins[i]]的总和 \\[dp[j] += dp[j -coins[i]]\\] dp数组的初始化 凑够金额为0的组合只有一种, 所以\\(dp[0] = 1\\). 遍历顺序 这里求的是组合数, 应该先遍历物品, 后遍历背包 123for (int i = 0; i &lt; coins.size(); i++) for (int j = coins[i]; j &lt;= amount; j++) dp[j] += dp[j - coins[i]]; 也给出求排列数的方法: 1234for (int j = 0; j &lt;= amount; j++) for (int i = 0; i &lt; coins.size(); i++) if (j - coins[i] &gt;= 0) dp[j] += dp[j - coins[i]]; 举例推导 题解 1234567891011class Solution {public: int change(int amount, vector&lt;int&gt;&amp; coins) { vector&lt;int&gt; dp(amount + 1, 0); dp[0] = 1; for (int i = 0; i &lt; coins.size(); i++) for (int j = coins[i]; j &lt;= amount; j++) dp[j] += dp[j - coins[i]]; return dp[amount]; }}; 377.组合总和 Ⅳ 代码随想录链接 题目 LeetCode-377. 组合总和 Ⅳ 给定一个不重复的正整数数组和一个数值, 找出和为给定数值的排列数. 分析 这道题就是完全背包的排列问题了. 动态规划五部曲: 确定dp数组及下标含义 dp[j]代表和为j时, 有多少种排列 确定递推公式 求装满背包的方法时, 递推公式一般是 \\[dp[j] += dp[j - nums[i]]\\] dp数组的初始化 dp[0] = 1, 不仅是因为凑够0只有一种方法, 更是为了在递归其他dp[j]时让数值有意义. 遍历顺序 本题要求排列数, 和上面提到的求排列的方法应当对应起来 12345// 外层for循环遍历背包容量, 内层for循环遍历物品, 且因为求排列数, 两者都要正向遍历for (int j = 0; j &lt;= target; j++) for (int i = 0; i &lt; nums.size(); i++) if (j - nums[i] &gt;= 0) dp[j] += dp[j - nums[i]]; 举例推导 题解 123456789101112class Solution {public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; dp(target + 1, 0); dp[0] = 1; for (int j = 0; j &lt;= target; j++) for (int i = 0; i &lt; nums.size(); i++) if (j - nums[i] &gt;= 0 &amp;&amp; dp[j] &lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; return dp[target]; }};","link":"/algorithm-train-day44/"},{"title":"代码随想录算法训练营第43天 | 1049.最后一块石头的重量 II, 494.目标和, 474.一和零","text":"1049.最后一块石头的重量 II 代码随想录链接 题目 LeetCode-1049.最后一块石头的重量II 给定表示一堆石头重量的正整数数组, 每次选出任意两块石头进行粉碎, 两块石头分别减去较小的石头的重量, 重复最后最多会剩下一块头, 求此时石头最小的可能重量. 题目分析 两两碰撞, 根据这一点可以将这个问题转化为将石头分成尽可能重量相同的两堆, 这种情况下两堆石头相撞之后剩下的石头重量最小. 问题也转化为了如何使用\\(sum / 2\\) 的背包装下更多的重量和价值在数值上相同的石头. 动态规划五部曲: 确定dp数组以及下标的含义 \\(dp[j]\\)表示容量为\\(j\\)的背包, 最多可以装的价值为\\(dp[j]\\). 确定递归公式 因为本题目中石头的重量和价值在数值上相同, 所以有\\[dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]\\]. dp数组如何初始化 dp数组的初始化要考虑两点, 一个是最大容量, 另一个是初始值 在本题目中, 最大容量是所有石头的重量和, 也就是\\(30 * 100 = 3000\\). 由于递推公式中包含了\\(+ stone[i]\\)这一部分, 所有初始值都可以初始化为0. 确定遍历顺序 一维dp数组, 先遍历物品后遍历背包容量时, 外层正向循环, 内层背包容量倒序遍历. 举例推导 举题目中的例子: 输入 [2, 4, 1, 1], target = 8 / 2 = 4 有dp数组: 遍历 0 1 2 3 4 用stone[0]遍历背包容量 0 0 2 2 2 用stone[1]遍历背包容量 0 0 2 2 4 用stone[2]遍历背包容量 0 1 2 3 4 用stone[3]遍历背包容量 0 1 2 3 4 确实是将石头分为[2, 1, 1] 和 [4] 之后, 最终的剩下的石头最小. 题解 1234567891011121314class Solution {public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { vector&lt;int&gt; dp(1501, 0); int sum = 0; for (int i = 0; i &lt; stones.size(); i++) // 统计石头总共多少重量 sum += stones[i]; int target = sum / 2; // 求要分得的目标重量 for (int i = 0; i &lt; stones.size(); i++) for (int j = target; j &gt;= stones[i]; j--) // 一维dp数组先物品后背包时, 背包容量逆向遍历 dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); return sum - dp[target] - dp[target]; // dp[target]是分得的两堆石头中的较小的那个, 大的减去小的, 即可得到碰撞后最后一块石头的重量 }}; 494.目标和 代码随想录链接 题目 LeetCode-494.目标和 给定一个非负整数数组和一个目标数, 向每个数前面添加'+'或'-'并串联起所有整数形成一个表达式, 求有多少个表达式之和为目标数. 题目分析 转化为0-1背包问题, 就可以将所有数字分为放+号的一个集合, 放-号的一个集合, 假设我们要求+号的集合, 设其为plus, 前面放-号的集合为minus, 有题目可知, plus + minus之和为sum, 而plus - minus的结果为目标数target, 消去minus, 可以得出plus = (sum + target) / 2. 此时问题就可以转化为装满plus容量的包, 有几种方法.(就是哪几个数来放+号) 动态规划五部曲: 确定dp数组及下标的含义 \\(dp[j]\\)表示填满\\(j\\)容积的包, 有\\(dp[j]\\)种方法. 确定递推公式 可以使用已经确定放入的物品, 以及不放这个物品的方法数来进行推测. \\[dp[j] += dp[j - nums[i]]\\] dp数组的初始化 填满容量为0的背包, 只有一种办法, 所以\\(dp[0]\\)应该初始化为1. 确定遍历顺序 一维dp数组下, 外层循环物品, 内层循环容量, 且容量倒序循环. 举例推导 nums:[1,1,1,1,1], target = 3 遍历 0 1 2 3 4 nums[0]遍历背包容量 1 1 0 0 0 nums[1]遍历背包容量 1 2 1 0 0 nums[2]遍历背包容量 1 3 3 1 0 nums[3]遍历背包容量 1 4 6 4 1 nums[4]遍历背包容量 1 5 10 10 5 题解 12345678910111213141516171819class Solution {public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) { int sum = 0; for (int i = 0; i &lt; nums.size(); i++) sum += nums[i]; if (abs(target) &gt; sum) return false; if ((target + sum) % 2) return false; int bagsize = (target + sum) / 2; vector&lt;int&gt; dp(bagsize + 1, 0); dp[0] = 1; for (int i = 0; i &lt; nums.size(); i++) for (int j = bagsize; j &gt;= nums[i]; j--) dp[j] += dp[j - nums[i]]; return dp[bagsize]; }}; 474.一和零 代码随想录链接 题目 LeetCode-474.一和零 给定一个二进制字符串数组和两个整数m和n, 找出数组的最大子集的大小, 且该子集最多含有m个0和n个1. 题目分析 转化为0-1背包问题, 可以是每个字符串都视为一个物品, 一个物品有两个维度, 分别是0的个数和1的个数. 动态规划五部曲: 确定dp数组及下标的含义 dp[i][j]: 最多有i个0和j个1的最大子集大小. 确定递推公式 可以由前一个字符串推导出来. \\[dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)\\] dp数组的初始化 初始化为0保证不会影响后续计算即可 遍历顺序 外层循环物品, 内层逆向循环容量 举例推导 懒了 题解 12345678910111213141516171819class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0)); for (string str : strs) { int oneNum = 0, zeroNum = 0; for (char c : str) { if (c == '0') zeroNum++; else oneNum++; } for (int i = m; i &gt;= zeroNum; i--) for (int j = n; j &gt;= oneNum; j--) dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); } return dp[m][n]; }};","link":"/algorithm-train-day43/"},{"title":"代码随想录算法训练营第45天 | 70.爬楼梯(进阶), 322.零钱兑换, 279.完全平方数","text":"70.爬楼梯(进阶) 代码随想录链接 题目 LeetCode-70.爬楼梯 爬n阶楼梯, 每次可以上一层或两层, 求有多少种不同的方式可以爬到顶. 题目分析 之前使用的是递推公式来解决这个问题, 这次使用背包问题的方式来解决这个问题. 动态规划五部曲: 确定dp数组及下标的含义 \\(dp[j]\\)代表爬到第j层楼梯, 有\\(dp[j]\\)种方法. 确定递推公式 求方法的数量, 公式为: \\[dp[j] += dp[j - i]\\] dp数组的初始化 递加的公式公式中, \\(dp[0]\\)应当被被初始化为1, 这样后序的递加才能累计. 确定遍历顺序 本题实际上求的是不限量的1和2的有序组合, 所以应该是先遍历背包, 再遍历物品 1234for (int j = 1; j &lt; n + 1; j++) for (int i = 1; i &lt; 3; i++) if (j - i &gt;= 0) dp[j] += dp[j - i]; 举例推导 题解 123456789101112class Solution {public: int climbStairs(int n) { vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for (int j = 1; j &lt; n + 1; j++) for (int i = 1; i &lt; 3; i++) if (j - i &gt;= 0) dp[j] += dp[j - i]; return dp[n]; }}; 322.零钱兑换 代码随想录链接 题目 LeetCode-322.零钱兑换 给定不同面额的硬币, 每种硬币数量无限, 求需要凑成给定金额最少要多少个硬币. 题目分析 本题目是求组合的完全背包问题. 动态规划五部曲: 确定dp数组及下标的含义 \\(dp[j]\\)代表凑够j金额至少需要\\(dp[j]\\)个硬币 确定递推公式 由于本题目求得是至少需要多少硬币, 所以递推公式应该为: \\[dp[j] = min(dp[j], dp[j - coins[i]] + 1\\] 为什么+1呢, 因为凑够\\(j - coins[i]\\)需要\\(dp[j - coins[i]]\\)个硬币, 再多一个\\(coins[i]\\)硬币才能凑够\\(j\\), 所以要+1. dp数组的初始化 因为要求最小值, 所以所有位置上的值都应该是\\(INT_MAX\\), 同时, 凑够0元一定是需要0个硬币, 所以 \\(dp[0] = 0\\) 确定遍历顺序 本题目求硬币最小个数, 对于顺序没有要求, 可以先遍历物品再遍历容量, 也可以反着来. 1234for (int i = 0; i &lt; coins.size(); i++) for (int j = coins[i]; j &lt;= amount; j++) if (dp[j - coins[i]] != INT_MAX) dp[j] = min(dp[j], dp[j - coins[i]] + 1); 举例推导 题解 123456789101112class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { vector&lt;int&gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &lt; coins.size(); i++) for (int j = coins[i]; j &lt;= amount; j++) if (dp[j - coins[i]] != INT_MAX) dp[j] = min(dp[j], dp[j - coins[i]] + 1); return dp[amount] == INT_MAX ? -1 : dp[amount]; }}; 279.完全平方数 代码随想录链接 题目 LeetCode-279.完全平方数 给定正整数n, 返回至少使用多少个完全平方数的和才能凑够这个正整数. 题目分析 实际上和上一道题目是一样的. 动态规划五部曲: 确定dp数组及下标含义 \\(dp[j]\\)代表凑够正整数\\(j\\)至少需要\\(dp[j]\\)个完全平方数. 确定递推公式 由于是求至少需要多少个, 所以递推公式应当为: \\[dp[j] = min(dp[j], dp[j - i * i] + 1)\\] dp数组的初始化 凑够0需要的完全平方数的个数一定为0, 所以dp[0] = 0. 又因为本题目要求最小数, 所以其他值应当初始化为INT_MAX. 确定遍历顺序 本题目也是两种顺序都可以, 这里给出先遍历物品后遍历背包的写法. 1234for (int i = 1; i * i &lt;= n; i++) for (int j = i * i; j &lt;= n; j++) if (dp[j - i * i] != INT_MAX) dp[j] = min(dp[j], dp[j - i * i] + 1); 举例推导 题解 123456789101112class Solution {public: int numSquares(int n) { vector&lt;int&gt; dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 1; i * i &lt;= n; i++) for (int j = i * i; j &lt;= n; j++) if (dp[j - i * i] != INT_MAX) dp[j] = min(dp[j], dp[j - i * i] + 1); return dp[n]; }};","link":"/algorithm-train-day45/"},{"title":"代码随想录算法训练营第49天 | 121.买卖股票的最佳时机, 122.买卖股票的最佳时机II","text":"121.买卖股票的最佳时机 代码随想录链接 题目 LeetCode-121.买卖股票的最佳时机 这道题老朋友了, 给定的数组价格是一支股票在一段日子每天的价格, 只能买入卖出一次, 求最大能获得的利润. 题目分析 动态规划是主要状态与状态之间的推算, 在这道题目中, 每一天可以看作有两种状态, 分别是持有股票和没有持有股票. 动态规划五四部曲: 确定dp数组及下标含义 dp[i][0]代表第i天不持有股票所获得的最多现金, dp[i][1]代表持有股票所获得的最多现金. 现金可以是负数. 确定递推公式 每一天都有两个状态, 同样的这两个状态也可以从前面一天的两个状态计算而来. 当前天的不持有, 也就是dp[i][0], 可以是前一天持有, 今天卖出, 也可以前一天一直不持有, 有: \\[dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])\\] 当前日子的持有, 也就是dp[i][1], 同样可以从前一天的状态推出来, 有: \\[dp[i][1] = max(dp[i - 1][1], -prices[i])\\] 为什么是第二个只是\\(-prices[i]\\)呢? 因为本题目中买入卖出只能有一次. dp数组的初始化 dp[0][0] 代表第一天不持有, 所以dp[0][0]必定为0; dp[0][1]代表第一天持有, dp[0][1]应初始化为\\(-prices[0]\\). 遍历顺序 每天的状态都是由前一天决定的, 所以遍历顺序一定是从前往后. 题解 1234567891011121314class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int dayNum = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(dayNum, vector&lt;int&gt;{0, 0}); dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i &lt; dayNum; i++) { dp[i][0] = max(dp[i - 1][0], prices[i] + dp[i - 1][1]); dp[i][1] = max(dp[i - 1][1], - prices[i]); } return max(dp.back()[0], dp.back()[1]); }}; 122.买卖股票的最佳时机II 代码随想录链接 题目 LeetCode-122.买卖股票的最佳时机II 在上面一题的基础上, 不限制买入卖出的次数, 甚至同一天先买入再卖出都可以. 题目分析 由于没有买入卖出的次数限制, 而其他逻辑都是一样的, 所以只需要将上面一题的分析中对于买入次数的限制取消掉即可, 即修改递推公式: \\[dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])\\] \\[dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])\\] 题解 1234567891011121314class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int dayNum = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(dayNum, vector&lt;int&gt;{0, 0}); dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i &lt; dayNum; i++) { dp[i][0] = max(dp[i - 1][0], prices[i] + dp[i - 1][1]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return max(dp.back()[0], dp.back()[1]); }};","link":"/algorithm-train-day49/"},{"title":"代码随想录算法训练营第48天 | 198.打家劫舍, 213.打家劫舍II, 337.打家劫舍III","text":"198.打家劫舍 代码随想录链接 题目 LeetCode-198.打家劫舍 思路分析 有一排屋子, 相邻两间房屋被闯入时会触发报警, 每个屋子都有一定数额的现金, 求能偷到的最高金额. 当前房屋偷和不偷取决与前一个房屋和前两个房屋是否被偷了, 就能形成一种递推关系. 动态规划五部曲: 确定dp数组及下标的含义 \\(dp[j]\\)代表\\([0, j]\\)内的房屋, 最多可以偷\\(dp[j]\\)的金额. 确定递推公式 到当前位置能偷多少可以从前两个位置的状态计算而来, 分别是偷前两个位置和当前位置, 或者是偷前一个位置, 故有: \\[dp[j] = max(dp[j - 2] + nums[i], dp[j - 1]\\] dp数组的初始化 dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) 遍历顺序 由公式: \\[dp[j] = max(dp[j - 2] + nums[i], dp[j - 1]\\] 可知遍历顺序一定是从前向后依次遍历. 举例推导 题解 12345678910111213class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) return nums[0]; vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &lt; nums.size(); i++) dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); return dp[nums.size() - 1]; }}; 213.打家劫舍II 代码随想录链接 题目 LeetCode-213.打家劫舍II 在第一题的基础上, 将房子首尾也连在一起, 即若首尾房子同时被入侵, 也会产生警报. 思路分析 可以将这个问题分解成两个子情况, 分别是不考虑首和不考虑尾, 并分别求出两个结果, 再取最大值. 题解 12345678910111213141516171819class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) return nums[0]; return max(robRange(nums, 0, nums.size() - 2), robRange(nums, 1, nums.size() - 1)); } int robRange(vector&lt;int&gt; &amp;nums, int start, int end) { // 第一题的逻辑 if (end == start) return nums[end]; vector&lt;int&gt; dp(end - start + 1); dp[0] = nums[start]; dp[1] = max(nums[start], nums[start + 1]); for (int i = start + 2; i &lt;= end; i++) dp[i - start] = max(dp[i - start - 2] + nums[i], dp[i - start - 1]); return dp[end - start]; }}; 337.打家劫舍III 代码随想录链接 题目 LeetCode-337.打家劫舍III 现在房屋以二叉树的形式进行排列, 直接相连的节点不能同时被入侵, 求最多能偷到的金额. 思路分析 上面两种情况都是后面的状态由前面决定, 而在二叉树中, 一个节点的状态应该由其子节点的状态决定, 所以应该用后序遍历来解决. 确定递归函数的参数和返回值 需要知道偷与不偷这节点能获得的金额, 所以每个节点的向上返回值都应该包含两个值. 确定终止条件 遇到空节点时, 直接返回{0, 0} 确定遍历顺序 如上面分析, 一定是后序遍历 单层递归的逻辑 先递归计算左右孩子偷与不偷分别能得到的金额, 再向上返回自己偷与不偷能获得的最大金额. 12345vector&lt;int&gt; left = robTree(cur -&gt; left);vector&lt;int&gt; right = robTree(cur -&gt; right);int valDoCur = cur -&gt; val + left[0] + right[0];int valNoCur = max(left[0], left[1]) + max(right[0], right[1]);return vector&lt;int&gt;{valNoCur, valDoCur}; 题解 1234567891011121314151617class Solution {public: int rob(TreeNode* root) { vector&lt;int&gt; res = robTree(root); return max(res[0], res[1]); } vector&lt;int&gt; robTree(TreeNode *cur) { if (!cur) return vector&lt;int&gt; {0, 0}; vector&lt;int&gt; left = robTree(cur -&gt; left); vector&lt;int&gt; right = robTree(cur -&gt; right); int valDoCur = cur -&gt; val + left[0] + right[0]; int valNoCur = max(left[0], left[1]) + max(right[0], right[1]); return vector&lt;int&gt;{valNoCur, valDoCur}; }};","link":"/algorithm-train-day48/"},{"title":"代码随想录算法训练营第53天 | 1143.最长公共子序列, 1035.不相交的线, 53.最大子序和(动态规划)","text":"1143.最长公共子序列 代码随想录链接 题目 LeetCode-1143.最长公共子序列 给定两个字符串, 返回两个字符串的最长公共子序列的长度. 题目分析 动态规划五部曲: 确定dp数组及下标的含义 dp[i][j]代表text1[0~i]和text2[0~j]部分最长公共子序列的长度. 确定递推公式 分为text1[i]和text2[j]相同和不相同的情况: 若相同, 则dp[i][j] = dp[i - 1][j - 1] + 1 若不同, 则dp[i][j]应该取text1[0~(i-1)]和text2[0~j]的最长公共子序列的长度及text1[0~i]和text2[0~(j-1)]的最大值, 即dp[i][j] = max(dp[i-1][j], dp[i][j-1]) dp数组的初始化 对于i或j为0的位置, 需要进行判断是否赋值为1. 遍历顺序 两层循环, 一层用来遍历text1, 一层用来遍历text2. 题解 1234567891011121314151617181920212223class Solution {public: int longestCommonSubsequence(string text1, string text2) { vector&lt;vector&lt;int&gt;&gt; dp(text1.size(), vector&lt;int&gt;(text2.size(), 0)); for (int i = 0; i &lt; text1.size(); i++) if (text1[i] == text2[0]) dp[i][0] = 1; for (int j = 0; j &lt; text2.size(); j++) if (text2[j] == text1[0]) dp[0][j] = 1; for (int i = 0; i &lt; text1.size(); i++) for (int j = 0; j &lt; text2.size(); j++) if (text1[i] == text2[j] &amp;&amp; i &amp;&amp; j) dp[i][j] = dp[i - 1][j - 1] + 1; else if (text1[i] != text2[j] &amp;&amp; i &amp;&amp; j) dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); else if (text1[i] != text2[j] &amp;&amp; i) dp[i][j] = dp[i - 1][j]; else if (text1[i] != text2[j] &amp;&amp; j) dp[i][j] = dp[i][j - 1]; return dp.back().back(); }}; 1035.不相交的线 代码随想录链接 题目 LeetCode-1035.不相交的线 给定两个数组, 在两个数组中相等的数之间一对一进行画线, 求最多能画多少条不相交的线. 题目分析 说是画线, 其实就还是找最长公共子序列的长度, 因为最长公共子序列中的每一位都可以能一一对应且画线不相交. 题目分析见上一题. 题解 12345678910111213class Solution {public: int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;vector&lt;int&gt;&gt; dp(nums1.size() + 1, vector&lt;int&gt;(nums2.size() + 1, 0)); for (int i = 1; i &lt;= nums1.size(); i++) for (int j = 1; j &lt;= nums2.size(); j++) if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); return dp.back().back(); }}; 53.最大子序和(动态规划) 代码随想录链接 题目 LeetCode-53.最大子序和 给定一个整数数组, 找到一个具有最大和的连续子数组并返回其和. 题目分析 动态规划五部曲: 确定dp数组及下标的含义 dp[i]表示nums[0~i]中最大连续子序列和. 确定递推公式 dp[i]的来源有两个: 一个是nums[i]加入前面的子数组, 另一个是重新开始计算子序列. 有: dp[i] = max(dp[i - 1] + nums[i], nums[i]) dp数组的初始化 dp[0]应初始化为nums[0], 因为题目中给定了子序列至少有一个数字, dp数组其他位置应初始化为INT_MIN 确定遍历顺序 题解 12345678910111213class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(nums.size(), 0); dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i &lt; nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); result = max(dp[i], result); } return result; }};","link":"/algorithm-train-day53/"},{"title":"代码随想录算法训练营第51天 | 309.最佳买卖股票时机含冷冻期, 714.买卖股票的最佳时机含手续费","text":"309.最佳买卖股票时机含冷冻期 代码随想录链接 题目 LeetCode-309.最佳买卖股票时机含冷冻期 给定股票每天的价格, 要求卖出股票之后的第二天为冷冻期不能再次买入, 买卖次数不限制, 求能获得的最大利润. 题目分析 动态规划的重点是不同时刻之间状态的转移. 动态规划五部曲: 确定dp数组及下标含义 本题目的每一天总共有4种状态, 分别是不持有, 买入持有, 买入并当天卖出, 冷冻期. 使用dp[i][0]代表不持有, dp[i][1]代表买入持有, dp[i][2]表示买入并在当天卖出, dp[i][3]为冷冻期. 确定递推公式 不持有的状态可以由冷静期或者不持有的状态得到, 有 \\[dp[i][0] = max(dp[i - 1][0], dp[i - 1][3])\\] 持有的状态可以由不持有状态和冷冻期状态买入股票得到, 或者保持持有状态得到, 有: \\[dp[i][1] = max(max(dp[i - 1][0] - prices[i], dp[i - 1][3] - prices[i]), dp[i - 1][1])\\] 当天卖出的状态由前一天持有状态转化而来: \\[dp[i][2] = dp[i - 1][1] + prices[i]\\] 冷冻期由前一天卖出的状态得到: \\[dp[i][3] = dp[i - 1][2]\\] dp数组的初始化 第一天的4种状态中只有买入持有的状态需要初始化为-prices[0], 其余均应该保持0; 遍历顺序 每一天的状态都由前一天的状态计算得来, 所以应当从前向后遍历 举例推导 题解 1234567891011121314class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(4, 0)); dp[0][1] = -prices[0]; for (int i = 1; i &lt; prices.size(); i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][3]); dp[i][1] = max(max(dp[i - 1][0] - prices[i], dp[i - 1][3] - prices[i]), dp[i - 1][1]); dp[i][2] = dp[i - 1][1] + prices[i]; dp[i][3] = dp[i - 1][2]; } return max(dp.back()[0], max(dp.back()[2], dp.back()[3])); }}; 714.买卖股票的最佳时机含手续费 代码随想录链接 题目 LeetCode-714.买卖股票的最佳时机含手续费 同样是股票问题, 可以无限次交易但每次卖出都需要收取手续费. 题目分析 基本就是LeetCode-122.买卖股票的最佳时机II在卖出时多收了个手续费, 不再重复分析. 题解 123456789101112class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) { vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2, 0)); dp[0][1] = -prices[0]; for (int i = 1; i &lt; prices.size(); i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp.back()[0]; }}; 股票问题总结 代码随想录链接 股票问题的关键点在于弄清楚每天都有几种状态, 以及状态与状态之间是怎么转换得到的.","link":"/algorithm-train-day51/"},{"title":"代码随想录算法训练营第46天 | 139.单词拆分, 多重背包, 背包问题总结","text":"139.单词拆分 代码随想录链接 题目 LeetCode-139.单词拆分 给定一个非空字符串和一个包含非空单词的数组, 判断非空字符串能否由数组中的单词组成. 一个单词可以使用多次, 没有重复的单词. 题目分析 转化为背包问题, 单词就是物品, 字符串就是背包, 因为同一个单词可以多次取, 所以是完全背包问题. 动态规划五部曲: 确定dp数组及下标的含义 \\(dp[j]\\), 字符串长度为j时, 能否由数组内单词组成. 确定递推公式 当区间字符串\\([i, j]\\)区间的子字符串出现在数组内的单词且\\(dp[i]\\)为true时, \\(dp[j]\\)也为true. dp数组的初始化 dp[0] = true, 仅用于推导公式 遍历顺序 用单词拼接字符串是需要注重顺序的, 所以需要先遍历背包, 再遍历物品 123456for (int j = 1; j &lt;= s.size(); j++) for (int i = 0; i &lt; j; i++) { string word = s.substr(i, j - i); if (wordSet.find(word) != wordSet.end() &amp;&amp; dp[i]) dp[j] = true; } 举例推导 题解 123456789101112131415class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); vector&lt;bool&gt; dp(s.size() + 1, false); dp[0] = true; for (int j = 1; j &lt;= s.size(); j++) for (int i = 0; i &lt; j; i++) { string word = s.substr(i, j - i); if (wordSet.find(word) != wordSet.end() &amp;&amp; dp[i]) dp[j] = true; } return dp[s.size()]; }}; 多重背包 多重背包就是在0-1背包的基础上, 同样的一件物品可能有不同的数量限制. 比如物品可能有: 重量 价值 数量 物品0 1 15 2 物品1 3 20 3 物品2 4 30 2 解决方法也很简单, 将相同的物品展开为一个一个\"不同\"的物品, 然后当做0-1背包问题处理即可. 背包问题总结 动态规划五部曲: 确定dp数组及下标的含义 确定递推公式 dp数组的初始化 确定遍历顺序 举例推导 dp数组 基本上题目求得是什么, dp数组的值就代表什么. 例如, 求最多能装多少, 那么dp数组的值就是不同容量时最多能装多少; 求有几种方法, dp数组的值就代表几种方法; 求最大价值, 那么dp数组就代表对应容量的最大价值. 递推公式 最多能装多少 问最多能装多少, 就把物品看做价值和重量相同的物品. 递推公式为: \\[dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]\\] 例题: 416.分割等和子集 1049.最后一块石头的重量 几种方法 求几种方法时, 一般是将背包容量小于当前位置的数值求和得到: \\[dp[j] += dp[j - nums[i]]\\] 例题: 494.目标和 518.零钱兑换II 377.组合总和IV 70.爬楼梯(进阶) 背包的最大价值 由前一个状态(没有装当前物品的背包状态), 和当前背包容量的状态得到. \\[dp[j] = max(dp[j], dp[j - weight[i]] + values[i])\\] 例题: 474.一和零 装满背包最少物品数 由上一个状态(没装当前物品)的个数和当前状态得到. \\[dp[j] = min(dp[j], dp[j - coins[i]] + 1)\\] 例题: 322.零钱兑换 279.完全平方数 遍历顺序 0-1背包 二维dp数组: 12345678// weight数组的大小 就是物品个数for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); }} 1234567// weight数组的大小 就是物品个数for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); }} 一维dp数组: 只能外层循环遍历物品, 内层(倒序)遍历背包容量 12345for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} 完全背包 纯完全背包(顺序可有可无): 注意两个循环都是索引从小到大遍历的 1234567// 先遍历物品，再遍历背包for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight ; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} 1234567// 先遍历背包，再遍历物品for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 if (j - weight[i] &gt;= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } cout &lt;&lt; endl;} 求组合数时: 外层for循环遍历物品, 内层for循环遍历背包. 例题: 518.零钱兑换II 求排列数: 外层for循环遍历背包, 内层for循环遍历物品. 例题: 377.组合总和IV 70.爬楼梯(进阶)","link":"/algorithm-train-day46/"},{"title":"代码随想录算法训练营第55天 | 392.判断子序列, 115.不同的子序列","text":"392.判断子序列 代码随想录链接 题目 LeetCode-392.判断子序列 给定字符串s和t, 判断t是否为s的子序列. 题目分析 动态规划五部曲: 确定dp数组及下标的含义 dp[i][j]表示以下标i-1为结尾的s, 和以下标j-1为结尾的t, 相同子序列长度为dp[i][j]. 确定递推公式 如果在t中一个字符在s中也出现了, 那么就要在dp[i-1][j-1]的基础上+1; 如果不匹配, 则继续沿用dp[i][j-1]的结果. dp数组的初始化 i==0和j==0的部分都要初始化为0. 遍历顺序 外层for循环遍历s的字符, 内层for循环遍历t的字符. 题解 123456789101112131415class Solution {public: bool isSubsequence(string s, string t) { vector&lt;vector&lt;int&gt;&gt; dp(s.size() + 1, vector&lt;int&gt;(t.size() + 1, 0)); for (int i = 1; i &lt;= s.size(); i++) for (int j = 1; j &lt;= t.size(); j++) if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = dp[i][j - 1]; if (dp.back().back() == s.size()) return true; return false; }}; 115.不同的子序列 代码随想录链接 题目 LeetCode-115.不同的子序列 给定一个字符串s和一个字符串t, 计算s的子序列中t出现的次数. 题目分析 动态规划五部曲: 确定dp数组及下标的含义 dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j] 确定递推公式 12345if (s[i - 1] == t[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];} else { dp[i][j] = dp[i - 1][j];} dp数组的初始化 12vector&lt;vector&lt;long long&gt;&gt; dp(s.size() + 1, vector&lt;long long&gt;(t.size() + 1));for (int i = 0; i &lt;= s.size(); i++) dp[i][0] = 1; 遍历顺序 外层for循环遍历s的字符, 内层for循环遍历t的字符 题解 1234567891011121314151617class Solution {public: int numDistinct(string s, string t) { vector&lt;vector&lt;uint64_t&gt;&gt; dp(s.size() + 1, vector&lt;uint64_t&gt;(t.size() + 1, 0)); for (int i = 0; i &lt; s.size(); i++) dp[i][0] = 1; for (int j = 1; j &lt; t.size(); j++) dp[0][j] = 0; for (int i = 1; i &lt;= s.size(); i++) for (int j = 1; j &lt;= t.size(); j++) if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; else dp[i][j] = dp[i - 1][j]; return dp.back().back(); }};","link":"/algorithm-train-day55/"},{"title":"代码随想录算法训练营第50天 | 123.买卖股票的最佳时机III, 188.买卖股票的最佳时机IV","text":"123.买卖股票的最佳时机III 代码随想录链接 题目 LeetCode-123.买卖股票的最佳时机III 由LeetCode-122.买卖股票的最佳时机II的不限制买入卖出次数变成了限制可以买卖两次, 求最大利润. 题目分析 动态规划依然是不同时刻状态与状态之间的推算. 动态规划五部曲: 确定dp数组及下标含义 本题中每一天有五种状态, 分别是一次没买, 第一次买了持有, 第一次买了已卖出, 第二次买了持有, 第二次买了已卖出. dp[i][0-4]分别表示第i天的以上五种状态. 确定递推公式 如果一次没买, 那么就不会有资金变动, 所以dp[i][0] = 0对所有i都适用. 第i天的第一次买入持有的状态可以从第i-1天的一次没买和买了持有的状态推出; 第i天的第一次买入并卖出的状态也可以由前一天的第一次买了持有的状态和第一次买了且卖出的状态推出; 剩下两个状态同理. \\[dp[i][0] = 0\\] \\[dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1])\\] \\[dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])\\] \\[dp[i][3] = max(dp[i - 1][2] - prices[i], dp[i - 1][3])\\] \\[dp[i][4] = max(dp[i - 1][3] + prices[i], dp[i - 1][4])\\] dp数组的初始化 由于是求最大值且数据都是正整数, 故所有位都可以初始化为0. 由于并没有限制买入和卖出操作不能在同一天完成, 所以第一天的五中状态可以初始化为: 12345dp[0][0] = 0;dp[0][1] = -prices[0];dp[0][2] = 0;dp[0][3] = -prices[0];dp[0][4] = 0; 遍历顺序 由于递推公式中每一天的状态都由前一天的状态决定, 故一定是从前先后遍历 题解 12345678910111213141516171819class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(5, 0)); dp[0][0] = 0; dp[0][1] = -prices[0]; dp[0][2] = 0; dp[0][3] = -prices[0]; dp[0][4] = 0; for (int i = 1; i &lt; prices.size(); i++) { dp[i][0] = 0; dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]); dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2]); dp[i][3] = max(dp[i - 1][2] - prices[i], dp[i - 1][3]); dp[i][4] = max(dp[i - 1][3] + prices[i], dp[i - 1][4]); } return max(dp.back()[2], dp.back()[4]); }}; 188.买卖股票的最佳时机IV 代码随想录链接 题目 LeetCode-188.买卖股票的最佳时机IV 由上面的题目扩展而来, 变成了最多买卖给定的k次. 题目分析 其实就是把上面的题目扩展了一下, 题目分析都是一样的, 同一天的dp数组的奇数位上都是买入并持有的状态, 偶数位上都卖出状态. 题解 12345678910111213141516171819class Solution {public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) { vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2 * k + 1, 0)); for (int i = 1; i &lt; 2 * k + 1; i+=2) // 初始化第一天的所有买入状态 dp[0][i] = -prices[0]; for (int i = 1; i &lt; prices.size(); i++) // 递推求每一天的状态 for (int j = 0; j &lt; k; j++) { dp[i][2 * j + 1] = max(dp[i - 1][2 * j] - prices[i], dp[i - 1][2 * j + 1]); dp[i][2 * j + 2] = max(dp[i - 1][2 * j + 1] + prices[i], dp[i - 1][2 * j + 2]); } int maxVal = 0; for (int i = 0; i &lt; dp.back().size(); i+=2) { // 求最后一天所有卖出状态的最大值 if (dp.back()[i] &gt; maxVal) maxVal = dp.back()[i]; } return maxVal; }};","link":"/algorithm-train-day50/"},{"title":"代码随想录算法训练营第52天 | 300.最长递增子序列, 674.最长连续递增序列, 718.最长重复子数组","text":"300.最长递增子序列 代码随想录链接 题目 LeetCode-300.最长递增子序列 在给定的整数数组中找出严格递增子序列的长度. 题目分析 拿回溯写了一下, 但是超时, 还得DP. 动态规划五部曲: dp数组及下标的含义 dp[i]代表在第i位及之前的数组中最长递增子序列的长度. 递推公式 位置i最长升序子序列等于与前面各位小于i处的值的位置的最长升序子序列的长度+1的最大值 12if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); dp数组初始化 每个位置的最长子序列的长度都大宇等于1, 故所有位置的值均应被初始化为1. 确定遍历顺序 dp[i]的结果都由[0, i - 1]的状态推到而来, 所以遍历顺序一定是由前向后遍历. 因为要取最大值, 所以还需要一个内层for循环来求最大值 题解 动态递归做法: 123456789101112131415161718class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) return 1; vector&lt;int&gt; dp(nums.size(), 1); int result = 0; for (int i = 1; i &lt; nums.size(); i++) { for (int j = 0; j &lt; i; j++) { if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); } if (dp[i] &gt; result) result = dp[i]; } return result; }}; 回溯做法:(超时⚠️) 1234567891011121314151617181920212223class Solution {private: int maxLen = 0; vector&lt;int&gt; seq; void backtracing(vector&lt;int&gt; &amp;nums, int startIndex) { if (seq.size () &gt; maxLen) maxLen = seq.size(); if (startIndex &gt;= nums.size()) { return; } for (int i = startIndex; i &lt; nums.size(); i++) if (!seq.size() || nums[i] &gt; seq.back()) { seq.push_back(nums[i]); backtracing(nums, i + 1); seq.pop_back(); } }public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { backtracing(nums, 0); return maxLen; }}; 674.最长连续递增序列 代码随想录链接 题目 LeetCode-674.最长连续递增序列 给定未经排序的数组, 返回最长的连续递增的子序列的长度. 题目分析 动态规划五部曲: 确定dp数组及下标的含义 dp[i]表示第[0, i]位最长的连续递增的子序列的长度. 递推公式 由于是求连续递增, 所以每个位置上只需要判断与前一个位置的关系即可根据前一位的状态计算出当前位的数据. 12if (nums[i] &gt; nums[i - 1]) dp[i] = dp[i - 1] + 1; dp数组的初始化 和上一题一样, 对于每一位来说, 最长连续递增子序列的长度都至少是1. 遍历顺序 同理可知应从前向后. 题解 1234567891011121314class Solution {public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(nums.size(), 1); int result = 1; for (int i = 1; i &lt; nums.size(); i++) { if (nums[i] &gt; nums[i - 1]) dp[i] = dp[i - 1] + 1; if (dp[i] &gt; result) result = dp[i]; } return result; }}; 718.最长重复子数组 代码随想录链接 题目 LeetCode-718.最长重复子数组 给定两个整数数组, 求两者最长公共子序列的长度. 题目分析 动态规划五部曲: dp数组及下标含义 dp[i][j]表示以i下标为结尾的A, 和以j下标为结尾的B, 最长公共子序列长度. 递推公式 当nums1[i] == nums2[j]时, dp[i][j] = dp[i - 1][j - 1] + 1; dp数组的初始化 因为递推公式是根据对上一位的结果得出的, 故应该将两个数组的第一位先填充好, 即dp[0][j]和dp[i][0]先根据nums1[i]和nums2[j]是否对应先填充好. 遍历顺序 两层for循环, 一层遍历A, 一层遍历B. 题解 12345678910111213141516171819202122class Solution {public: int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;vector&lt;int&gt;&gt; dp(nums1.size() + 1, vector&lt;int&gt;(nums2.size() + 1, 0)); int result = 0; for (int i = 0; i &lt; nums1.size(); i++) if (nums1[i] == nums2[0]) dp[i][0] = 1; for (int j = 0; j &lt; nums2.size(); j++) if (nums2[j] == nums1[0]) dp[0][j] = 1; for (int i = 0; i &lt; nums1.size(); i++) for (int j = 0; j &lt; nums2.size(); j++) { if (nums1[i] == nums2[j] &amp;&amp; i &amp;&amp; j) dp[i][j] = dp[i - 1][j - 1] + 1; if (dp[i][j] &gt; result) result = dp[i][j]; } return result; }};","link":"/algorithm-train-day52/"},{"title":"代码随想录算法训练营第57天 | 647.回文子串, 516.最长回文子序列, 动态规划总结篇","text":"647.回文子串 代码随想录链接 题目 LeetCode-647.回文子串 根据给定的字符串计算这个字符串里有多少回文子串. 题目分析 动态规划五部曲: 确定dp数组及下标的含义 如果规定dp[i]是以下标i为结尾的字符串有dp[i]个回文串的话, 会发现dp[i], dp[i-1], dp[i+1]之间没有什么关系, 这就不符合动态规划的条件了. 由回文串的性质可知, 如果s[i, j]区间的子串是回文串的话, 那么如果s[i-1]==s[j+1], 则s[i-1. j+1]也一定是回文串, 故可以有dp[i][j]表示s[i, j]之间的字符能够形成回文串与否. 确定递推公式 如果s[i] != s[j], 则dp[i][j]一定是false; 若s[i] == s[j], 若i == j, 即同一个字符, 是回文串, dp[i][j] = true; 若i != j, 但 j - i = 1, 即相邻字符相等, 则也是回文串, dp[i][j] = true; 若i != j, 且 i 与 j相差超过1, 则需要看dp[i+1][j-1]是否为回文串, 即dp[i][j] = dp[i + 1][j - 1]; dp数组的初始化 全部初始化为false. 遍历顺序 由递推公式知, dp[i][j]会由左下角的值推出, 故应当外围for循环从后向前, 内层for循环从前向后. 题解 动态规划: 123456789101112131415class Solution {public: int countSubstrings(string s) { vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false)); int result = 0; for (int i = s.size() - 1; i &gt;= 0; i--) for (int j = i; j &lt; s.size(); j++) if(s[i] == s[j]) if (j - i &lt;= 1 || dp[i + 1][j - 1]) { result++; dp[i][j] = true; } return result; }}; 双指针法: 12345678910111213141516171819class Solution {private: int extend(const string &amp;s, int i, int j) { int res = 0; while (i &gt;= 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] == s[j]) { i--; j++; res++; } return res; }public: int countSubstrings(string s) { int result = 0; for (int i = 0; i &lt; s.size(); i++) { // 从给定的字符开始, 双指针向左向右展开, 寻找以给定的一个或两个字符为中心的字符串是否为回文串 result += extend(s, i, i); result += extend(s, i, i + 1); } return result; }}; 516.最长回文子序列 代码随想录链接 题目 LeetCode-516.最长回文子序列 从给定的字符串中找出最长的回文子序列, 返回其长度. 题目分析 动态规划五部曲: 确定dp数组及下标的含义 dp[i][j]表示s[i, j]范围内最长的回文子序列的长度为dp[i][j]. 确定递推公式 如果s[i] == s[j], 则dp[i][j] = dp[i + 1][j - 1] + 2; 如果s[i] != s[j], 则尝试让s[i] 和 s[j] 分别加入 s[i + 1, j - 1]的序列中, 求回文子序列的最大长度, 即dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]). dp数组的初始化 二维数组正对角线上的值全部初始化为1, 其余部分为0. 遍历顺序 由递推公式知, dp[i][j]的来源状态有dp[i + 1][j - 1], dp[i][j - 1], dp[i + 1][j]. 故遍历顺序一定是从下往上, 从左向右. 题解 1234567891011121314class Solution {public: int longestPalindromeSubseq(string s) { vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size(), 0)); for (int i = 0; i &lt; s.size(); i++) dp[i][i] = 1; for (int i = s.size() - 1; i &gt;= 0; i--) for (int j = i + 1; j &lt; s.size(); j++) if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]); return dp[0].back(); }}; 动态规划总结篇 代码随想录链接 最重要的: 动态规划五部曲: 确定dp数组及下标的含义 确定递推公式 dp数组的初始化 遍历顺序 举例推导","link":"/algorithm-train-day57/"},{"title":"代码随想录算法训练营第58天 | 739.每日温度, 496.下一个更大元素 I","text":"739.每日温度 代码随想录链接 题目 LeetCode-739.每日温度 根据给定的数组, 给出每一位数之后下一位比自己更大的数和自身的索引差. 题目分析 可以两层for循环暴力法来做, 时间复杂度为\\(O(n^2)\\). 下面是单调栈的写法, 单调栈就是从栈顶到栈底只能存放单调递增或者单调递减的数据(存放索引即可), 当下一位数据的加入使得单调递增或者单调递减不成立时, 将栈内元素不断弹出, 直到栈为空或者剩余元素和要加入的元素形成的栈符合单调递增或者单调递减. 对于本题目, 有三种情况: 要加入的元素和栈顶元素相等 本题要求是下一个更大的元素, 所以栈从栈顶到栈底应该是递增栈, 此时直接将元素入栈即可. 要加入的元素小于栈顶元素 加入比栈顶元素更小的元素不会破坏栈从栈顶到栈底元素递增的状态, 可以直接将元素入栈. 要加入的元素大于栈顶元素 加入的元素比栈顶元素大, 破坏了站从栈顶到栈底递增的状态, 所以需要将栈顶元素不断弹出, 直到栈符合递增的状态. 在不断弹出的过程中, 要加入的元素就是被弹出元素右侧第一个比其大的元素, 进行标记即可. 题解 1234567891011121314151617181920class Solution {public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { stack&lt;int&gt; st; vector&lt;int&gt; result(temperatures.size(), 0); st.push(0); // 第一个元素入栈 for (int i = 1; i &lt; temperatures.size(); i++) { // 遍历后序所有元素 if (temperatures[i] &gt; temperatures[st.top()]) { // 如果元素大于栈顶元素, 开始弹出并标记 while (!st.empty() &amp;&amp; temperatures[i] &gt; temperatures[st.top()]) { result[st.top()] = i - st.top(); st.pop(); } st.push(i); } else { // 元素小于等于栈顶元素, 仅入栈 st.push(i); } } return result; }}; 496.下一个更大元素 I 代码随想录链接 题目 LeetCode-496.下一个更大元素 I 给定两个没有重复元素的数组A和B, A是B的子集, 求A中每一个元素在B中对应的元素的右侧第一个比自己大的元素. 题目分析 在上面一题的基础上, 对B数组仍然调用上一题的逻辑, 但在弹出栈顶元素时, 判断当前栈顶元素是否在A中存在, 若存在, 则将试图入栈的元素标记为A中该元素在B中对应位置右侧存在的第一个比自身大的数. 题解 1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { stack&lt;int&gt; st; vector&lt;int&gt; result(nums1.size(), -1); unordered_map&lt;int, int&gt; map; for (int i = 0; i &lt; nums1.size(); i++) map[nums1[i]] = i; st.push(0); for (int i = 1; i &lt; nums2.size(); i++) { if (nums2[i] &lt;= nums2[st.top()]) { st.push(i); } else { while (!st.empty() &amp;&amp; nums2[i] &gt; nums2[st.top()]) { if (map.count(nums2[st.top()]) &gt; 0) { int index = map[nums2[st.top()]]; result[index] = nums2[i]; } st.pop(); } } st.push(i); } return result; }};","link":"/algorithm-train-day58/"},{"title":"代码随想录算法训练营第59天 | 503.下一个更大元素II, 42.接雨水","text":"503.下一个更大元素II 代码随想录链接 题目 LeetCode-503.下一个更大元素II 给定一个循环数组, 在循环的情况下寻找每一个元素右侧的第一个比其大的元素. 题目分析 可以看作是单调栈连续对一个数组执行了两次, 且之间执行是连续的. 可以在for循环的控制条件里, 将i结束的条件设置为小于两倍的数组长度, 并在for循环内使用\\(i\\ \\% \\ nums.size()\\) 来进行迭代. 题解 12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; result(nums.size(), -1); if (nums.size() == 1) return result; stack&lt;int&gt; st; st.push(0); for (int i = 1; i &lt; nums.size() * 2; i++) { if (nums[i % nums.size()] &lt;= nums[st.top() % nums.size()]) st.push(i); else { while (!st.empty() &amp;&amp; nums[st.top() % nums.size()] &lt; nums[i % nums.size()]) { result[st.top() % nums.size()] = nums[i % nums.size()]; st.pop(); } st.push(i); } } return result; }}; 42.接雨水 代码随想录链接 题目 LeetCode-42.接雨水 给定一系列在横轴上摆放的柱子的高度, 求这些柱子和横轴之间所形成的容器最多能接多少雨水. LeetCode-42.接雨水 如图, 黑色是柱子, 蓝色是雨水, 题目要求的就是蓝色块的面积(二维下可不是面积🐴) 题目分析 双指针法 针对每一个柱子上的面积进行单独考虑, 一个柱子上的蓝色块的面积, 由左右方向各自最高的共两根柱子中, 较矮的那根柱子和自身的高度差决定. LeetCode-42.接雨水 例如, 柱子高度height[0,1,0,2,1,0,1,3,2,1,2,1] 对应的图片是上面这张图片, 当i = 2时, height[2] = 0, 其上方的积水为1个单位, 由左边高度为1的柱子和自身为0的柱子求得; i = 6时, height[6] = 1, 其上方积水为1个单位, 由左侧最高的柱子的高度2和自身高度1求得. 我们可以在针对每个柱子进行积水计算时, 分别找左侧最高的柱子和右侧最高的柱子, 但这样会有很多重复的计算, 解决办法之一是先将每个柱子的左侧最高高度和右侧最高高度进行一次计算并保存下来, 这样能降低时间复杂度. 单调栈 单调栈方法下, 一行一行地计算积水的量. 在给定柱子高度的环境下, 积水只会出现在有凹槽的地方, 有凹槽的地方一定是出现在从前向后遍历时, 由递减变为递增的状态处, 此时就应该进行横向的积水量计算. LeetCode-42.接雨水(单调栈) 由前向后使用单调栈进行遍历时, 有三种情况: 栈顶索引对应的元素大于遍历到的元素 此时将元素入栈符合栈顶到栈底元素递增的情况, 对应在柱子中, 是凹槽的左侧高度下降部分. 栈顶索引对应的元素等于遍历到的元素 元素可以直接入栈, 并不影响计算, 或者只保存一者, 最终不影响结果. 栈顶索引对应的元素小于遍历到的元素 此时说明凹槽出现了, 应该开始计算当前开始变高的柱子和左侧柱子形成的凹槽的单位. 题解 双指针法: 123456789101112131415161718192021222324class Solution {public: int trap(vector&lt;int&gt;&amp; height) { if (height.size() &lt;= 2) return 0; vector&lt;int&gt; maxLeft(height.size(), 0); vector&lt;int&gt; maxRight(height.size(), 0); maxLeft[0] = height[0]; for (int i = 1; i &lt; height.size(); i++) maxLeft[i] = max(maxLeft[i - 1], height[i]); maxRight[height.size() - 1] = height.back(); for (int i = height.size() - 2; i &gt;= 0; i--) maxRight[i] = max(maxRight[i + 1], height[i]); int sum = 0; for (int i = 0; i &lt; height.size(); i++) { int count = min(maxLeft[i], maxRight[i]) - height[i]; if (count &gt; 0) sum += count; } return sum; }}; 单调栈: 123456789101112131415161718192021222324252627class Solution {public: int trap(vector&lt;int&gt;&amp; height) { if (height.size() &lt;= 2) return 0; stack&lt;int&gt; st; st.push(0); int sum = 0; for (int i = 1; i &lt; height.size(); i++) { if (height[i] &lt;= height[st.top()]) st.push(i); else { while (!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) { int mid = st.top(); st.pop(); if (!st.empty()) { int h = min(height[st.top()], height[i]) - height[mid]; int w = i - st.top() - 1; sum += h * w; } } st.push(i); } } return sum; }};","link":"/algorithm-train-day59/"},{"title":"代码随想录算法训练营第60天 | 84.柱状图中最大的矩形","text":"84.柱状图中最大的矩形 代码随想录链接 题目 LeetCode-84.柱状图中最大的矩形 给定一系列柱状图中依次相邻柱子的高度, 求这些柱子能勾勒出的最大的矩形的面积. 题目分析 和昨天LeetCode-42.接雨水非常相似. 双指针 在LeetCode-42.接雨水的双指针法中, 遍历的每个柱子是为了求当前柱子上能积多少水. 而本题目中, 是要求以每根柱子的高度为高, 与两侧的柱子能形成的最大面积, 这就要求找到每根柱子两侧连续且不低于自身高度的柱子的范围, 这样才能求得最大面积. 和LeetCode-42.接雨水类似, 先标记每根柱子左侧最近的高度低于自身的柱子, 再标记每根柱子右侧最近的高度低于自身的柱子, 这样就确定了以自身高度为高, 左右两个高度低于自身的柱子中间的部分为宽的矩形. 单调栈 与上面分析的思路类似, 单调栈中应该从栈顶到栈底是递减顺序, 这样能保证在遇到比栈顶小的元素时, 将栈内的元素进行类似于上面的求面积操作. 题解 双指针: 123456789101112131415161718192021222324252627282930class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { vector&lt;int&gt; minLeftIndexes(heights.size()); vector&lt;int&gt; minRightIndexes(heights.size()); minLeftIndexes[0] = -1; // 统计每根柱子左侧最近且低于自己的柱子 for (int i = 1; i &lt; heights.size(); i++) { int t = i - 1; while (t &gt;= 0 &amp;&amp; heights[t] &gt;= heights[i]) t = minLeftIndexes[t]; minLeftIndexes[i] = t; } minRightIndexes.back() = heights.size(); // 统计每根柱子右侧最近且低于自己的柱子 for (int i = heights.size() - 1; i &gt;= 0; i--) { int t = i + 1; while (t &lt; heights.size() &amp;&amp; heights[t] &gt;= heights[i]) t = minRightIndexes[t]; minRightIndexes[i] = t; } int result = 0; // 求左右两侧高于等于自己的柱子以自己的高所能形成的面积 for (int i = 0; i &lt; heights.size(); i++) { int sum = heights[i] * (minRightIndexes[i] - minLeftIndexes[i] - 1); result = max(sum, result); } return result; }}; 单调栈: 123456789101112131415161718192021222324252627282930class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int result = 0; stack&lt;int&gt; st; heights.insert(heights.begin(), 0); heights.push_back(0); st.push(0); for (int i = 1; i &lt; heights.size(); i++) { if (heights[i] &gt;= heights[st.top()]) { st.push(i); } else { while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) { int mid = st.top(); st.pop(); if (!st.empty()) { int left = st.top(); int right = i; int w = right - left - 1; int h = heights[mid]; result = max(result, w * h); } } st.push(i); } } return result; }};","link":"/algorithm-train-day60/"},{"title":"代码随想录算法训练营第56天 | 583.两个字符串的删除操作, 72.编辑距离, 编辑距离总结篇","text":"583.两个字符串的删除操作 代码随想录链接 题目 LeetCode-583.两个字符串的删除操作 给定两个单词, 为使两个单词相同, 每一步可以删除任意一个字符串中的一个字符, 求至少需要多少步可以使得两个字符串相同. 题目分析 动态规划五部曲: 确定dp数组及下标的含义 dp[i][j]表示以i-1结尾的字符串word1和以j-1结尾的字符串word2想要达到相等要删除的元素次数. 递推公式 分为两种情况: word1[i] == word2[j] 此时, dp[i][j] = dp[i - 1][j - 1] word1[i] != word2[j] 这个时候, 可以选择删除word1[i - 1]处的字符, 也可以选择删除word2[j - 1]处的字符, 亦或是同时删除word1[i - 1]和word2[j - 1]处的字符 dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2)) dp数组的初始化 dp[i][0]和dp[0][j]是一定要初始化的, 而根据dp数组及下标的意义, 所有dp[i][0]都应该被赋值为i, dp[0][j]同理. 遍历顺序 外层for循环遍历word1中字符, 内层for循环遍历word2中字符. 题解 1234567891011121314151617class Solution {public: int minDistance(string word1, string word2) { vector&lt;vector&lt;int&gt;&gt; dp(word1.size() + 1, vector&lt;int&gt;(word2.size() + 1, 0)); for (int i = 0; i &lt;= word1.size(); i++) dp[i][0] = i; for (int j = 0; j &lt;= word2.size(); j++) dp[0][j] = j; for (int i = 1; i &lt;= word1.size(); i++) for (int j = 1; j &lt;= word2.size(); j++) if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2)); return dp.back().back(); }}; 72.编辑距离 代码随想录链接 题目 LeetCode-72.编辑距离 给定两个单词, 规分别插入, 删除, 替换一个字符为1步, 求将第一个字符串转化为第二个字符串需要几步. 题目分析 动态规划五部曲: 确定dp数组及下标的含义 dp[i][j]代表以下标i-1结尾的字符串word1, 和以下标j-1为结尾的字符串word2, 最近的编辑距离. 递推公式 分为两种情况: word1[i - 1] == word2[j - 1] 此时, 当前位置的编辑距离和两个字符串在上一个字符比较时的结果一样, dp[i][j] = dp[i - 1][j - 1] word1[i - 1] != word2[j - 1] 可以进行的操作有, 删除word1[i-1], 删除word2[j-1], 替换word1[i-1]为word2[j-1] dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1 dp数组的初始化 和上一题一样, 需要对dp[i][0]和dp[0][j]进行初始化, 且初始化方式相同. 遍历顺序 外层for循环遍历word1中字符, 内层for循环遍历word2中字符. 题解 1234567891011121314151617class Solution {public: int minDistance(string word1, string word2) { vector&lt;vector&lt;int&gt;&gt; dp(word1.size() + 1, vector&lt;int&gt;(word2.size() + 1, 0)); for (int i = 0; i &lt;= word1.size(); i++) dp[i][0] = i; for (int j = 0; j &lt;= word2.size(); j++) dp[0][j] = j; for (int i = 1; i &lt;= word1.size(); i++) for (int j = 1; j &lt;= word2.size(); j++) if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1; return dp.back().back(); }}; 编辑距离总结篇 代码随想录链接","link":"/algorithm-train-day56/"},{"title":"代码随想录算法训练营第6天 | 242.有效的字母异位词，349.两个数组的交集，202.快乐数，1.两数之和","text":"没第5天？因为第5天是周日，放个假。 哈希表理论基础 什么是哈希表 哈希表就是根据数据的关键码来对数据进行直接访问的数据结构。例如数组其实就是一个哈希表，可以根据数据的索引来直接访问对应位置的数据。 哈希表主要用来解决快速判断一个元素是否出现在一个集合中。这里的快速判断是指要通过\\(O(1)\\)的时间复杂度来判断，而并非像遍历数组那样的\\(O(n)\\)的时间复杂度。 哈希函数 通过一定的计算方法，将要存储的数据转化出来对应的哈希表上的索引的函数，为哈希函数。 例如，将学生的姓名通过哈希函数计算出数值，再将该学生的姓名存放在哈希表上的对应位置。 如果哈希函数的设计不足以完全达到对不同的数据产生一定产生不同的哈希值（例如哈希函数为 x % 10时，数据11和数据21的哈希值都是1），就会发生哈希碰撞。 哈希碰撞 在下面这个图中，两个不同的数据，通过哈希函数计算出来的哈希值是相同的。 解决哈希碰撞主要有两种方法： 拉链法 哈希表表内实际上存储的是一个一个（警撅）链表的表头指针，将发生哈希碰撞的数据按照插入的先后顺序，存放在对应位置的链表上。如图所示。 线性探测法 该方法的思想是，在遭遇到碰撞时，从哈希值所指的位置开始，线性向后依次探测出一个空位置，并将数据存放至该空位置。 但是单纯的线性探测，会使得哈希值相同的数据聚集在同一个区域，此时一个改进的方法就是将“依次探测空位置”变为“按照一定的计算方法向后探测位置”，如将向后探测位置的步数从每次加1改为向后探测\\(1^2, 2^2, ...\\)。 再哈希 准备多个哈希函数，在出现哈希碰撞时，使用下一个哈希函数进行计算，直至哈希函数不再冲突。 其中\\(RH_i\\)为不同的哈希函数。 常见的三种哈希结构 数组 set--集合 map--映射 数组作为哈希结构在上文中有提到。 set在C++主要有下面三种数据结构，将代码随想录的表格抄过来，如下表所示： 数据结构 底层实现 有序 可以重复 可以更改数值 查询效率 增删效率 std::set 红黑树 Y N N \\(O(logn)\\) \\(O(logn)\\) std::multiset 红黑树 Y Y N \\(O(logn)\\) \\(O(logn)\\) std::unordered_set 哈希表 N N N \\(O(1)\\) \\(O(1)\\) 红黑树是一种平衡二叉搜索树，所以key是有序的，但key不能修改，只能对数据进行删除和增加。 C++中，集合的调用形式为： 12345678#include &lt;set&gt;// ...std::unordered_set&lt;DATA_TYPE&gt; set; // 声明一个集合set.insert(DATA); // 插入一个数据auto iter = set.find(DATA); // 判断一个集合是否包含一个数据if (iter != set.end()) { // 如果包含一个数据，则进行一些处理 // do things} 映射，顾名思义，就是将一个值映射到另外一个值上面，形成一定的对应关系。 map在C++中主要有以下三种数据结构，将代码随想录的表格抄过来，如下表所示： 数据结构 底层实现 有序 可以重复 可以更改数值 查询效率 增删效率 std::map 红黑树 Y(Key) N N \\(O(logn)\\) \\(O(logn)\\) std::multimap 红黑树 Y(key) Y N \\(O(logn)\\) \\(O(logn)\\) std::unordered_map 哈希表 N(Key) N N \\(O(1)\\) \\(O(1)\\) 同上，multimap和map中的key是有序的且无法修改。 C++中，映射的调用形式为： 12345678#include &lt;map&gt;// ...std::unordered_set&lt;KEY_TYPE, DATA_TYPE&gt; map; // 声明一个映射map.insert(pair&lt;KEY_TYPE, DATA_TYPE&gt;(key, data)); // 插入一对数据auto iter = map.find(key); // 判断一个集合是否包含一个数据if (iter != map.end()) { // 如果包含一个数据，则进行一些处理 // do things} 使用集合来解决哈希问题时，优先使用unordered_set，因为其查询效率和增删效率都是最优的。 242.有效的字母异位词 代码随想录链接 题目 LeetCode-242 给定两个字符串，判断这两个字符串是否是异位词。 自己的想法 异位词的其实就是同样的一组字母，进行不同的排列而形成的单词。特点有： 出现的字符相同 每个字符的出现次数相同 那在这里其实就可以使用映射关系，来存储26个字母中每个字母的出现的次数。可以使用数组，也可以使用map。 解法 1234567891011class Solution {public: bool isAnagram(string s, string t) { int letters[26] = {0}; // 用于存储26个字母出现次数的数组 for (int i = 0; i &lt; s.size(); i++) letters[s[i] - 'a']++; // 遍历s字符串，计算每个字母出现的次数 for (int i = 0; i &lt; t.size(); i++) letters[t[i] - 'a']--; // 遍历t字符串，将出现的字母的次数进行减1 for (int i = 0; i &lt; 26; i++) if (letters[i] != 0) return false; // 如果数组中出现了不为0的值，证明两个字符串不符合异位词的特点 return true; // 如果数组最终均为0值，则两个字符串时异位词 }}; 该解法时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)。 349. 两个数组的交集 代码随想录链接 题目 LeetCode-349 给定两个数组，输出它们的交集。 自己的想法 集合么，将一个数组转为一个集合，然后遍历另外一个数组，依次判断第二个数组中的值是否存在于集合中，若存在，则将该数插入到结果集合中。 解法 1234567891011class Solution {public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_set&lt;int&gt; result; // 结果集合 unordered_set&lt;int&gt; nums1_set(nums1.begin(), nums1.end()); // 根据第一个数组中的值生成一个集合 for (int i = 0; i &lt; nums2.size(); i++) { // 依次判断第二个数组中的数是否存在于集合中 if (nums1_set.find(nums2[i]) != nums1_set.end()) result.insert(nums2[i]); // 若存在，就将该值插入到结果结合中 } return vector&lt;int&gt;(result.begin(), result.end()); // 将结果集合转化为数组 }}; unordered_set的查询和增删效率都是\\(O(1)\\)，故生成集合的过程耗费时间为\\(O(n)\\)，遍历并判断是否存在以及插入到结果集合所耗费的时间为\\(O(n)\\)，将结果转化为数组的时间为\\(O(n)\\)，故时间复杂度为\\(o(n)\\)，空间复杂度为\\(o(n)\\)。 202. 快乐数 代码随想录链接 题目 LeetCode-202 判断一个数是否为快乐数，快乐数的定义为：进行一个循环，每次循环都将这个数替换为其各位数的平方和，若最终平方和为1，则该数为快乐数；若一直无限循环，则该数不是快乐数。 自己的想法 一直无限循环的话，每次替换的数值必定会有重复的，例如给定数是2时，其替换的值依次为：4,16,37,58,89,145,42,20,4,...。是一个重复的序列。 所以我们可以使用一个集合，当替换的值不为1时，判断每次替换的值是否存在于该集合中，如果存在则说明非快乐数，否则就将该替换值加入集合当中，继续循环。 解法 12345678910111213141516171819202122class Solution {public: int getSum(int n) { // 用于计算一个数的各位平方之和的函数 int sum = 0; while (n) { sum += (n % 10) * (n % 10); n /= 10; } return sum; } bool isHappy(int n) { unordered_set&lt;int&gt; sumSet; // 每次计算出的平方和的集合 while (n != 1) { // 当平方和不为1时进行循环 n = getSum(n); // 计算出平方和 if (sumSet.find(n) != sumSet.end()) return false; // 如果已经出现过这个平方和，说明非快乐数 else sumSet.insert(n); // 没有出现过就将本次平方和加入集合 } return true; // n == 1时，该数为快乐数 }}; 1. 两数之和 代码随想录链接 题目 LeetCode-1 给定一个数组和一个值，判断该数组中是否存在两个数且他们之和为给定值，若存在，则输出这两个值的索引。 自己的想法 暴力解法，两个for循环，根据一个数来查是否存在另外一个数 由于要输出的是两个值的索引，这个地方可以使用map来存储&lt;值, 索引&gt;对来解决问题。 解法一 12345678910class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { for (int i = 0; i &lt; nums.size(); i++) { // 遍历数组 int num1 = nums[i]; // 取当前遍历到的值A for (int j = i + 1; j &lt; nums.size(); j++) if (target - num1 == nums[j]) return vector&lt;int&gt;{i, j}; // 遍历查找在A之后的值中是否有与A之和等于给定值的数（你说为啥不从前面开始找，那我遍历前面的时候不是找过了？） } return vector&lt;int&gt;(); // 不存在则返回空数组 }}; 时间复杂度为\\(O(n^2)\\)，空间复杂度为\\(o(1)\\)。 解法二 123456789101112class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; indexMap; // 存储&lt;值, 索引&gt;对的映射 for (int i = 0; i &lt; nums.size(); i++) { // 遍历数组 auto iter = indexMap.find(target - nums[i]); // 查找映射中是否有key为相应的加数的键值对 if (iter != indexMap.end()) return {iter -&gt; second, i}; // 若存在，则返回这两个索引 indexMap.insert(pair&lt;int, int&gt;(nums[i], i)); // 否则就将该键值对插入映射中 } return {}; // 不存在则返回空数组 }}; unordered_map的查询和增删效率都是\\(O(1)\\)，故该实现的时间复杂度为\\(O(n)\\)，空间复杂度为\\(o(n)\\)。","link":"/algorithm-train-day6/"},{"title":"代码随想录算法训练营第8天 | 344.反转字符串，541.反转字符串II，剑指Offer 05.替换空格，151.翻转字符串里的单词，剑指Offer58-II.左旋转字符串","text":"344.反转字符串 代码随想录链接 题目 LeetCode-344 将一个字符串中的字符翻转。只能在函数中使用\\(O(1)\\)的额外空间。 自己的想法 使用\\(O(1)\\)的空间意味着，对于字符串的逆转操作只能原地进行。 因为本题的关键点就在于逆转操作，故不可以直接使用reverse函数完成。 使用双指针法，将左右指针分别指向字符串的起始位置和末尾，交换两个指针指向的字符，并将指针向中间靠拢。 解法 1234567891011class Solution {public: void reverseString(vector&lt;char&gt;&amp; s) { int left = 0, right = s.size() - 1; // 初始化左右指针 while (left &lt; right) { // 左右指针结束循环条件 swap(s[left], s[right]); // 交换左右指针的值 left++; // 左右指针分别向中间移动 right--; } }}; 时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)。 541.反转字符串II 代码随想录链接 题目 LeetCode-541 给定一个字符串和一个正整数k，对于每2k的字符，翻转前k个字符。若剩余不到k个字符，则全部翻转；若剩余字符数大于等于k但小于2k，则翻转前k个字符。 自己的想法 使用一个for循环来确定每2k个字符所形成的字符串的左侧起始区间，判断自该位置起始的剩余字符串的长度是否大于等于k，若大于等于k，则翻转自该位置起的k个字符所形成的字符串；若剩余长度小于k，则翻转剩余字符。 解法 12345678910111213class Solution {public: string reverseStr(string s, int k) { for (int i = 0; i &lt; s.size(); i += 2 * k) { // 确定每2k个字符形成的字符串的起始位置 if (i + k &lt;= s.size()) { // 若剩余字符个数大于等于k reverse(s.begin() + i, s.begin() + i + k); // 翻转k个字符 } else { // 否则就翻转剩下的字符 reverse(s.begin() + i, s.end()); } } return s; }}; 剑指Offer 05.替换空格 代码随想录链接 题目 剑指 Offer 05.替换空格 将字符串中的空格替换为\"%20\"。 自己的想法 如果使用额外的新数组作为结果进行返回，题目就很简单，遍历数组即可。使用\\(O(1)\\)的空间复杂度才使得这个题目有难度。 这个题目类似于LeetCode-27.移除元素，可以使用双指针方法来进行替换。若要原地替换，首先统计字符串中有多少个空格，计算出新的字符串应该有的长度，对原字符串进行长度调整。然后再使用两个指针，指针A指向原字符串的末尾，指针B指向调整后的字符串的末尾。将指针A向前移动，若遇见一个空格，则在指针B指向的位置依次向前插入'0', '2', '%'；若遇见空格之外的字符，则直接拷贝至指针B指向的位置。 解法一 暴力法 123456789101112class Solution {public: string replaceSpace(string s) { string result; for (char c: s) { if (c == ' ') { result.append(&quot;%20&quot;); } else result.push_back(c); } return result; }}; 解法二 12345678910111213141516171819202122232425class Solution {public: string replaceSpace(string s) { int blankCount = 0; for (char c: s) { // 统计空格的个数 if (c == ' ') { blankCount++; } } int oldPointer = s.size() - 1; // 指针A指向原字符串的末尾 s.resize(2 * blankCount + s.size()); // 扩展字符串至替换后应该有的长度 int newPointer = s.size() - 1; // 指针B指向新字符串的末尾 while (blankCount) { // 当空格没有被替换完毕时 if (s[oldPointer] == ' ') { // 如果指针A遇到了一个空格 s[newPointer--] = '0'; // 依次插入替换的字符 s[newPointer--] = '2'; s[newPointer--] = '%'; blankCount--; // 空格计数器减1 oldPointer--; // 指针A向前移动 } else s[newPointer--] = s[oldPointer--]; // 遇到的不是空格，就直接拷贝原字符 } return s; }}; 时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)。 151.翻转字符串里的单词 代码随想录链接 题目 LeetCode-151 将字符串中的单词进行翻转，而单词保持原来的状态。同时去除字符串前后的空格和连续的多余空格。 自己的想法 字符串中的一些部分翻转而另外一些保持原形，就可以考虑使用先整体翻转再部分翻转来解决。 在这个题目中，可以先去除多余的空格，再将整个字符串翻转，最后再以单词为分区，进行分区内的翻转。 解法 12345678910111213141516171819202122232425262728class Solution {public: string reverseWords(string s) { int fast = 0, slow = 0; // 同27.移除元素，使用双指针法移除元素 while (s[fast] == ' ' &amp;&amp; fast &lt; s.size()) fast++; // 移除开头的空格 while (fast &lt; s.size()) { // 每碰见一个空格，就像慢指针的位置写入一个空格，并将快指针移至下一个不为空格的位置 if (s[fast] == ' ') { s[slow++] = ' '; while (s[fast] == ' ' &amp;&amp; fast &lt; s.size()) fast++; } else { s[slow++] = s[fast++]; // fast指针不指向空格时，拷贝fast指针指向的内容至slow指针 } } if (s[slow - 1] == ' ') { // 去除末尾可能多出来的一个空格 slow--; } s.resize(slow); // 调整s的大小，该大小为去除多余空格之后的字符串大小 reverse(s.begin(), s.end()); // 翻转整个字符串 int start = 0; // 标记每个单词的起始位置 for (int i = 0; i &lt;= s.size(); i++) { // 遍历字符串，找单词之间的空格 if (i == s.size() || s[i] == ' ') { // 遇到了空格或者字符串末尾 reverse(s.begin() + start, s.begin() + i); // 翻转[start, i)区间的字符串 start = i + 1; // 移动单词起始位置至空格后的字符 } } return s; }}; 剑指 Offer 58-II.左旋转字符串 代码随想录链接 题目 剑指 Offer 58-II.左旋转字符串 给定一个字符串和一个整数k，将前k位的字符移至字符串末尾。 自己的想法 和上面的题相似，可以采用先整体翻转再局部翻转的方法解决。先将整个字符串进行翻转，再翻转\\([0, size - k)\\)区间的字符，最后反转\\([size - k, size)\\)部分即可。 解法 123456789class Solution {public: string reverseLeftWords(string s, int n) { reverse(s.begin(), s.end()); // 翻转整个字符串 reverse(s.begin(), s.end() - n); // 翻转[0, size - k) reverse(s.end() - n, s.end()); // 翻转[size - k, size) return s; }};","link":"/algorithm-train-day8/"},{"title":"代码随想录算法训练营第9天 | 28.实现 strStr()，459.重复的子字符串，字符串总结，双指针回顾","text":"28.实现strStr() 代码随想录链接 题目 LeetCode-28 给定字符串A和B，返回B作为子串在A中出现的位置。 自己的想法 暴力法就不说了，时间复杂度\\(O(m * n)\\)。 优化方法是使用KMP算法来进行字符串匹配，可惜考研的时候只在王道上学了KMP怎么样手工计算next数组，代码莫得掌握。 KMP太长了，感觉自己讲不明白，详细的说明可以去看上面代码随想录的链接。这里只说明一下KMP的思想就是：字符串某个位置出现不匹配的时候，可以不用从头开始匹配，直接根据next数组跳转至已经匹配过得一部分。 题解 1234567891011121314151617181920212223242526272829class Solution {public: void getNext(string &amp;s, int* next) { // 获取字符串的next数组 int j = 0; // j是前缀末尾，初始指向首位 next[0] = j; // 后面一位的值为回退到字符串初始位置 for (int i = 1; i &lt; s.size(); i++) { // i指向后缀末尾 while (j &gt; 0 &amp;&amp; s[i] != s[j]) { // 前缀末尾不等于后缀末尾时，前缀末尾向前回退 j = next[j - 1]; } if (s[i] == s[j]) j++; // 找到相同的前后缀 next[i] = j; // 将前缀的长度赋给next数组中的next[i] } } int strStr(string haystack, string needle) { if (needle.size() == 0) return 0; int next[needle.size()]; getNext(needle, next); // 根据needle获取next数组 int j = 0; // j用来指向needle中的字符 for (int i = 0; i &lt; haystack.size(); i++) { // i用来指向haystack里的字符 while (j &gt; 0 &amp;&amp; haystack[i] != needle[j]) j = next[j - 1]; // 若字符不相同，needle的指针根据next数组回退 if (haystack[i] == needle[j]) j++; // 相同时，needle指针往后探索 if (j == needle.size()) { // needle指针探索到了needle的末尾时，证明匹配完成 return (i - needle.size() + 1); } } return -1; }}; 459.重复的子字符串 代码随想录链接 题目 LeetCode-459 判断一个字符串是否由一个子串多次重复构成。 自己的想法 暴力法 其实也可以用KMP算法来解决，如果一个字符串是由其子串多次重复而得到的，其next数组就会呈现出一定的规律。 假设重复n次来组成的串s的子串为sub，长为x, 那么s的长度为\\(m * x\\)，且s的最长相同前后缀长度必定为 \\((m - 1) * x\\)，通过这个条件，就可以根据next数组判断是否满足题设。 题解 1234567891011121314151617181920212223class Solution {public: void getNext(int *next, const string &amp;s) { // 和上题一样，根据给定字符串获得一个next数组 int j = 0; next[0] = 0; for (int i = 1; i &lt; s.size(); i++) { while (j &gt; 0 &amp;&amp; s[i] != s[j]) j = next[j - 1]; if (s[i] == s[j]) j++; next[i] = j; } } bool repeatedSubstringPattern(string s) { if (s.size() == 0) return false; int next[s.size()]; getNext(next, s); int len = s.size(); if (next[len - 1] != 0 &amp;&amp; (len % (len - next[len - 1]) == 0)) { // 如果next数组的最后一位不指向0，且字符串长度能够整除以最长前后缀以外的部分的长度，则满足条件 return true; } return false; }}; 字符串总结 字符串，其实可以看做是字符的数组。在C++中，字符串可以是 12345char a[5] = &quot;asd&quot;;\\\\ 也可以是vector&lt;char&gt; vc;\\\\ 还可以是string s; 使用char的数组来组成一个字符串，需要自行判断'\\0‘来检测字符串的结尾，string则不用，且string类型提供了更多的接口来进行字符串处理。所以在遇到字符串问题的时候，尽量还是使用string类型。 双指针法 和数组中的双指针法非常相似，无论是翻转，还是去除某些元素。 例题： 344.反转字符串 字符串：替换空格 151.翻转字符串里的单词 反转题目 这类题目涉及到对于字符串的翻转操作，按照要求完成一部分翻转或者是某个区间的翻转。 例题： 541. 反转字符串II 151.翻转字符串里的单词 剑指Offer58-II.左旋转字符串 KMP 两个字符串进行匹配，思想是匹配过程中出现不相同字符时，使用预先计算好的内容，避免从头开始重新进行匹配。 例题： 28.实现 strStr() 459.重复的子字符串 双指针回顾 双指针主要是用于将暴力法（通常情况下）的\\(O(n^2)\\)的时间复杂度给降低下来，使用两个指针在一个for循环下完成两个嵌套for循环的工作。 字符串 主要涉及原地翻转，去除给定字符操作。（其实在数组里也是这些） 例题： 344.反转字符串 剑指Offer 05.替换空格 151.翻转字符串里的单词 链表 还是反转，反转链表；以及环形结构的问题。 例题： 206.反转链表 142.环形链表II N数之和 例题： 15.三数之和 18.四数之和","link":"/algorithm-train-day9/"},{"title":"代码随想录算法训练营第7天 | 454.四数相加II，383. 赎金信，15.三数之和，18.四数之和，哈希总结","text":"454.四数相加II 代码随想录链接 题目 LeetCode-454 给定四个数组，计算满足从各个数组中取一个值得到的四个值之和为0的情况有几种。 自己的想法 怎么一上来先想到的是暴力法啊（恼） 因为要求四个数之和是0，且只要求输出可行的对数，可以使用一个map来存储第一个和第二个数组中每种可能的和，然后根据第三个数组和第四个数组中取出的数之和来找在map中是否有相应的数据满足四个数之和为0。 解法 1234567891011121314151617181920class Solution {public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) { unordered_map&lt;int, int&gt; addedMap; // 存储第1个和第2个数组中取出的数的值之和的情况 int count = 0; // 计数有多少种可能满足 for (int a: nums1) { for (int b: nums2) { addedMap[a + b]++; // 存储和的出现次数 } } for (int c: nums3) { for (int d: nums4) { if (addedMap[0 - (c + d)] != 0) { // 如果存在a+b满足a+b+c+d==0 count += addedMap[0 - (c + d)]; // 计数器增加 } } } return count; }}; 时间复杂度为\\(O(n^2)\\)，空间复杂度为\\(O(n)\\)。 383.赎金信 代码随想录链接 题目 LeetCode-383 给定一个字符串ransom和另一个字符串magazine，判断ransom字符串能否由magazine字符串中的字母组成，每个位置上的字母只能使用一次。 自己的想法 使用map统计magazine中每个字符出现的次数，然后再遍历ransom字符串，判断每个字符都在map内存在对应的足够的出现次数。 其实也可以用int record[26] = {0}来存，因为题目说了只有小写字母。 解法 123456789101112131415class Solution {public: bool canConstruct(string ransomNote, string magazine) { unordered_map&lt;char, int&gt; mapMagazine; // 用来存储magazine中字符出现次数的map for (char m: magazine) { mapMagazine[m]++; // 遍历magazine字符串，统计字符出现次数 } for (char r: ransomNote) { // 遍历ransom字符串 if (mapMagazine.count(r) &lt;= 0) return false; // 若map中不存在这个字符，直接判断不满足 mapMagazine[r]--; // 抵消map中这个字符的计数一次 if (mapMagazine[r] &lt; 0) return false; // 如果抵消后，计数低于0，证明不满足条件，返回false } return true; // 满足条件，返回true }}; 时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(n)\\)。 15.三数之和 代码随想录链接 题目 LeetCode-15 给定一个数组，输出三个位置不相同的数，且这三个数之和为0。 自己的想法 一开始想用哈希做来着，但是哈希感觉还要去重，不是很容易。然后就不知道该咋办了 看了代码随想录的提示，开始往双指针上考虑。这个方法主要是要想好开始的时候左右指针要怎么定义，以及移动指针的条件。 由于题目要求输出三个相加为0的数，所以可以对本题的数组进行排序。遍历数组，并在遍历的数据后方进行左右指针的调整。 解法 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; results; // 存储最终数组 sort(nums.begin(), nums.end()); // 对数组进行排序，sort函数默认为升序 for (int i = 0; i &lt; nums.size(); i++) { // 遍历数组中每个数据 if (nums[i] &gt; 0) { // 如果其本身就已经大于0，加上后面的数据必大于0，一定不满足条件 return results; } if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { // 如果和左侧相邻的数相同，已经计算过，不用再次计算 continue; } int left = i + 1; // 确定左右区间 int right = nums.size() - 1; while (right &gt; left) { // 指针不能重合 if (nums[i] + nums[left] + nums[right] &gt; 0) right--; // 如果三个值之和大于0，证明右指针需要朝着变小的方向移动 else if (nums[i] + nums[left] + nums[right] &lt; 0) left++; // 如果三个值之和小于0，证明左指针需要朝着变大的方向移动 else { // 如果三值之和等于0 results.push_back(vector&lt;int&gt;{nums[i], nums[left], nums[right]}); // 保存满足条件的结果 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; // 跳过会和刚才保存的结果相同的数据 while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; left++; // 继续收缩区间 right--; } } } return results; // 返回结果 }}; 18.四数之和 代码随想录链接 题目 LeetCode-18 在一个给定的数组内，找出4个索引不同的数据，使得四个数之和为给定的目标值。 自己的想法 和上面道题非常相似，其实感觉就可以在上面的题解的基础上，增加一个for循环，以两个for循环的索引指向的值之和为确定值，使用双指针法确定剩下两个数。 解法 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; result; // 结果数组 sort(nums.begin(), nums.end()); // 生序排序 for (int k = 0; k &lt; nums.size(); k++) { // 遍历，确定第1个值 if (nums[k] &gt; target &amp;&amp; nums[k] &gt;= 0) { // 如果本身就是正数且大于目标值，右侧的数只会比这个数大，加起来必定不会满足条件 break; } if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) { // 去重 continue; } for (int i = k + 1; i &lt; nums.size(); i++) { // 遍历，确定第2个值 if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= 0) { // 第1个值和第2个值加起来大于目标值且之和为正数，加上右侧的数必定不满足条件 break; } if (i &gt; k + 1 &amp;&amp; nums[i] == nums[i - 1]) { // 第2个值去重 continue; } int left = i + 1; // 确定左右区间 int right = nums.size() - 1; while (right &gt; left) { // 双指针循环条件 if ((long) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) right--; // 四数之和大于目标值，右指针左移 else if ((long) nums[k] + nums[i] + nums[left] + nums[right] &lt; target) left++; // 四数之和小于目标值，左指针右移 else { // 若四数之和等于目标值 result.push_back(vector&lt;int&gt;{nums[k], nums[i], nums[left], nums[right]}); // 保存结果 while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; // 左指针指向的值去重 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; // 右指针指向的值去重 right--; // 左右指针向中间移动一位 left++; } } } } return result; // 返回结果 }}; 哈希总结 哈希表在刷题中经常用于快速判断一个元素是否出现在集合里。一些哈希表实现的知识，请参考昨天的总结。 经典题目 数组作为哈希表 在昨天和今天的题目里，主要是用于在只会出现的小写字母的字符串判断。这种情况下使用数组要比使用C++的STL要更快一些。 LeetCode-242 有效的字母异位词 LeetCode-383 赎金信 set作为哈希表 当可能出现的数据的范围比较大时，再使用数组就不合理了，因为数组大小是有限的，而且声明过大的数组会浪费内存。 在昨天的文章中，提到了C++中set的三种数据结构，在不需要排序和数据重复的情况下，使用std::unordered_set是最高效的。 LeetCode-202 快乐数 LeetCode-349 两个数组的交集 map作为哈希表 相比于set，map适合用在需要记录额外信息的地方，例如，记录了一个元素出现了多少次、记录一个元素的在数组中的下标等等... map所存储的是键值对，在昨天的文章中，提到了C++中有三种map的数据结构，和set类似，如果不需要对key进行排序和重复的情况下，使用std::unordered_map的效率是最高的。 LeetCode-1 两数之和 LeetCode-454 四数相加II","link":"/algorithm-train-day7/"},{"title":"how-to-write-a-thesis-note","text":"","link":"/how-to-write-a-thesis-note/"},{"title":"11.1 迁移学习【斯坦福21秋季：实用机器学习中文版】","text":"本节课程课件： 课件 自己做的思维导图： 导图 迁移学习的出发点 - 在一个任务上学习到的知识，可以在另外一个地方用到 因为训练要花钱，还要搞数据集 途径 训练好的模型做成特征抽取的模块，得到特征干别的事情，比如作为另外一个模型的输入 在相关的任务上训练一个模型，在另外一个任务上直接用，例如GPT系列 在训练好的模型上，针对新的任务进行微调（本节内容） 相关领域 半监督学习 极端情况下，新的任务，不给标记；或者只给几张有标记 多任务学习，每一个任务都有自己的数据但不是很够，但任务之间又有相关性 转移知识 - 有很多大规模的标好的数据集，尤其是图片分类任务上（因为标记很容易） 计算机视觉的迁移学习里面，存在很多效果比较好的模型，希望把这些模型的知识拓展到自己的任务上去 刚开始进行任务的时候可能不会投入太多，看能不能利用别人在标记好的、比自己的数据集大10倍，100倍的数据集上面学到的一些东西迁移过来，试试效果 预训练模型 - 用的最多的迁移学习的方法 一般来说，一个神经网络大概分为两块 编码器 可以认为是特征提取器 将像素转化为在语义空间里面线性可分的一些特征（浅表示） 解码器 可能就是个线性层 把编码器的输出映射为最终结果，做决策 例如 给个猫的图片 可以认为除了最后一层之外的，都是编码器 最后一层把语义特征（如1024的特征向量），转化为语义空间内的表示 也可以认为最后几层都是解码器，剩下的是编码器 预训练模型 在比较大的数据集上训练好的一个模型 训练的数据集大，可以认为其有一定的泛化能力 泛化能力指，放到别的任务或者数据集上，多多少少也是能帮点忙 虽然目标任务可能不会对猫感兴趣，但是编码器部分多多少少学会了点怎么样去处理像素的信息 在ImageNet上训练的模型，能对其他任务的图片做特征提取，总比从随机开始好 Fine-Tune技巧 - 通常认为，在深度学习中微调能够带来最好的效果 在新的任务上面，构建一个新的模型，其架构要与预训练模型一样 如一个在ImageNet上训练好的ResNet 50模型 在新的任务上面，也要用一个ResNet 50模型（可以先找找在当前任务的特定架构上是不是有比较好的预训练模型） 初始化模型 新模型的特征提取器（编码器）的权重直接从预训练模型得到 解码器的权重随机初始化 不同任务的语义空间不同 例如图中右侧的例子 在限制搜索空间，进行训练 因为之前效果已经比较好了，已经在最优解附近了 要把学习率调的小 例如正常是0.1，现在要用1e-3 epoch数要小 例如 不做特别的限制的话，不管是fine-tune还是随机初始化整个网络，在足够长的时间下，网络都会达到一个特定的程度，但这个程度并非是最佳状态 泛化误差和训练误差是不一样的 在数据集不大且网络足够复杂的情况下，网络是可以记住整个数据集的 训练误差最低的时候，泛化误差不一定更好 在完全拟合自己的数据和保留在大数据集上的泛化能力之间，做一个权衡 冻结底层网络 - 限制搜索空间的另一种方法 因为神经网络有个比较层次化的学习过程 在最底层学到一些底层的特征的表示，像素底层特征，学习到的纹理是什么形状、颜色的知识 如一个圆圈，图形的边 层数越来越高的时候，多多少少会学到一些更大，更全局的东西，更加跟语义相关 最下面的层在微调的时候不动 例如第0层学习率为0，第1层为1e-8，第二层为1e-7 通常做法，固定住最下面一些层，往上面一些层学习率为1e-3，再往上是1e-1 需要固定多少层是需要调的 若目标任务和预训练模型之间差比较大的话，需要多训练一些层 差异小的话，可以固定更多层，极端情况下甚至可以只允许最后一层进行训练 在哪儿找与训练模型 - 在微调的时候怎么样找到一个与训练模型，很重要 首先有没有 例如要注重latency的话，找个训练好的MobileNet 其次是考虑在什么样的大数据集上 例如是在ImageNet上训练好的 各种各样的Hub Timm的Hub Fine-Tune应用 - 使用在大数据集预训练好的模型，Fine-Tune到自己的任务上，是过去七八年至现在，在CV方面都是一个主流方法 - 目标检测/分割----图片相似但目标不同 - 医学/卫星图像识别----任务相同但图像不同 微调加速了收敛 开始的点不是随机初始化的点，而是比较靠近目标的点 不一定提升精度 预训练的数据集和目标数据集比较像的时候，一般结果会比只在目标数据集上训练好 有时候直接在目标数据集上训练时也会得到一个相似的结果，特别是在目标数据集比较大的情况下 通常不会让精度变得更低，So why not? 总结 - 通常会在比较大的数据集上训练预训练好的模型 在新的任务上，初始化一个编码器部分的权重和预训练模型权重一样的模型，解码器权重随机初始化 微调通常来说加速收敛，有时会提升精度，但不会使得精度变差","link":"/cs329p-slides-transfer-learning/"},{"title":"LeetCode每日一题-1026.节点与其祖先之间的最大差值","text":"LeetCode 题目 LeetCode-1026.节点与其祖先之间的最大差值 给定二叉树的根节点root, 找出存在于一个节点与其任意一个直接子节点或者间接子节点之间差值的绝对值的最大值. 题目分析 为了差值的绝对值的最大化, 所有子节点的最大值和最小值, 再进行运算求最大差值. 为了找所有子节点的最大值和最小值, 可以使用后序遍历来进行统计. 下面给出的题解内使用两个map来统计子节点中的最大值和最小值. 题解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {private: void findMaxDiff(TreeNode *root, unordered_map&lt;TreeNode*, int&gt; &amp;minMap, unordered_map&lt;TreeNode*, int&gt; &amp;maxMap, int &amp;maxDiff) { if (!root) return; findMaxDiff(root -&gt; left, minMap, maxMap, maxDiff); // 递归地找左右孩子的最大差值 findMaxDiff(root -&gt; right, minMap, maxMap, maxDiff); int minVal = root -&gt; val; int maxVal = root -&gt; val; if (root -&gt; left || root -&gt; right) { // 左右孩子有一者存在时, 才进行差值的统计 minVal = INT_MAX; maxVal = INT_MIN; if (root -&gt; left) { // 统计左子树的最大值和最小值 minVal = min(minMap[root -&gt; left], minVal); maxVal = max(maxMap[root -&gt; left], maxVal); } if (root -&gt; right) { // 统计右子树的最大值和最小值 minVal = min(minMap[root -&gt; right], minVal); maxVal = max(maxMap[root -&gt; right], maxVal); } maxDiff = max({abs(root -&gt; val - minVal), abs(root -&gt; val - maxVal), maxDiff}); // 根据左右子树的最大值和最小值求最大差值 minMap[root] = min(minVal, root -&gt; val); // 标记以当前节点为根节点的二叉树中的最大值和最小值 maxMap[root] = max(maxVal, root -&gt; val); } else { // 没有子节点时, 将最大值和最小值标记为自身 minMap[root] = minVal; maxMap[root] = maxVal; } }public: int maxAncestorDiff(TreeNode* root) { unordered_map&lt;TreeNode*, int&gt; minMap; unordered_map&lt;TreeNode*, int&gt; maxMap; int maxDiff = 0; findMaxDiff(root, minMap, maxMap, maxDiff); return maxDiff; }};","link":"/leetcode-maximum-difference-between-node-and-ancestor/"},{"title":"快手8.17音视频开发凉面","text":"凉经 5min自我介绍 看到有iOS项目，问为什么用Moya，相比于NSURLSession好在哪里？ Moya封装了Alamofire，提供了一个抽象层，封装了网络层的细节，提供了更干净、更类似于Swift的API，使得封装网络请求编的更容易。 NSURLSession是iOS自带的网络库，支持多种协议，可自定义程度更高。 两者封装性的差别：NSURLSession的扩展性会更高一些。 C++ malloc 和 new的区别 new分配内存失败时，会抛出bad_alloc异常，malloc分配失败时，只会返回NULL； new不需要显式地指示所需要的空间，而malloc需要显式指明； new会触发所创建对象的构造函数，而malloc不会； new是一个运算符，可以重载，而malloc是库函数； new所返回的指针类型一定是new的对象类型的指针，而malloc返回的是void *，需要再次转换为所需的类型的指针 i++是原子性的吗？ 不是原子性，虽然C++语句只有一句，但是实际上可以理解为做了三个操作：将i移动到寄存器中，在寄存器中做运算，再将运算后的结果拷贝到原先i的位置。 如果并发有多个线程进行i++操作，会造成数据的异常； 可以使用std::atomic来解决。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;std::atomic&lt;int&gt; atomicCounter{0};int counter = 0;void atomicIncrement() { for (int i = 0; i &lt; 100000; ++i) { ++atomicCounter; }}void increment() { for (int i = 0; i &lt; 100000; ++i) { ++counter; }}int main() { std::thread atomicT1(atomicIncrement); std::thread atomicT2(atomicIncrement); atomicT1.join(); atomicT2.join(); std::thread t1(increment); std::thread t2(increment); t1.join(); t2.join(); std::cout &lt;&lt; &quot;atomic increment result: &quot; &lt;&lt; atomicCounter &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Increment result: &quot; &lt;&lt; counter &lt;&lt; std::endl; return 0;} 2023-09-06T230540 SSL的过程 客户端发送Client hello, 其中包含客户端所支持的TLS版本, 加密套件, 以及随机数Client random. 服务器返回Sever hello, 其中包含服务器的TLS整数, 服务器所选择的加密套件, 以及服务器随机数Server random. 客户端对服务器提供的证书进行验证, 验证通过后发送Client Key Exchange消息, 一中包含了使用服务器证书公钥加密的一个随机数Premaster Secret. 服务器使用证书私钥解密得到Premaster Secret 客户端和服务器都使用相同的加密套件, 根据Client Random, Server Random和Premaster Secret生成相同的密钥. 客户端和服务器都相对方发送Change Cipher Spec以及Finished消息, 表明自身已经计算好用于通信加密的密钥. 握手完毕, 开始使用加密连接进行通讯. 介绍下死锁 死锁是指一组相互竞争资源的进程推进顺序不当而导致无法每个进程都无法推进下去的局面 在这一组进程中, 每个进程都占有并保持了一定的资源, 而又请求另外一些被其他进程占有的资源 触发条件: 互斥, 占有和等待, 不可抢占, 环路等待. 死锁预防: 破坏互斥(虚拟打印机技术), 破坏占有并等待(预先请求好运行过程中所需要的所有资源), 破坏不可抢占 死锁避免: 银行家算法 介绍下C++智能指针 分为shared_ptr, unique_ptr 和 weak_ptr shared_ptr在拷贝时使用同一份引用计数, 重载拷贝构造函数使得引用计数+1, 重载赋值运算符使得赋值前原来的对象的引用计数-1, 新的对象引用计数+1, 重载析构函数使得引用计数-1并判断是否需要delete 同一个shared_ptr被多个线程读是安全的, 被多个线程写是不安全的(类比于i++的情况); 指向同一个实例的多个shared_ptr被不同的线程写是安全的. unique_ptr唯一拥有其所指的对象,离开作用域时, 对象会被销毁, 不支持普通的拷贝和赋值(但是一个将要被销毁的unique_ptr, 可以通过使用release或者reset将指针所有权转移到另一个unique_ptr上) weak_ptr的使用不会引起引用计数的变化, 主要是为了辅助shared_ptr工作, 使用前需要检查是否为空指针. 怎么样来避免菱形继承所带来的问题? 给定A为基类, B, C分别继承于A, D继承于B, C, 这种情况为菱形继承. 菱形继承会使得D中保留了两份基类A的数据, 分别存在于类B和类C当中, 会浪费空间, 且访问基类中的数据还要使用域运算符作区分. 使用虚继承来解决问题, 虚继承在声明派生类时指定继承方式, 在菱形继承中, 需要在定义类B, 类C时指明继承A的方式是虚继承. 虚基类的初始化由最后的派生类来负责初始化 shared_ptr是否是线程安全的？ 见7. C++类型转换，static_cast和dynamic_cast statoc_cast没有类型检查, 不能保证类型安全, 由派生类向基类转化是安全的, 但反方向是不安全的. 可用于基本数据类型之间的转化, 以及把任何类型的表达式转化为void类型 dynamic_cast是动态转化, 具有类型检查的功能, 互赞换后必须是类的指针, 引用或者是void*, 基类要有虚函数, 可以交叉转化; 其只能用于存在虚函数的有继承关系的类的实例之间进行强制类型转换; 指针转换失败会返回nullptr, 引用转换失败则会抛出异常. reinterpret_cast可以将整型转换为指针, 也可以把指针转化为数组, 可以在指针和引用里随意转换. const_cast, 将常量指针转化为非常量指针, 常量引用转化为非常量引用 C++怎么实现多态的？ 重载(Overload)和覆盖(Override) 重载指允许出现多个重名函数, 且这些函数的参数表不同 覆盖指子类重新定义父类的函数的做法. map与unordered_map的区别 map使用红黑树实现, key是有序的, 查找, 插入的时间复杂度为O(logn)且较为稳定 unordered_map使用哈希表实现, key是无序的, 查找, 插入的时间复杂度通常为O(1), 但是不稳定, 根据哈希函数在有些情况下可能会达到O(n)的时间复杂度. TCP拥塞控制的流程 慢启动 拥塞避免(指数增长变为线性增长) 拥塞发生 超时重传--阈值设为原速率一半, 速率从1开始慢启动 快速重传--阈值和速率都设置为原速率一半. 快速恢复 操作系统虚拟地址到物理地址的转换流程 CPU在TLB中找到虚拟地址的项, 就从该项中直接获取对应的物理地址 TLB未命中, 则查找进程的页表, 如果其对应物理页面在内存中, 则更新TLB并检测访问是否合法, 通过之后给定物理地址 TLB未命中, 且物理页面不在内存中, 则使用页面置换算法将该物理页换入内存中, 再次建立映射 在有1000+文件的一个目录里，给定一个字符串，怎么样去找到包含该字符串的那个文件 grep -nr \"text\" directory/ Git提交中，如何避免环的产生 定期将主干上的更改合并到次要分支 使用cherry-pick选择性地将更改从一个分支应用到另一个分支而不会创建合并提交. 手撕的复原IP地址，但是ACM模式，紧张了。原本之前第一次做这题的时候自己就撕出来了，现在再做反而只把代码框架撕出来，甚至编译报错。","link":"/failed-ks-interview-summary/"},{"title":"macOS 10.15 ”app已损坏，无法打开“ 解决方法","text":"问题表现 安装了网上下载来的破解软件（大写加粗的穷）后，双击发现 不！能！用！还提示你扔到垃圾桶。 因为实在莫得钱去买软件，只能去找解决方案 # 命令行处理 将下载到的App拖入应用程序后，打开终端（iTerm等都可以），输入以下命令： 1$ sudo xattr -rd com.apple.quarantine 输入完先不要按下Enter，打开finder到应用程序那里，找到你下载的破解App，将其拖入到终端内。会变成类似于下面的 1$ sudo xattr -rd com.apple.quarantine /Applications/xxx.app 其中xxx是你要用的软件的名字。这个时候按下回车，并输入当前用户的密码（输入密码的时候是看不见的，直接输就好），按下回车。 再打开就好了。","link":"/mac-catalina-damaged-app/"},{"title":"Mac手动切换显卡","text":"手动切换Mac 显卡 主力电脑是一台15年的MacBook Pro 15寸顶配，有的时候，某些程序在运行时系统会把图形卡模式自动调整为高性能，就觉得对性能有影响，想手动切换。 系统自带的切换只能选择自动和独显，所以要使用其他方法 ### 终端切换 12345678强制使用核显(集成显卡)$ sudo pmset -a GPUSwitch 0强制使用独立显卡$ sudo pmset -a GPUSwitch 1自动切换$ sudo pmset -a GPUSwitch 2查看是否切换成功$ pmset -g 使用第三方软件 12Homebrew 安装 gfxCardStatus$ brew cask install gfxCardStatus","link":"/mac-select-gpu/"},{"title":"微信小程序云开发数据库联表查找","text":"需求分析 现在有以下集合 orders集合： 12345[ {&quot;_id&quot;:4,&quot;book&quot;:&quot;novel 1&quot;,&quot;price&quot;:30,&quot;quantity&quot;:2}, {&quot;_id&quot;:5,&quot;book&quot;:&quot;science 1&quot;,&quot;price&quot;:20,&quot;quantity&quot;:1}, {&quot;_id&quot;:6}] books集合： 12345678[ {&quot;_id&quot;:&quot;book1&quot;,&quot;author&quot;:&quot;author 1&quot;,&quot;category&quot;:&quot;novel&quot;,&quot;stock&quot;:10,&quot;time&quot;:1564456048486,&quot;title&quot;:&quot;novel 1&quot;}, {&quot;_id&quot;:&quot;book3&quot;,&quot;author&quot;:&quot;author 3&quot;,&quot;category&quot;:&quot;science&quot;,&quot;stock&quot;:30,&quot;title&quot;:&quot;science 1&quot;}, {&quot;_id&quot;:&quot;book4&quot;,&quot;author&quot;:&quot;author 3&quot;,&quot;category&quot;:&quot;science&quot;,&quot;stock&quot;:40,&quot;title&quot;:&quot;science 2&quot;}, {&quot;_id&quot;:&quot;book2&quot;,&quot;author&quot;:&quot;author 2&quot;,&quot;category&quot;:&quot;novel&quot;,&quot;stock&quot;:20,&quot;title&quot;:&quot;novel 2&quot;}, {&quot;_id&quot;:&quot;book5&quot;,&quot;author&quot;:&quot;author 4&quot;,&quot;category&quot;:&quot;science&quot;,&quot;stock&quot;:50,&quot;title&quot;:null}, {&quot;_id&quot;:&quot;book6&quot;,&quot;author&quot;:&quot;author 5&quot;,&quot;category&quot;:&quot;novel&quot;,&quot;stock&quot;:&quot;60&quot;}] 要求进行联表查询，返回结果，匹配字段为orders的book字段和books的title字段 # 代码 1234567891011const db = cloud.database()db.collection('orders').aggregate() .lookup({ from: 'books', localField: 'book', foreignField: 'title', as: 'bookList', }) .end() .then(res =&gt; console.log(res)) .catch(err =&gt; console.error(err)) 得到的结果为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[ { &quot;_id&quot;: 4, &quot;book&quot;: &quot;novel 1&quot;, &quot;price&quot;: 30, &quot;quantity&quot;: 2, &quot;bookList&quot;: [ { &quot;_id&quot;: &quot;book1&quot;, &quot;title&quot;: &quot;novel 1&quot;, &quot;author&quot;: &quot;author 1&quot;, &quot;category&quot;: &quot;novel&quot;, &quot;stock&quot;: 10 } ] }, { &quot;_id&quot;: 5, &quot;book&quot;: &quot;science 1&quot;, &quot;price&quot;: 20, &quot;quantity&quot;: 1, &quot;bookList&quot;: [ { &quot;_id&quot;: &quot;book3&quot;, &quot;category&quot;: &quot;science&quot;, &quot;title&quot;: &quot;science 1&quot;, &quot;author&quot;: &quot;author 3&quot;, &quot;stock&quot;: 30 } ] }, { &quot;_id&quot;: 6, &quot;bookList&quot;: [ { &quot;_id&quot;: &quot;book5&quot;, &quot;category&quot;: &quot;science&quot;, &quot;author&quot;: &quot;author 4&quot;, &quot;stock&quot;: 50, &quot;title&quot;: null }, { &quot;_id&quot;: &quot;book6&quot;, &quot;author&quot;: &quot;author 5&quot;, &quot;stock&quot;: &quot;60&quot;, &quot;category&quot;: &quot;novel&quot; } ] }] HINT：其中localField字段和foreignField字段，其中一个可以指定为Array。 改进 上面的代码里会生成一个新的字段bookList，若要将查询结果直接并入上一级，可有： 123456789101112131415161718var db = cloud.database()var $ = db.command.aggregatedb.collection('orders').aggregate() .lookup({ from: &quot;books&quot;, localField: &quot;book&quot;, foreignField: &quot;title&quot;, as: &quot;bookList&quot; }) .replaceRoot({ newRoot: $.mergeObjects([ $.arrayElemAt(['$bookList', 0]), '$$ROOT' ]) }) .project({ bookList: 0 }) .end() .then(res =&gt; console.log(res)) .catch(err =&gt; console.error(err)) 其中replaceRoot指定的是新生成的数据有哪些字段，必须传入newRoot参数 project指定要保留哪些字段，0为不保留，1为保留 引用 微信官方文档·小程序","link":"/miniapp-lookup/"},{"title":"美团9.7后端面试","text":"岗位 应该是成都的搞文件存储 流程 自我介绍 C++怎么实现虚函数的 析构函数可以是虚函数吗?构造函数呢? C++面向对象的三大特性 我重载了一个函数, 使用基类指针调用派生类的这个函数, 实际上调用的哪个? 介绍下智能指针 weak_ptr不增加引用计数, 是为了解决什么问题? malloc和new的区别 C++内存分布 进程和线程的区别 进程和线程进行调度的时候, 谁开销大, 为什么? Linux使用什么系统调用来创建新的进程? 创建了新的进程之后, 子进程是否会共享父进程的资源? 还用过哪些系统调用? 有用过MySQL? KV存储? Linux下软链接和硬链接是什么? 有什么区别? 手撕的二叉树层序遍历, 6分钟撕完. 结束一小时后回人才库. 凉啊~","link":"/meituan-interview-23-9-7/"},{"title":"代码随想录算法训练营总结篇","text":"一刷总结 这两个月是吧代码随想录目前有的部分一刷完毕, 个人的感受是对这些算法的思想有了了解, 但要是说现在就能去跟面试官比划比划, 我觉得还差点意思. 数组总结 链表基础 链表总结 哈希基础 哈希总结 字符串总结 栈和队列基础 栈和队列总结 二叉树开始内容就多了起来: 二叉树基础 二叉树总结 回溯法基础 回溯法总结 贪心基础 动态规划基础 0-1背包基础 完全背包基础 背包问题总结 编辑距离总结 动态规划总结 下一步计划 二刷, 同样还是要写题解, 但应该不会像一刷那样写完了(有点费时间). 还有磕盐任务要做.","link":"/algorithm-train-summary/"},{"title":"剑指 Offer 47. 礼物的最大价值","text":"题目 LeetCode-链接直达 给定一个二维数组, 每一步只能向下或向右移动, 求在从二维数组的\\([0][0]\\)位移动到\\([m-1][n-1]\\)的过程中, 经过位置的值之和的最大值. 自己的想法 自己的想法 X 看了别人的想法之后自己的理解 √ 一个递推方程, 如果要保证走到最后的值最大, 则需要每一步都是最大的. \\begin{equation} dp(i, j) = \\begin{cases} grid(i, j), &amp; i = 0, j = 0 \\\\ grid(i, j) + dp(i, j - 1), &amp; i = 0, j \\neq 0 \\\\ grid(i, j) + dp(i - 1, j), &amp; i \\neq 0, j = 0 \\\\ grid(i, j) + \\max(dp(i - 1, j), dp(i, j - 1)), &amp; i \\neq 0,j \\neq 0 \\end{cases} \\end{equation} 其实就是递归地把整个二维数组中从开始到每个位置的路过值之和的最大值求出来, 是贪心还是动态规划啊. 自己再遇到这种问题的时候可以想一下有没有什么递推公式可以用来解决这个问题, 数学归纳法. 题解 根据上面的方程, 写出对应的代码还是不难的. 12345678910111213141516class Solution {public: int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n)); for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (i == 0 &amp;&amp; j == 0) dp[i][j] = grid[i][j]; else if (i == 0 &amp;&amp; j != 0) dp[i][j] = dp[i][j - 1] + grid[i][j]; else if (i != 0 &amp;&amp; j == 0) dp[i][j] = dp[i - 1][j] + grid[i][j]; else dp[i][j] = grid[i][j] + max(dp[i - 1][j], dp[i][j - 1]); } } return dp[m - 1][n - 1]; }}; 时间复杂度为\\(O(mn)\\), 空间复杂度为\\(O(mn)\\). 由于整个遍历过程是从上往下从左至右一行一行遍历的, 其实也可以在原数组上进行计算, 这样空间复杂度就只有\\(O(1)\\)了. 123456789101112131415class Solution {public: int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (i == 0 &amp;&amp; j == 0) grid[i][j] = grid[i][j]; else if (i == 0 &amp;&amp; j != 0) grid[i][j] = grid[i][j - 1] + grid[i][j]; else if (i != 0 &amp;&amp; j == 0) grid[i][j] = grid[i - 1][j] + grid[i][j]; else grid[i][j] = grid[i][j] + max(grid[i - 1][j], grid[i][j - 1]); } } return grid[m - 1][n - 1]; }};","link":"/leetcode-max-gift-sum/"},{"title":"一台学习用台式电脑的组装记录","text":"最终配置 为什么要配电脑呢 研究生期间的课题是深度学习方向的, 苦于手头没有GPU计算资源, 而现阶段autodl上租卡也是一卡难求, 一直想搞一台拿来跑深度学习的机器. 自己手头用的是M1 MacBook Pro, 正儿八经搞深度学习还是不太现实的. CPU 最开始是在学校二手群看到有出i5 12400F 配 七彩虹B660M 二手价格1300, 上电商平台搜了下, 觉得价格可以接受, 就买了下来. 我需要干的也没有什么需要高性能CPU的, 所以应该够用. 主板 只可惜作为一个年轻人, 总是有那么一点点自己的梦想, 比如RGB. 和12400F一起收来的七彩虹板子并没有ARGB或者RGB的接口, 那怎么办呢? ARGB控制器, 长这样: ARGB控制器 然后在最初版本的配置下, 实现了这样的效果: 除了显卡不配合以外, 好像...还行? 不过最后还是觉得板子有点丐, 换了微星B660M迫击炮, 事实证明这也是个错误, 想让灯光好看些, 还得是华硕), 3月10号买板子的时候, ROG的B760小吹雪刚上市, 1399, 自己当时因为价格原因还是选择了B660迫击炮. 内存 穷人, 而且自认为DDR5相较于DDR4没有可以感知到的提升, 所以就买了外号高级废料厂光威的两条32G的DDR4, 组个64G, 凑合用吧. SSD 一条21年底买的爱国者399元 1T, 还有一条致态的TiPlus5000 1T. 谢谢长江存储能让我用上这么便宜的固态, 在此ღ( ´･ᴗ･` )比心. 一波三折的显卡 先说都用了啥卡, 京东购买 镭风 3060 12G -&gt; 京东购买 蓝戟 A770 Photon 16G -&gt; 天猫耕升官方店4070Ti 追风 EX. 镭风3060 12G 最早开始是在京东上买了镭风的3060 12G, 长这个样: 就还说的过去, 关键是这货还有12G显存, 拿来跑模型应该是这个价位比较好的选择了, 当然不怕矿的话可以去买2080Ti(甚至还有魔改22G显存的版本). 就在我以为装机到此为止的时候, 我发现这台电脑开机的时候总是有比较大的概率(40%左右), 屏幕不亮, 但是电脑可以通过远程桌面连接上, 且设备管理器里没有这张显卡. 刚开始因为是显卡没插稳的原因, 就拆了机重新收拾了一下. 然而并没有彻底解决这个问题, 最后选择了京东售后, 售后的处理结果还挺让我意外, 我可以选择换货或者退货. 蓝戟 A770 16G Photon 在3060售后的10天里, 偶尔间刷到了Intel去年推得独显Arc A770和A750, 本着对3060和黄狗40系定价不当人很不满意的心态, 当京东问我怎么处理3060的时候, 我选择了退货, 下单了蓝戟的A770 16G Photon. 当然陪这台机器的目的还是为了跑PyTorch, 所以在买A770之前, 我还是做了一些资料搜索, 了解A770运行PyTorch的一些能力. 我在Reddit找了一些帖子, 大概了解到一些人已经开始在用A770做一些深度学习的工作了. 例如: Does anyone uses Intel Arc A770 GPU for machine learning? [D] 看到了一些这种说法, 介绍Intel Extension For PyTorch框架: 而且我还找到了使用A770来运行Stable Diffusion的教程, 例如: Stable Diffusion with Intel Arc GPUs Running TensorFlow* Stable Diffusion on Intel® Arc™ GPUs 甚至第二个链接指向的还是Intel的官网. 根据搜到的这些资料, 我自认为A770值得一试, 可以冲一把. 下面是一些A770开箱拍的图片: 装好之后, 机箱看起来是这样的: 看起来就也还行. 按照IPEX(Intel Extension For PyTorch)的文档配好了IPEX环境, 下面就要开始试验PyTorch训练模型方面的性能了. 刚开始觉得挺不错, 这么大显存跑模型岂不美滋滋. 直到我看见了这个报错: 当时看到这个的时候, 心态有点略微爆炸. 首先, 第一个Epoch下来, 模型的AUC还是0.5, 证明模型还是在瞎猜, 应该没有完成反向传播. 其二, 第二个Epoch直接跑不完了, Segmentation Fault. 去IPEX的Github的Issues里面搜了一下, 在这个Issue下面看到了这个: 其中这位jingxu10应该是Intel这个框架的工作人员, 这个框架下的许多Issue页面下都有此人的身影. 反正就是拿来进行推理, 像Stable Diffusion那样, 完全ok, 没问题, 但要是训练模型的话, Intel自己的人都说不推荐, 那我还是算了. 借着A770高负载下啸叫的问题, 在京东上进行了退货. 虽然但是, Intel的态度还是非常不错的, IPEX这个框架的版本更新频率, 以及人员回复Issue的速度, 都远超微软DirectML加速框架; 而且这块卡拿来打游戏(游戏越新, 体验越好), 剪视频都是很不错的选择, 只是不适合我(和深度学习), B站上有许许多多Intel发布一个新版本驱动就能将游戏帧数往上明显提升的视频. 如果为了3A游戏, 这张卡值得购买. 耕升 4070Ti 追风 EX 这张卡其实没什么好说的, 就是我不想买30系的矿, 又想用CUDA(最终还是向黄狗低下头了捏), 还想稍微省些钱的选择. 选择耕升这块卡的原因有二, 其一是有外接ARGB, 可以通过线和主板神光同步; 其二能个人送保. 没拍什么开箱照片, 只是拿手机录了一个非常简单的开箱视频(就真的只是开箱): 年轻人的第一张40系显卡 耕升4070Ti开箱-哔哩哔哩 装好的效果: 一切按照CUDA on WSL User Guide和Start Locally | PyTorch说明进行操作, 装完PyTorch就能使用CUDA加速了. 其实这张卡的选择也不是很好, 12G显存, 我自己的模型里面把预训练模型的部分的网络微调一下, 显存就爆了, 应该找一些24G显存的卡来装才对. THE END 跑分什么的就不跑了, 感觉对我没有太大意义. 以后这台电脑有变动的话再补充下.","link":"/my-desktop-computer-diy-record-2023/"},{"title":"Mac下Clion的OpenGL环境配置","text":"Mac下Clion的OpenGL环境配置 安装glfw/glew 12$ brew install glew$ brew install glfw 对工程内CMakeLists.txt进行更改： 1234567891011121314151617181920212223cmake_minimum_required(VERSION 3.14)project(XXX)set(CMAKE_CXX_STANDARD 11)# 添加头文件set(GLEW_H /usr/local/Cellar/glew/2.1.0/include/GL)set(GLFW_H /usr/local/Cellar/glfw/3.2.1/include/GLFW)include_directories(${GLEW_H} ${GLFW_H})# 添加目标链接set(GLEW_LINK /usr/local/Cellar/glew/2.1.0/lib/libGLEW.2.1.dylib)set(GLFW_LINK /usr/local/Cellar/glfw/3.2.1/lib/libglfw.3.dylib)link_libraries(${OPENGL} ${GLEW_LINK} ${GLFW_LINK})# 执行编译命令set(SOURCE_FILES main.cpp)add_executable(XXX ${SOURCE_FILES})if (APPLE) target_link_libraries(XXX &quot;-framework OpenGL&quot;) target_link_libraries(XXX &quot;-framework GLUT&quot;)endif() 将上方的XXX改为自己的工程名称即可","link":"/mac-clion-opengl/"},{"title":"腾讯云SCF云函数部署OneDrive共享盘","text":"更新 更新于2022年7月 腾讯云SCF大幅削减了免费额度，请事先查阅收费标准再决定是否使用。 前情提要 申请了Office365技术社区成员，通过后获得了一个Office 365 E3的账号，其中包含1T容量的OneDrive for business世纪互联版。物要尽其用，用这个搭一个网盘。 &gt; OneDrive for business下的文件，组织的管理员可以查看，私人文件请放OneDrive个人版 教育邮箱白嫖的1T空间需要有管理员才可以继续搭建 # 准备工作 + 自己腾讯云账户SecretID和SecretKey + SCF函数文件 点击去Github 新建云函数 点击去云函数控制台 新建一个云函数，选择自己想要的区域，新建函数，运行环境选择Php 7.2，选择空白模板，下一步 OneDrive个人版选择内地区域可能会有问题，建议选择中国香港 拉到下方高级配置，你刚才选择的区域Region官方对应列表 点击完成 上传代码文件 返回到函数列表，点击函数，选择函数代码，更改提交方法，把解压缩的代码传上去，保存 添加触发方式 在触发方式内添加触发方式，选择API网关触发方式，将启用集成响应打钩，其余默认即可 获得访问路径 配置网盘参数 访问上一步内获得的链接 填写之前获得的SecretKey和SecretID，设置密码，确认 稍等会跳转到首页，点击左上角的管理，添加Onedrive盘 选择自己对应的版本： 怎么样选择自己的版本： 在浏览器里打开OneDrive的文件目录的首页，看地址栏的域名 域名 版本 onedrive.live.com 个人版 *****.sharepoint.cn 商业世纪互联版 *****.sharepoint.com 商业国际版 这里我用的是世纪互联版，选第二个 确认后会调到授权界面，授权即可 稍等即可跳转到首页 完善体验 网盘配置 在云函数环境变量处可以添加以下值（说明来自开发者）： 变量名 说明 sitename 网站的名称，不添加会显示为‘请在环境变量添加sitename’。 admin 管理密码，不添加时不显示登录页面且无法登录。 adminloginpage 管理登录的页面不再是'?admin'，而是此设置的值。如果设置，登录按钮及页面隐藏。 public_path 使用API长链接访问时，显示网盘文件的路径，不设置时默认为根目录；不能是private_path的上级（public看到的不能比private多，要么看到的就不一样）。 private_path 使用自定义域名访问时，显示网盘文件的路径，不设置时默认为根目录。 domain_path 格式为\"a1.com:/dir/path1|b1.com:/path2\"，比private_path优先。 imgup_path 设置图床路径，不设置这个值时该目录内容会正常列文件出来，设置后只有上传界面，不显示其中文件（登录后显示）。 passfile 自定义密码文件的名字，可以是'pppppp'，也可以是'aaaa.txt'等等；密码是这个文件的内容，可以空格、可以中文；列目录时不会显示，只有知道密码才能查看或下载此文件。 自定义域名 触发方式下选择API服务名 在自定义域名下选择新建 填写域名，路径映射选择自定义，填/，环境选择发布 如果没有证书的话，可以去控制台免费申请证书 点击提交前，请先将自定义的域名用CNAME方式指向图中的公网二级域名 在管理API下，点击编辑 路径改为/ 下一步 勾选是否启用响应集成 下一步 返回类型选择HTML 完成，点击前往发布服务 点击发布 写点备注，提交 部署完成 已经可以用来访问了","link":"/scf-onedrive/"},{"title":"基于Wechaty的群学习内容推送工具","text":"Author: @GilesWong Code: @GilesWong/wechaty-xiaowang 功能 定时采集英语的每日一题，推送到群里 早晨问好，同时发送当天天气预报，每半天检查一次未来 24 小时内设定的经纬度处是否有降水。 采集网站上的新闻早报，补充时政知识 发送每日一句 图灵机器人对话 （来源于第三方的数据仅供学习之用，请经常访问这些优质网站） ## 特点 使用腾讯云云函数进行定时获取信息的操作，减少了服务器上的配置难度 使用 Node.js Express 对 Wechaty 进行了封装，后续功能可以本地写好 python 或 nodejs 云函数后，直接部署在腾讯云上，不用调整服务器 使用 pm2 进行 wechaty 运行状态的维持（后续可以考虑改为使用无服务器的环境，比如 Leancloud、Heroku 容器等，减少服务器的开支） 功能示例 项目结构 12345678910111213|-- wechaty-xiaowang |-- index.js //主程序 |-- package-lock.json |-- package.json |-- puppet-config.js //pupet参数 |-- serverchan.js //通过方糖报告错误 |-- tulingbot.js //图灵机器人 |-- cloudFunctions // 运行在腾讯云上的云函数爬虫 |-- dailyEnglishTest //英语每日一题 |-- dailySentence //英语每日一句 |-- moringNews //每日早报 |-- rainDetection //降雨提醒 |-- weatherTip //早晨问好，及天气预报 架构说明 服务器端 Express + Wechaty 开放一个 HTTP 接口用于访问，传入 HTTP 接口的内容会被发送到预先指定的群内 云函数端 定时获取信息，并通过 HTTP 调用发送给 Wechaty 机器人 使用 wechaty 的部署 填写代码中的配置，如Token，服务器地址、端口等 上传至服务器 在其目录下，获取所有用到的 NPM 包 12npm i 使用node index.js命令，启动wechaty，并扫码登录 （可选）调试好之后，可选择使用pm2等工具维持wechaty的运行 （可选）使用Nginx的反向代理功能来实现HTTPS，增强安全性 （可选）使用cloudflare的防火墙规则或者Nginx，来将访问权限限制到特定的范围，增强安全性 云函数的部署 打开 https://console.cloud.tencent.com/scf/index 注册并新建云函数 新建时选择空白函数即可,然后选择目前要增加的函数的环境，之后点击下一步 Python 3.6 Node.js 12.16 在提交方法处，选择上传文件夹 选择当前增加的函数的文件夹，上传即可 新建完成后，返回云函数主页面，点击函数服务- 触发管理 弹出的创建触发器的页面内，选择自定义触发，填入Cron表达式 Cron表达式用法见：https://cloud.tencent.com/document/product/583/9708#cron-.E8.A1.A8.E8.BE.BE.E5.BC.8F 完成 对于每日新闻的代码，其运行于Coding的定时构建计划内，详见：https://help.coding.net/docs/devops/ci/trigger.html 致谢 JUZI Bot提供的Token，使这个小项目具有可行性 Wechaty (非常优秀的项目) 腾讯云（提供了几乎免费的云函数） Coding（提供了免费使用的构建计划的主机） ```","link":"/wechaty/"}],"tags":[{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"代码随想录","slug":"代码随想录","link":"/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Transfer Learning","slug":"Transfer-Learning","link":"/tags/Transfer-Learning/"},{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"凉面","slug":"凉面","link":"/tags/%E5%87%89%E9%9D%A2/"},{"name":"DIY","slug":"DIY","link":"/tags/DIY/"},{"name":"Intel ARC","slug":"Intel-ARC","link":"/tags/Intel-ARC/"},{"name":"PyTorch","slug":"PyTorch","link":"/tags/PyTorch/"},{"name":"电脑","slug":"电脑","link":"/tags/%E7%94%B5%E8%84%91/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"Clion","slug":"Clion","link":"/tags/Clion/"},{"name":"Serverless","slug":"Serverless","link":"/tags/Serverless/"},{"name":"Onedrive","slug":"Onedrive","link":"/tags/Onedrive/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"}],"categories":[],"pages":[{"title":"Giles&#39; Resume","text":"个人信息 性 别：男 年 龄：24 手 机：Redacted For Privacy 邮 箱：xtenggie@gmail.com 专 业：计算机技术 教育经历 西安交通大学 2021.9~2024.6 计算机技术-硕士研究生 杭州电子科技大学 2017.9~2021.6 计算机科学与技术-本科 专业技能 熟悉C++，熟练使用C++指针应用及指针管理， C++的封装继承多态，STL常用容器 了解Swift、Python、Java、JavaScript，有过开发经验，能完成开发任务。 熟悉常用的数据结构（链表、栈、队列、二叉树）和排序等算法的基本原理。 熟悉Linux的开发环境，熟悉常用的登录、操作命令与方法，习惯使用Unix命令行，了解bash, zsh, Systemd, WSL, Crontab，公私钥登录等。 熟悉OSI五层网络模型，熟悉TCP/IP，UDP，HTTP/HTTPS，DNS等常见网络协议，熟悉TCP三次握手、四次挥手、流量控制、拥塞控制等手段。 熟悉pip、npm、apt、yum、brew、winget等常见包管理器的使用。 熟悉操作系统的进程通信，了解操作系统的死锁、内存管理、调度算法等知识 熟悉VSCode、git等工具的使用。 项目经历 杭州公交旅游客运有限公司 -《杭州公交旅游》微信小程序 - 开发者 - 2020.3 - 2020.4 北京重度科技有限公司 -《摩链溯源》App iOS 版本 – 开发者 - 2019.3 - 2019.5 校内社团 - 《HduIn在杭电》App iOS版本 - 开发者 - 2017.10 - 2019.6 View in App Store 个人项目 - Wechaty-Xiaowang - 独立开发 - 2020.2 - 2020.4 自动定时抓取信息并使用微信机器人推送给自己 View on GitHub 校园经历 西安交通大学电信学部2021-2022学年优秀研究生 2022.11 西安交通大学(Redacted)支部书记 2021.9-(Redacted) 杭州电子科技大学2021届优秀本科毕业生 2021.6 瑞典Kristianstad University交换生 2018.9-2019.1 校内社团技术部副总监 2018.6-2019.6 英语等级 CET4-600分，CET6-552分 常用Google、GitHub、Stack Overflow等英文网站来检索资料 有阅读英文新闻的习惯","link":"/about/index.html"}]}