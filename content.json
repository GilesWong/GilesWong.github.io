{"posts":[{"title":"2021级西安交通大学计算机专硕上岸经验","text":"个人情况 计算机科班, 双非, 无科研经历, 做过两个小的外包项目, 绩点4.1, 20%左右 四六级大一过的, 四级600分, 六级558分 初试成绩:政治75, 英语二86, 数学二126, 专业课912 119, 总分 406分, 初试排名目测是25左右 最后总排名15~20. 去年在王道论坛看了20各位学长的经验贴, 得到了许多帮助. 现在把自己的一些心得写一下, 希望能帮助到备考的你. 仅供参考. 初试准备 正式开始准备基本上是从6月初开始的,去学校提供的考研教室,每天差不多7点起,7-9月份晚上到8点,之后就去锻炼. 10月份起就6点半起,到9点结束学习. 相比着之前发帖的大佬,我觉得我的学习效率可能远不如他. 考研有一个复习的法则: 多次, 全面. 政治 20年的特殊形势, 在政治卷子上的影响就体现在各个老师押题押的都很准(因为不得不考这些),导致最后大家的分数普遍较高.同时也就是说, 大家的政治主要靠的还是考前的一个月突击, 在此之前政治不要开始过早过晚, 月初就可. 我自己用的是徐涛老师的核心考案, 听徐涛老师的强化班的课(徐涛老师的课可能是那段时间快乐的源泉之一),另外买了肖秀荣老师的1000题,听一章课,做一章选择题,大题不用做.虽然题和课不是同一个老师的,但是在章节分布上还是差不多的,这样搭配没问题的. (私以为的)重点来了: 1000题上做过的选择题,要定时进行复习(主要是重做). 我推荐使用一些辅助记忆的方法来完成,比如说艾宾浩斯遗忘曲线等. 我使用的是iPad上面的软件(开发者把广告费结一下谢谢), 卡片只需要添加哪一页哪一题即可,然后按照查阅计划重复做. 11月份等肖8出来之后, 开始做肖8的选择题, 做法和1000题一样,尽量把所有选择题都搞懂. 大题的话B站找带背视频(我看的空卡的). 肖4出来之后,选择题还是全部搞懂,大题试着自己做一下,同样也是找带背视频,背下来. 省流助手: - 9月初开始就行 - 徐涛 - 徐涛强化班 - 肖秀荣1000题 - 1000题的错题 - 11月份之后肖8 肖4 - 宝藏UP主的带背视频 英语 英语是门语言,想要成绩好的话,还是要多背单词,词汇量上去了题目完全就不是问题. 我从19年10月份开始用背单词软件(墨墨背单词, 其他软件也可以)背单词, 把考研要求的词汇全背了. 背单词这个过程要一直持续到初试考完英语那天,一定要坚持下去. 7月份开始,做英语往年真题. 英语二可以先做英语一的题目, 然后再做英语二的. 我用的是黄皮书. 阅读理解每道错题都要找出为什么错,错在哪里. 作文在考前40天左右,开始背作文书,我背的是王江涛的作文预测,里面的20篇要背的非常熟.基本上作文就没什么问题了. 要点: - 背单词直到初试英语结束 - 7月份开始做真题 - 背作文书 数学 21的数学算是...不要太简单, 我数学底子比较差, 都可以考到126分. 按照大小年的规律, 22的同学们要小心了, 22的数学大概率会非常难. 而且数学非常能拉分, 所以数学一定要抓好.我数学从5月份开始准备(说实话, 晚了), 高数跟的是武忠祥老师, 线代跟的是李永乐老师. 材料全是他们的配套材料. 基础部分建议就6月份及之前, 开始学的话就先把高数基础班过一遍, 再过线代, 过的时候看一节课, 做一节课对应的习题, 把错误的习题拿红笔标注一下, 方便重复去做. 做完一节课之后可以再反过头来, 把这节的理论知识再过一遍, 重点放在自己不熟练的地方. 强化阶段建议7-9月. 这段时间非常关键, 是数学提分的重要阶段. 武忠祥老师的高数强化资料和李永乐老师的线代强化资料上面的题目都是非常好的. 把这些题能够吃透, 130应该是没问题的, 不要怕错题, 发现了错题, 解决一个问题, 才能进步. 10-11月份, 开始做真题, 各家的真题都可以买, 没什么特别大的区别, 做真题的话把最近15年的做题吃透就可以了, 抽个时间可以试着给自己来一次模拟考试. 11月底就开始刷模拟卷, 我用的模拟卷是李林老师的6套卷和4套卷, 题目难度适中, 比较适合数学二的考试来做. 专业课 21专业课课程代码不变, 初试科目比20少了一门操作系统(不要以为初试科目少就比其他好考, 西交复试有笔试). 数据结构这门课, 没什么好说的, 王道吃透做透就行了. 试卷上数据结构总共有选择题, 大题, 以及代码题三种. 选择题是5道, 大题5道, 代码题1道. 这些题目在王道上都有比较接近或类似的题目. 参考书籍的散列表部分可以看一下, 有王道上面没有的知识点, 前些年考过. 计算机组成原理这门课是比较不好做的. 一定要买王换招老师的那本书, 然后反复啃, 反复看, 把课后习题搞懂就问题不大. 试卷上计算机组成原理的题目有填空题, 简答题, 计算题. 简答题的占比还是很大的, 这点务必要注意. 课后习题里面的简答题和书上的一些重要的知识点, 都有可能出简答题. 复试 复试阶段有笔试, 机试, 面试(面试包括英语面试, 专业提问以及老师们对你的自由问答). 现阶段先准备初试即可, 初试完之后觉得可以的话, 再准备复试. 笔试可选 操作系统, 计算机网络, 离散数学, 数据库, 编译原理, 软件工程. 六选二. 难度也是不小的. 同样还是喜欢考简答题, 还有名词解释的题目(给你英文单词, 让你解释这是什么东西, 回答时中英文都可). 最低60分. 机试可用C, C++, Java. 五道题目, 总体来说还是难度不大的. 考一些基本操作. 最低分50分. 面试部分基本上就是自我介绍, 文献翻译, 专业提问, 老师自由提问这四个部分.","link":"/2021/04/09/2021-xjtu-postgraduate-admission-experience/"},{"title":"代码随想录算法训练营第3天 | 链表基础，203.移除链表元素，707.设计链表，206.反转链表","text":"链表理论 链表，顾名思义，是链状的数据的集合。在计算机编程语言当中，链表通常的表现形式为： 单链表，图源自代码随想录 根据不同的节点构成，链表可以被分为： 单链表 如上面的图所示，即为单链表，“单”指的是单向，即一个节点除了所存储的数据外，只保留其下一个节点的指针。 双链表 在单链表的基础上，在每个节点上增加一个指向上一个节点的指针，将根据这个节点能查询到的节点扩展为前后节点。 双向链表 循环链表 在双链表或者单链表的基础上，使链表首尾相连，就形成了一个循环链表。 循环链表 链表的存储方式与数组不同，数组通常是连续存储的，通过索引和数组起始位置即可以\\(O(1)\\)的时间访问到指定的数据，但链表中的节点不是连续存储的，需要从链首指针开始，依次查询到指定位置才可以，需要花费\\(O(n)\\)的时间。 链表存储示意图 根据链表的定义，一个常见的单链表的节点可以用C++表示为： struct Node* { int data; // 该节点所存储的数据 Node* next; // 指向下一个节点的指针 Node(int x) : data(x), next(nullptr) {} // 节点的构造函数，可选 }; 一个常见的双链表节点可以用C++表示为： struct Node* { int data; // 该节点所存储的数据 Node* prev; // 指向前一个节点的指针 Node* next; // 指向下一个节点的指针 Node(int x) : data(x), prev(nullptr), next(nullptr) {} // 节点的构造函数，可选 }; 203.移除链表元素 代码随想录链接 题目 LeetCode-203 删除链表中等于给定值的所有节点。 自己的想法 自己首先想到的还是使用链表原有的头和尾来完成，对头进行单独的判断处理，如果头携带值就等于给定值，则不断地把头设置为下一个节点，当头所携带的值不是给定值之后，再对链表后面进行处理，自己写的版本即为解法一。 解法一 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* cur = NULL; // 为了保存当前使用的节点而设立的一个指针 while (head != NULL &amp;&amp; head -&gt; val == val) { // 如果头指针指向的节点携带的值等于给定值 cur = head; // 保存头结点的地址 head = head -&gt; next; // 将头指向下一个节点，使下一个节点成为头结点，这一步之后原来的头结点已经被剥离链表 delete cur; // 释放掉原来头结点的空间 } cur = head; // 从头结点开始遍历，此时头结点的值不等于给定值，所以我们下面只需要看cur -&gt; next的值是否等于给定值 while (cur != NULL) { // 当遍历节点不为空时 if (cur -&gt; next != NULL &amp;&amp; cur -&gt; next -&gt; val == val) { // 如果当前节点存在下一个节点且下一个节点的数据等于给定值 ListNode* toDel = cur -&gt; next; // 标记需要被删除的节点 cur -&gt; next = toDel -&gt; next; // 更新当前节点的next指针，将其指向被删除节点的下一个节点，此步之后被删除节点已被剥离链表 delete toDel; // 释放被删除节点的空间 } else { // 如果当前节点的下一个节点不存在或者其值不等于给定值 cur = cur -&gt; next; // 则移动节点 } } return head; // 返回链表表首指针 } }; 由于遍历了整个链表，故时间复杂度为\\(O(n)\\)，使用了常数个额外变量，空间复杂度为\\(O(1)\\)。 解法二 下面这种方法的思想和上面是一样的，只不过使用了一个假表首来使得代码实现起来比较简单。之前学过但是自己想的时候就是想不起来这种做法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); dummyHead -&gt; next = head; ListNode* cur = dummyHead; while (cur -&gt; next != NULL) { if (cur -&gt; next -&gt; val == val) { ListNode* toDel = cur -&gt; next; cur -&gt; next = toDel -&gt; next; delete toDel; } else { cur = cur -&gt; next; } } head = dummyHead -&gt; next; delete dummyHead; return head; } }; 由于遍历了整个链表，故时间复杂度为\\(O(n)\\)，使用了常数个额外变量，空间复杂度为\\(O(1)\\)。 707.设计链表 代码随想录链接 题目 Leetcode-707 就是实现链表的增删查功能，改太简单了。上过数据结构的同学应该能非常熟练地完成才对。 自己的思考 尽量地多使用伪表首来实现功能，让代码的逻辑看起来更清晰一些。 解法 class MyLinkedList { public: struct Node { int val; Node* next; Node(int val): val(val), next(nullptr){} }; MyLinkedList() { _dummyHead = new Node(0); // 内部实现一个假表首 _size = 0; // 内部的变量，用于存储当前链表的大小 } int get(int index) { if (index &gt;= _size || index &lt; 0) return -1; // 在index不正确时，按照题目要求返回-1 Node* cur = _dummyHead -&gt; next; // 声明一个用于遍历链表的节点 while (index--) cur = cur-&gt;next; // 根据index定位到节点 return cur -&gt; val; // 返回节点值 } void addAtHead(int val) { Node* toAdd = new Node(val); // 实例化一个新的节点来存储值 toAdd -&gt; next = _dummyHead -&gt; next; // 将新的节点的next指针指向当前的（真）头指针，让头节点成为其下一个节点 _dummyHead -&gt; next = toAdd; // 将假表首的next指针指向新的节点，代表新节点成为了（真）头指针 _size++; // 别忘了更新链表的大小 } void addAtTail(int val) { Node* cur = _dummyHead; // 依次遍历到链表的末尾，实例化一个新的节点，并将原末尾节点的next指针指向新的节点 while (cur -&gt; next != NULL) cur = cur -&gt; next; Node* toAdd = new Node(val); cur -&gt; next = toAdd; _size++; } void addAtIndex(int index, int val) { // 类似于get函数的做法，先定位到index指向的节点，然后根据题意将节点插入在该节点之前（修改前节点的next指针和新节点的next指针） if (index &gt; _size) return; if (index &lt; 0) index = 0; Node* toAdd = new Node(val); Node* cur = _dummyHead; while (index--) cur = cur -&gt; next; toAdd -&gt; next = cur -&gt; next; cur -&gt; next = toAdd; _size++; } void deleteAtIndex(int index) { // 根据index定位到节点，通过将前一个节点的next指针修改为要删除节点的下一个节点的地址来完成删除 if (index &gt;= _size || index &lt; 0 ) return; Node* cur = _dummyHead; while (index--) cur = cur -&gt; next; Node* todel = cur -&gt; next; cur -&gt; next = todel -&gt; next; delete todel; // 释放节点空间 _size--; } private: int _size; Node* _dummyHead; }; 206.反转链表 代码随想录链接 题目 LeetCode-206 将一个给定的单链表的节点顺序依次翻转过来。 自己的思考 首先想到的是生成一个新的链表，依次分别将原链表中的数据不断在新链表的头部进行添加。但考虑到这样会造成额外的空间开销，就考虑使用链表的现有节点进行逆转。 解法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if (head == NULL) return NULL; // 处理空表的特殊情况 if (head -&gt; next == NULL) return head; // 处理只有一个节点的特殊情况 ListNode* dummyHead = new ListNode(0); // 使用假表首 ListNode* cur = head; // 使用一个当前节点的指针 while (cur != NULL) { // 循环条件 ListNode* tmp = cur; // 使用一个临时指针来标记当前节点A cur = cur -&gt; next; // 将当前节点向后移动，标记原链表中A的下一个节点 tmp -&gt; next = dummyHead -&gt; next; // 将A的next指针指向假表首的下一个节点 dummyHead -&gt; next = tmp; // 使A成为新的表首 } return dummyHead -&gt; next; // 真表首是假表首的next指针所指向的节点 } }; 遍历了链表，时间复杂度为\\(O(n)\\)；由于没有产生新的链表，空间复杂度为\\(O(1)\\)。","link":"/2023/02/17/algorithm-train-day3/"},{"title":"代码随想录算法训练营第4天 | 24. 两两交换链表中的节点， 19.删除链表的倒数第N个节点，面试题 02.07. 链表相交，142.环形链表II，链表总结","text":"24.两两交换链表中的节点 代码随想录链接 题目 LeetCode-24 给定一个链表，将奇数位与相邻右侧偶数位的节点进行翻转。 自己的想法 使用假表头，遍历时使用一个cur指针指向在需要交换的一对节点的前面一个节点，然后对这一对节点的位置进行交换。 解法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0, head); // 一个假表头，并使用构造函数将next指向head节点 ListNode* cur = dummyHead; // cur指针用于遍历链表 while(cur != NULL &amp;&amp; cur -&gt; next != NULL) { // 如果cur指针为空，或者cur节点后没有节点的话，就跳出循环 if (cur -&gt; next -&gt; next == NULL) break; // 如果cur指针指向的节点没有一对节点的话，结束 ListNode* first = cur -&gt; next; // 取cur指向的节点后的第一个节点，即奇数位节点 ListNode* second = first -&gt; next; // 取要交换的偶数位节点 ListNode* third = second -&gt; next; // 取偶数位节点后的节点 cur -&gt; next = second; // 将偶数位节点向前置，置于奇数位节点之前 second -&gt; next = first; // 将奇数位节点置于偶数位节点之后 first -&gt; next = third; // 将原来偶数位节点之后的节点置于奇数位节点之后 cur = first; // 移动cur指针 } return dummyHead -&gt; next; // 返回真表头 } }; 对链表进行遍历，时间复杂度为\\(O(n)\\)；使用了常数个额外变量，空间复杂度为\\(O(1)\\)。 19.删除链表中的倒数第N个节点 代码随想录链接 题目 LeetCode-19 给定一个单链表，删除倒数第n个节点。 自己的想法 双指针么，根据给定的n，使快指针先走对应的\\((n - 1)\\)步, 然后快慢指针再一起移动，当慢指针移动到末尾节点时，慢指针指向的就是要删除的节点。 为什么是\\((n - 1)\\)步呢，因为这里的想法是使得fast指向最后一个节点时停止，而不是fast为NULL时停止，在这种条件下，fast和slow指针之间的步数差距应该是\\((n - 1)\\)步，举个例子，如果要删除倒数第2个节点，当fast指向末尾节点时，slow指向的是fast前的一个节点，此时fast和slow之间的步数差距不是2，而是1。 为了能在单链表中正确删除给定位置的节点，还可以让fast在寻找末尾的时候少走一步，这样fast和slow指针一起移动结束之时，slow指针指向的是要被删除的节点之前的节点，便于进行链表操作。 解法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0, head); // 利用构造函数声明一个假表头并让其next指针指向head节点 ListNode* slow = dummyHead, *fast = dummyHead; // 快慢指针 n--; // 计算步数差 while (n-- &amp;&amp; fast != NULL) fast = fast -&gt; next; // 让fast指针先走 while (fast -&gt; next != NULL &amp;&amp; fast -&gt; next -&gt; next != NULL) { // 当fast指针在倒数第二个节点的时候就停下来，这样slow就在要删除的节点的上一个节点停下来了 fast = fast -&gt; next; // slow和fast指针同时前进 slow = slow -&gt; next; } ListNode* toDel = slow -&gt; next; // 根据上面的思路，此时slow节点的next指针指向的就是要删除的节点，在此标注 slow -&gt; next = toDel -&gt; next; // 将slow节点的next指针指向要删除的节点的下一个节点，将要删除的节点剥离链表 delete toDel; // 释放删除的节点的内存空间 return dummyHead -&gt; next; // 返回真表头 } }; 上面的这个代码实现和代码随想录里的C++代码实现有些许的不同，主要区别是在如何处理fast指针的位置，使得slow指针能够停留在要删除的节点的上一个节点处。代码随想录里的做法循环的跳出条件是，fast为空时，slow指针要指向被删除节点的上一个节点，所以fast指针不仅要比slow指针多走n步，甚至还要再多1步；而上面的实现中，fast指针最终停在了末尾节点的上一个节点。作用是一样的。 上面的实现中，时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)。 链表相交 代码随想录链接 题目 LeetCode-面试题02.07 给定两个链表，要求找到两个链表重合部分的起始节点。王道考研资料数据结构书上的题。 自己的想法 先通过遍历两个链表，获得两个链表分别的长度，再让长链表的遍历指针先走等于长度差的步数，接着让长短链表的遍历指针同时移动，当这两个指针指向同一个节点时，就找到了重合相交部分的起始节点。 解法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *dummyA = headA, *dummyB = headB; // 假表头 ListNode *curA = dummyA, *curB = dummyB; // 用来计算长度的遍历指针 int lengthA = 0, lengthB = 0; // 长度的变量 while (curA != NULL &amp;&amp; curA -&gt; next != NULL) { // 查A的长度 curA = curA -&gt; next; lengthA++; } while (curB != NULL &amp;&amp; curB -&gt; next != NULL) { // 查B的长度 curB = curB -&gt; next; lengthB++; } ListNode *curLongerList = lengthA &gt;= lengthB ? dummyA : dummyB; // 根据长度对比，分别确定长链表和锻炼表 ListNode *curShorterList = lengthA &lt; lengthB ? dummyA : dummyB; int steps = lengthA &gt;= lengthB ? (lengthA - lengthB) : (lengthB - lengthA); // 计算步数差 while (steps--) curLongerList = curLongerList -&gt; next; // 长链表先走 while (curLongerList &amp;&amp; curShorterList) { // 长短链表遍历指针同时移动 if (curLongerList == curShorterList) return curLongerList; // 当两条链表的遍历指针指向同一个节点时，返回该节点指针 curLongerList = curLongerList -&gt; next; // 否则，两个指针继续移动 curShorterList = curShorterList -&gt; next; } return NULL; // 如果一直没有指向同一个节点，证明两链表无相交部分 } }; 和代码随想录上的C++实现也还是有些许的差别，主要是在确定长短链表那里。 上面的实现遍历了两次链表，时间复杂度为\\(O(2 * n) = O(n)\\)，使用了常数个变量，空间复杂度为\\(O(1)\\)。 142.环形链表II 代码随想录链接 题目 LeetCode-142 给定一个链表，返回链表内环形结构开始的节点。若无环，则返回 NULL 。 这道题目不要太熟悉啊，也是王道考研资料的数据结构书上面的题，可能是链表部分练习题的最后一道大题来着。并不耽误我这次一开始自己没做出来。 自己的想法 双指针法，快指针一次走两步，慢指针一次走一步。当快慢指针相遇时，证明有环状结构存在。此时，快指针的步数是慢指针步数的两倍。 示意图，图源代码随想录 设链表入环前的长度为\\(x\\)，链表环的入口到快慢指针相遇的地方长度为\\(y\\)，相遇之处从沿快慢指针前进方向距环的入口的长度为\\(z\\)，可得以下公式： \\begin{equation} 2 * (x + y) = x + n * (x + y) + z \\end{equation} 其中，\\(n\\)为快指针进入环结构之后，完整走完了几次环结构。 根据上面的式子，可得： \\begin{equation} x = (n - 1) * (y + z) + z \\end{equation} \\((y + z)\\)等于一个环结构的长度，我们假设\\(n = 1\\)，即快指针完整走完了一次环结构后才与慢指针相遇，可得： \\begin{equation} x = z \\end{equation} 此时若新设立一个指针，从链表表头开始，与慢指针同时一步一步前进，则当慢指针走过\\(z\\)步，新指针走过\\(x\\)步时，慢指针和新指针将在环结构入口处相遇。 若\\(n &gt; 1\\)，同样在链表表头设立一个新指针，此时新指针与慢指针的距离为\\((x + y)\\)。由上面的式子可得： \\begin{equation} x + y = (n - 1) * (y + z) + z + y = n * (y + z) \\end{equation} 即此时新指针与慢指针的差距为环形结构的长度的\\(n\\)倍，在新指针与慢指针同时一步一步前进的条件下，两者最终还是会在环装结构入口处相遇。 解法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *fast = head, *slow = head; while (fast != NULL &amp;&amp; fast -&gt; next != NULL) { slow = slow -&gt; next; fast = fast -&gt; next -&gt; next; if (slow == fast) break; } if (fast == NULL || fast -&gt; next == NULL) return NULL; ListNode *prob = head; while (prob != slow) { prob = prob -&gt; next; slow = slow -&gt; next; } return prob; } }; 不知道怎么说这个时间复杂度为好。。。空间复杂度为\\(O(1)\\)。 链表总结 两天干完链表。感觉链表的内容确实不算那种非常难的知识。最起码给我这个计算机科班的人感觉像是在复习。或这就是为什么卡哥给算法训练营中数组和链表都只安排了两天吧。 链表基础 链表的种类分为： 单链表 双链表 循环链表 链表的存储方式：分散存储，依靠相邻节点之间的指针保持联系。 常见题目 虚拟头节点 虚拟头结点主要使用在单链表遍历过程中需要使用前一个节点才能进行操作时。不使用虚拟头结点也能做，就是要单独处理头结点的情况；而使用虚拟头结点，能够在后续的代码中简化实现。 例题： 代码随想录--LeetCode 203.移除链表元素 链表增删改查 既然是个数据结构嘛，免不了要进行增删（改）查，为什么把改单独括起来呢，因为改的前一步往往是要查。 这种题目考的是链表的一些基础操作，虽然看起来简单，但是非常重要，而且经常会在小地方出错而导致代码不能AC。 例题： 代码随想录--LeetCode 707.设计链表 反转链表 将链表的本末倒置。考察对于链表操作的熟练程度，方法主要有递归法和迭代法。 例题： 代码随想录--LeetCode 206.反转链表 删除倒数第N个节点 双指针法。理清快慢指针之间的关系即可。 例题： 代码随想录--LeetCode 19.删除链表的倒数第N个节点 链表相交 找清楚链表相同的部分，将不同的部分予以对齐。 例题： 代码随想录--LeetCode 面试题 02.07 链表相交 环形链表 这种题目主要是数学公式的推导，实现并非难点。 例题： 代码随想录--LeetCode 142.环形链表II","link":"/2023/02/18/algorithm-train-day4/"},{"title":"11.1 迁移学习【斯坦福21秋季：实用机器学习中文版】","text":"本节课程课件： 课件 自己做的思维导图： 导图 迁移学习的出发点 - 在一个任务上学习到的知识，可以在另外一个地方用到 因为训练要花钱，还要搞数据集 途径 训练好的模型做成特征抽取的模块，得到特征干别的事情，比如作为另外一个模型的输入 在相关的任务上训练一个模型，在另外一个任务上直接用，例如GPT系列 在训练好的模型上，针对新的任务进行微调（本节内容） 相关领域 半监督学习 极端情况下，新的任务，不给标记；或者只给几张有标记 多任务学习，每一个任务都有自己的数据但不是很够，但任务之间又有相关性 转移知识 - 有很多大规模的标好的数据集，尤其是图片分类任务上（因为标记很容易） 计算机视觉的迁移学习里面，存在很多效果比较好的模型，希望把这些模型的知识拓展到自己的任务上去 刚开始进行任务的时候可能不会投入太多，看能不能利用别人在标记好的、比自己的数据集大10倍，100倍的数据集上面学到的一些东西迁移过来，试试效果 预训练模型 - 用的最多的迁移学习的方法 一般来说，一个神经网络大概分为两块 编码器 可以认为是特征提取器 将像素转化为在语义空间里面线性可分的一些特征（浅表示） 解码器 可能就是个线性层 把编码器的输出映射为最终结果，做决策 例如 给个猫的图片 可以认为除了最后一层之外的，都是编码器 最后一层把语义特征（如1024的特征向量），转化为语义空间内的表示 也可以认为最后几层都是解码器，剩下的是编码器 预训练模型 在比较大的数据集上训练好的一个模型 训练的数据集大，可以认为其有一定的泛化能力 泛化能力指，放到别的任务或者数据集上，多多少少也是能帮点忙 虽然目标任务可能不会对猫感兴趣，但是编码器部分多多少少学会了点怎么样去处理像素的信息 在ImageNet上训练的模型，能对其他任务的图片做特征提取，总比从随机开始好 Fine-Tune技巧 - 通常认为，在深度学习中微调能够带来最好的效果 在新的任务上面，构建一个新的模型，其架构要与预训练模型一样 如一个在ImageNet上训练好的ResNet 50模型 在新的任务上面，也要用一个ResNet 50模型（可以先找找在当前任务的特定架构上是不是有比较好的预训练模型） 初始化模型 新模型的特征提取器（编码器）的权重直接从预训练模型得到 解码器的权重随机初始化 不同任务的语义空间不同 例如图中右侧的例子 在限制搜索空间，进行训练 因为之前效果已经比较好了，已经在最优解附近了 要把学习率调的小 例如正常是0.1，现在要用1e-3 epoch数要小 例如 不做特别的限制的话，不管是fine-tune还是随机初始化整个网络，在足够长的时间下，网络都会达到一个特定的程度，但这个程度并非是最佳状态 泛化误差和训练误差是不一样的 在数据集不大且网络足够复杂的情况下，网络是可以记住整个数据集的 训练误差最低的时候，泛化误差不一定更好 在完全拟合自己的数据和保留在大数据集上的泛化能力之间，做一个权衡 冻结底层网络 - 限制搜索空间的另一种方法 因为神经网络有个比较层次化的学习过程 在最底层学到一些底层的特征的表示，像素底层特征，学习到的纹理是什么形状、颜色的知识 如一个圆圈，图形的边 层数越来越高的时候，多多少少会学到一些更大，更全局的东西，更加跟语义相关 最下面的层在微调的时候不动 例如第0层学习率为0，第1层为1e-8，第二层为1e-7 通常做法，固定住最下面一些层，往上面一些层学习率为1e-3，再往上是1e-1 需要固定多少层是需要调的 若目标任务和预训练模型之间差比较大的话，需要多训练一些层 差异小的话，可以固定更多层，极端情况下甚至可以只允许最后一层进行训练 在哪儿找与训练模型 - 在微调的时候怎么样找到一个与训练模型，很重要 首先有没有 例如要注重latency的话，找个训练好的MobileNet 其次是考虑在什么样的大数据集上 例如是在ImageNet上训练好的 各种各样的Hub Timm的Hub Fine-Tune应用 - 使用在大数据集预训练好的模型，Fine-Tune到自己的任务上，是过去七八年至现在，在CV方面都是一个主流方法 - 目标检测/分割----图片相似但目标不同 - 医学/卫星图像识别----任务相同但图像不同 微调加速了收敛 开始的点不是随机初始化的点，而是比较靠近目标的点 不一定提升精度 预训练的数据集和目标数据集比较像的时候，一般结果会比只在目标数据集上训练好 有时候直接在目标数据集上训练时也会得到一个相似的结果，特别是在目标数据集比较大的情况下 通常不会让精度变得更低，So why not? 总结 - 通常会在比较大的数据集上训练预训练好的模型 在新的任务上，初始化一个编码器部分的权重和预训练模型权重一样的模型，解码器权重随机初始化 微调通常来说加速收敛，有时会提升精度，但不会使得精度变差","link":"/2022/07/23/cs329p-slides-transfer-learning/"},{"title":"代码随想录算法训练营第6天 | 242.有效的字母异位词，349.两个数组的交集，202.快乐数，1.两数之和","text":"没第5天？因为第5天是周日，放个假。 哈希表理论基础 什么是哈希表 哈希表就是根据数据的关键码来对数据进行直接访问的数据结构。例如数组其实就是一个哈希表，可以根据数据的索引来直接访问对应位置的数据。 哈希表主要用来解决快速判断一个元素是否出现在一个集合中。这里的快速判断是指要通过\\(O(1)\\)的时间复杂度来判断，而并非像遍历数组那样的\\(O(n)\\)的时间复杂度。 哈希函数 通过一定的计算方法，将要存储的数据转化出来对应的哈希表上的索引的函数，为哈希函数。 例如，将学生的姓名通过哈希函数计算出数值，再将该学生的姓名存放在哈希表上的对应位置。 如果哈希函数的设计不足以完全达到对不同的数据产生一定产生不同的哈希值（例如哈希函数为 x % 10时，数据11和数据21的哈希值都是1），就会发生哈希碰撞。 哈希碰撞 在下面这个图中，两个不同的数据，通过哈希函数计算出来的哈希值是相同的。 解决哈希碰撞主要有两种方法： 拉链法 哈希表表内实际上存储的是一个一个（警撅）链表的表头指针，将发生哈希碰撞的数据按照插入的先后顺序，存放在对应位置的链表上。如图所示。 线性探测法 该方法的思想是，在遭遇到碰撞时，从哈希值所指的位置开始，线性向后依次探测出一个空位置，并将数据存放至该空位置。 但是单纯的线性探测，会使得哈希值相同的数据聚集在同一个区域，此时一个改进的方法就是将“依次探测空位置”变为“按照一定的计算方法向后探测位置”，如将向后探测位置的步数从每次加1改为向后探测\\(1^2, 2^2, ...\\)。 再哈希 准备多个哈希函数，在出现哈希碰撞时，使用下一个哈希函数进行计算，直至哈希函数不再冲突。 其中\\(RH_i\\)为不同的哈希函数。 常见的三种哈希结构 数组 set--集合 map--映射 数组作为哈希结构在上文中有提到。 set在C++主要有下面三种数据结构，将代码随想录的表格抄过来，如下表所示： 数据结构 底层实现 有序 可以重复 可以更改数值 查询效率 增删效率 std::set 红黑树 Y N N \\(O(logn)\\) \\(O(logn)\\) std::multiset 红黑树 Y Y N \\(O(logn)\\) \\(O(logn)\\) std::unordered_set 哈希表 N N N \\(O(1)\\) \\(O(1)\\) 红黑树是一种平衡二叉搜索树，所以key是有序的，但key不能修改，只能对数据进行删除和增加。 C++中，集合的调用形式为： #include &lt;set&gt; // ... std::unordered_set&lt;DATA_TYPE&gt; set; // 声明一个集合 set.insert(DATA); // 插入一个数据 auto iter = set.find(DATA); // 判断一个集合是否包含一个数据 if (iter != set.end()) { // 如果包含一个数据，则进行一些处理 // do things } 映射，顾名思义，就是将一个值映射到另外一个值上面，形成一定的对应关系。 map在C++中主要有以下三种数据结构，将代码随想录的表格抄过来，如下表所示： 数据结构 底层实现 有序 可以重复 可以更改数值 查询效率 增删效率 std::map 红黑树 Y(Key) N N \\(O(logn)\\) \\(O(logn)\\) std::multimap 红黑树 Y(key) Y N \\(O(logn)\\) \\(O(logn)\\) std::unordered_map 哈希表 N(Key) N N \\(O(1)\\) \\(O(1)\\) 同上，multimap和map中的key是有序的且无法修改。 C++中，映射的调用形式为： #include &lt;map&gt; // ... std::unordered_set&lt;KEY_TYPE, DATA_TYPE&gt; map; // 声明一个映射 map.insert(pair&lt;KEY_TYPE, DATA_TYPE&gt;(key, data)); // 插入一对数据 auto iter = map.find(key); // 判断一个集合是否包含一个数据 if (iter != map.end()) { // 如果包含一个数据，则进行一些处理 // do things } 使用集合来解决哈希问题时，优先使用unordered_set，因为其查询效率和增删效率都是最优的。 242.有效的字母异位词 代码随想录链接 题目 LeetCode-242 给定两个字符串，判断这两个字符串是否是异位词。 自己的想法 异位词的其实就是同样的一组字母，进行不同的排列而形成的单词。特点有： 出现的字符相同 每个字符的出现次数相同 那在这里其实就可以使用映射关系，来存储26个字母中每个字母的出现的次数。可以使用数组，也可以使用map。 解法 class Solution { public: bool isAnagram(string s, string t) { int letters[26] = {0}; // 用于存储26个字母出现次数的数组 for (int i = 0; i &lt; s.size(); i++) letters[s[i] - 'a']++; // 遍历s字符串，计算每个字母出现的次数 for (int i = 0; i &lt; t.size(); i++) letters[t[i] - 'a']--; // 遍历t字符串，将出现的字母的次数进行减1 for (int i = 0; i &lt; 26; i++) if (letters[i] != 0) return false; // 如果数组中出现了不为0的值，证明两个字符串不符合异位词的特点 return true; // 如果数组最终均为0值，则两个字符串时异位词 } }; 该解法时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)。 349. 两个数组的交集 代码随想录链接 题目 LeetCode-349 给定两个数组，输出它们的交集。 自己的想法 集合么，将一个数组转为一个集合，然后遍历另外一个数组，依次判断第二个数组中的值是否存在于集合中，若存在，则将该数插入到结果集合中。 解法 class Solution { public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_set&lt;int&gt; result; // 结果集合 unordered_set&lt;int&gt; nums1_set(nums1.begin(), nums1.end()); // 根据第一个数组中的值生成一个集合 for (int i = 0; i &lt; nums2.size(); i++) { // 依次判断第二个数组中的数是否存在于集合中 if (nums1_set.find(nums2[i]) != nums1_set.end()) result.insert(nums2[i]); // 若存在，就将该值插入到结果结合中 } return vector&lt;int&gt;(result.begin(), result.end()); // 将结果集合转化为数组 } }; unordered_set的查询和增删效率都是\\(O(1)\\)，故生成集合的过程耗费时间为\\(O(n)\\)，遍历并判断是否存在以及插入到结果集合所耗费的时间为\\(O(n)\\)，将结果转化为数组的时间为\\(O(n)\\)，故时间复杂度为\\(o(n)\\)，空间复杂度为\\(o(n)\\)。 202. 快乐数 代码随想录链接 题目 LeetCode-202 判断一个数是否为快乐数，快乐数的定义为：进行一个循环，每次循环都将这个数替换为其各位数的平方和，若最终平方和为1，则该数为快乐数；若一直无限循环，则该数不是快乐数。 自己的想法 一直无限循环的话，每次替换的数值必定会有重复的，例如给定数是2时，其替换的值依次为：4,16,37,58,89,145,42,20,4,...。是一个重复的序列。 所以我们可以使用一个集合，当替换的值不为1时，判断每次替换的值是否存在于该集合中，如果存在则说明非快乐数，否则就将该替换值加入集合当中，继续循环。 解法 class Solution { public: int getSum(int n) { // 用于计算一个数的各位平方之和的函数 int sum = 0; while (n) { sum += (n % 10) * (n % 10); n /= 10; } return sum; } bool isHappy(int n) { unordered_set&lt;int&gt; sumSet; // 每次计算出的平方和的集合 while (n != 1) { // 当平方和不为1时进行循环 n = getSum(n); // 计算出平方和 if (sumSet.find(n) != sumSet.end()) return false; // 如果已经出现过这个平方和，说明非快乐数 else sumSet.insert(n); // 没有出现过就将本次平方和加入集合 } return true; // n == 1时，该数为快乐数 } }; 1. 两数之和 代码随想录链接 题目 LeetCode-1 给定一个数组和一个值，判断该数组中是否存在两个数且他们之和为给定值，若存在，则输出这两个值的索引。 自己的想法 暴力解法，两个for循环，根据一个数来查是否存在另外一个数 由于要输出的是两个值的索引，这个地方可以使用map来存储&lt;值, 索引&gt;对来解决问题。 解法一 class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { for (int i = 0; i &lt; nums.size(); i++) { // 遍历数组 int num1 = nums[i]; // 取当前遍历到的值A for (int j = i + 1; j &lt; nums.size(); j++) if (target - num1 == nums[j]) return vector&lt;int&gt;{i, j}; // 遍历查找在A之后的值中是否有与A之和等于给定值的数（你说为啥不从前面开始找，那我遍历前面的时候不是找过了？） } return vector&lt;int&gt;(); // 不存在则返回空数组 } }; 时间复杂度为\\(O(n^2)\\)，空间复杂度为\\(o(1)\\)。 解法二 class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; indexMap; // 存储&lt;值, 索引&gt;对的映射 for (int i = 0; i &lt; nums.size(); i++) { // 遍历数组 auto iter = indexMap.find(target - nums[i]); // 查找映射中是否有key为相应的加数的键值对 if (iter != indexMap.end()) return {iter -&gt; second, i}; // 若存在，则返回这两个索引 indexMap.insert(pair&lt;int, int&gt;(nums[i], i)); // 否则就将该键值对插入映射中 } return {}; // 不存在则返回空数组 } }; unordered_map的查询和增删效率都是\\(O(1)\\)，故该实现的时间复杂度为\\(O(n)\\)，空间复杂度为\\(o(n)\\)。","link":"/2023/02/20/algorithm-train-day6/"},{"title":"代码随想录算法训练营第1天 | 704. 二分查找、27. 移除元素","text":"希望自己能够坚持下去 自己的小破站好久没更了就是说。 二分查找 代码随想录-二分查找 适合条件 给定一个有序的数组，从其中找出指定的元素的位置 思路 将查找区间一分为二，通过对比区间中间值与目标值的大小来确定： 中间值是否就是目标值所在 若中间值不是目标值，确定下个循环的查找区间的移动方向 跳出循环的条件，区间的左边界大于区间的右边界 例题 LeetCode-704 二分查找 LeetCode-704 题目的描述就是给定了有序数组，在O(logn)的时间内找出给定值的索引，若给定值不存在，则输出-1。 在O(logn)的时间内完成这个操作，必定是需要使用和区间划分有关的方法。 根据区间定义的不同，有两种解题方法。 解法一 如果目标值在区间[left, right]内 class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int size = nums.size(); // 下面一行确定初次循环时的查找区间的左右边界 int left = 0, right = size - 1; while (left &lt;= right) { // 循环结束条件 /** * 根据左右边界计算出中间位置的索引， * 之所以不使用 mid = (left + right) / 2 是因为防止溢出 */ int mid = left + ((right - left) / 2); if (nums[mid] == target) return mid; // 若中间值为目标值，则返回中间值 if (nums[mid] &gt; target) { // 若中间值大于目标值，即要找的目标值应该在中间值的左侧，则将区间右边界向左调整 right = mid - 1; continue; } if (nums[mid] &lt; target) { // 若中间值小于目标值，即目标值应该在中间值的右侧，则将区间左边界向右调整 left = mid + 1; continue; } } return -1; // 当找不到目标值时，返回 -1 } }; 解法二 如果目标值在[left, right)内 class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { // 下面一行确定初次循环时的查找区间的左右边界 int left = 0, right = nums.size(); while (left &lt; right) { // 循环结束条件 /** * 根据左右边界计算出中间位置的索引， * 之所以不使用 mid = (left + right) / 2 是因为防止溢出 */ int mid = left + ((right - left) / 2); if (nums[mid] == target) return mid; // 若中间值为目标值，则返回中间值 if (nums[mid] &gt; target) { // 若中间值大于目标值，即要找的目标值应该在中间值的左侧，则将区间右边界向左调整 right = mid; continue; } if (nums[mid] &lt; target) { // 若中间值小于目标值，即目标值应该在中间值的右侧，则将区间左边界向右调整 left = mid + 1; continue; } } return -1; // 当找不到目标值时，返回 -1 } }; 类似题目 LeetCode-34 寻找可能重复的目标值的存在区间 分别利用二分法找最左边的目标值和最右侧的目标值。 class Solution { public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int leftBorder = getLeftBorder(nums, target); // 分别调用封装好的函数去找左右边界，性能可能稍差，但代码逻辑会清晰些 int rightBorder = getRightBorder(nums, target); if (leftBorder == -2 || rightBorder == -2) return {-1, -1}; // 不存在目标值的返回 if (rightBorder - leftBorder &gt; 1) return {leftBorder + 1, rightBorder - 1}; return {-1, -1}; } int getLeftBorder(vector&lt;int&gt; &amp;nums, int target) {// 找左边界，其实是找目标值的左侧紧挨着的非目标值的数 int left = 0, right = nums.size() - 1; int leftBorder = -2; while (left &lt;= right) { // 循环结束条件 int mid = left + ((right - left) / 2); // 求中间位置 if (nums[mid] &gt;= target) {// 由于要找的是左边界，当中间值大于等于目标值时，应当将当前寻找的边界取中间值左侧 right = mid - 1; // 右边界取在中间值左侧 leftBorder = right; // 为了处理可能存在的中间值等于目标值的情况，要将寻找的左边界置为当前的右边界 } else { // 若中间值小于目标值，证明要找的边界在中间值右边 left = mid + 1; } } return leftBorder; } int getRightBorder(vector&lt;int&gt; &amp;nums, int target) { // 找右边界，其实是找目标值右侧紧挨着的非目标值的数 int left = 0, right = nums.size() - 1; int rightBorder = -2; while (left &lt;= right) { // 循环结束条件 int mid = left + ((right - left) / 2); if (nums[mid] &gt; target) { // 中间值大于目标，应该取左区间 right = mid - 1; } else { // 中间值小于等于目标，应该取右区间，并更新rightBorder为右区间的首位 left = mid + 1; rightBorder = left; } } return rightBorder; } }; 移除元素 代码随想录-移除元素 题目要求 给定一个数组，和一个值，将数组中等于给定值的数据移出，返回剩下的数据组成的数组以及该数组的大小。 思路 解法一 暴力法，没有什么是for循环嵌套不能解决的（然后时间复杂度就上去了捏） 思路是，一个for循环用于遍历给定数组，遍历过程中若遇到与给定值相同的数，则使用一个新的for循环，将当前位置之后的全部数据，向前移动一位，同时还需要注意将遍历的索引置于正确位置。 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int size = nums.size(); // 记录数组的实时大小 for (int i = 0; i &lt; size; i++) { // 遍历数组 if (nums[i] == val) { // 若等于目标值，就使用一个新的for循环将后续数据向前移动一位 for (int j = i; j &lt; size - 1; j++) { nums[j] = nums[j + 1]; } i--; // 移动后，当前位置数据发生变化，该位置需要重新判断一次 size--; // 覆盖掉了一位数据，数组大小-1 } } return size; } }; 两个for循环且每个循环的循环次数与给定数组的大小线性有关，故时间复杂度为\\(O(n^2)\\)。 使用了常数个变量，故空间复杂度为\\(O(1)\\)。 解法二 双指针法 思想是同时保留两个指针，快指针用于遍历原数组，慢指针用于保存结果数组。当快指针遇到与给定值相同的数据时，什么也不做，只是单纯地将快指针移动到下一位；若快指针遇见了非给定值的数，则将快指针当前指向的数拷贝至慢指针指向的位置，并将慢指针后移一位。 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int slowIndex = 0; // 用于指向结果数组的末尾 for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) { // 遍历数组 if (val != nums[fastIndex]) { // 若遇到了非给定值的数，则将其保存下来，复制至slowIndex指向的位置，slowIndex向后移一位 nums[slowIndex++] = nums[fastIndex]; } // 若遇到了给定值的数，则什么都不做，相当于将其丢弃 } return slowIndex; // slowIndex在最后一次复制操作后的自增，正好为结果数组的大小 } }; 使用了一个for循环，循环的次数和数组大小线性相关，故时间复杂度为\\(O(n)\\)。 使用了常数个变量，故空间复杂度为\\(O(1)\\)。 解法三 另一种双指针法 类似于快速排序分区的过程，左指针从数组左侧出发，依次寻找一个等于给定值的数，等待被替换，找到后，右指针从数组末尾出发，找到一个不为给定值的数据，用于替换左指针指向的数据。 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int left = 0, right = nums.size() - 1; // 左右指针的起始位置 while (left &lt;= right) { // 循环进行条件 while (left &lt;= right &amp;&amp; nums[left] != val) { // 从左侧寻找一个与给定值相同的数，等待被替换 left++; } while (left &lt;= right &amp;&amp; nums[right] == val) { // 从右侧寻找一个非给定值的数，用于替换左指针找到的数 right--; } if (left &lt; right) { // 确保是因为找到了被替换数据和替换数据，才进行替换 nums[left++] = nums[right--]; } } return left; } }; 代码中循环次数和数组大小线性相关，故时间复杂度为\\(O(n)\\)，使用了常数个变量，故空间复杂度为\\(O(1)\\)。","link":"/2023/02/15/algorithm-train-day1/"},{"title":"macOS 10.15 ”app已损坏，无法打开“ 解决方法","text":"问题表现 安装了网上下载来的破解软件（大写加粗的穷）后，双击发现 不！能！用！还提示你扔到垃圾桶。 因为实在莫得钱去买软件，只能去找解决方案 # 命令行处理 将下载到的App拖入应用程序后，打开终端（iTerm等都可以），输入以下命令： $ sudo xattr -rd com.apple.quarantine 输入完先不要按下Enter，打开finder到应用程序那里，找到你下载的破解App，将其拖入到终端内。会变成类似于下面的 $ sudo xattr -rd com.apple.quarantine /Applications/xxx.app 其中xxx是你要用的软件的名字。这个时候按下回车，并输入当前用户的密码（输入密码的时候是看不见的，直接输就好），按下回车。 再打开就好了。","link":"/2019/12/18/mac-catalina-damaged-app/"},{"title":"代码随想录算法训练营第2天 |  977.有序数组的平方，209.长度最小的子数组，59.螺旋矩阵II","text":"977.有序数组的平方 代码随想录链接 题目 LeetCode-977 给定一个顺序不减的有序数组A，返回一个由A数组中每个值的平方组成的顺序不减数组。 自己的思考 可能还是倾向于暴力法一点，有看到提示说可以用双指针法，但是自己也没想明白应该怎么用(我好蔡啊.jpg) 解法一 暴力法，先就原地计算出来每一项的平方是多少，覆盖到原位置，然后再排个序。 #include&lt;algorithm&gt; class Solution { public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { for (int i = 0; i &lt; nums.size(); i++) { // 遍历每个值 nums[i] *= nums[i]; // 求出平方值，写入原位置 } sort(nums.begin(), nums.end()); // 调用C++的sort函数进行排序 return nums; } }; 一个for循环遍历数组，时间复杂度为\\(O(n)\\)，C++的sort函数是基于快速排序的优化算法，时间复杂度为\\(O(nlogn)\\)。 使用了常数个变量，空间复杂度为\\(O(1)\\)。 解法二 双指针法，类似于昨天的题目，使用两个指针来完成。 为什么可以使用双指针法呢？要题目给定的条件出发。 题目给定的数组是顺序不减进行排列的，求得平方值值后需要调整位置的情况，只存在于原数组左侧的负数，平方之后应该被排在右侧的某个位置，而原数组和结果数组的右侧都是较大的值。由这个条件，我们可以使用双指针法，对比两个指针指向的值的平方，较大的值，应该依次从右至左写入到结果数组内。 #include&lt;algorithm&gt; #include&lt;cmath&gt; class Solution { public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; result(nums.size(), 0); // 声明并实例化一个新的数组，大小和原数组一样，并均用0填充 int leftIndex = 0, rightIndex = nums.size() - 1, resultIndex = nums.size() - 1; // 声明原数组的左右指针，以及结果数组的指针 while(leftIndex &lt;= rightIndex) { // 循环条件 if (pow(nums[leftIndex], 2) &gt; pow(nums[rightIndex], 2)) { // 若左指针指向的数的平方值要大于右指针指向的数的平方值 result[resultIndex--] = pow(nums[leftIndex++], 2); // 将左指针的值写入到目标数组,并移动左指针和结果数组的指针 } else { result[resultIndex--] = pow(nums[rightIndex--], 2); // 否则，就将右指针指向的数的平方值写入结果数组，并相应调整两个指针 } } return result; } }; 算法中while的循环次数和数组的大小线性相关，时间复杂度为\\(O(n)\\)。 由于使用了一个新的且和原数组大小一致的数组，空间复杂度为\\(O(n)\\)。 209.长度最小的子数组 代码随想录链接 题目 LeetCode-209 自己的思考 暴力法（蔡啊） 失败案例 使用两个for循环，计算并对比从第一个for循环的索引指向的数开始的每个子序列是否符合条件，若符合条件，记录下最短值。 class Solution { public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int result = INT32_MAX; int sum = 0; int subLength = 0; for (int i = 0; i &lt; nums.size(); i++) { // 外层for循环，其索引用于标记子序列的开头 sum = 0; for (int j = i; j &lt; nums.size(); j++) { // 内层for循环，j表示当前判断的子序列的末尾索引 sum += nums[j]; // 将当前位置的值加入 if (sum &gt;= target) { // 若满足了大于等于目标值的条件，就计算并对比是否是最短子序列 subLength = j - i + 1; result = result &lt; subLength ? result : subLength; break; // 都找到满足的了，再往后找，子序列就变更长了，该考虑以下一位数据开头的子序列了 } } } return result == INT32_MAX ? 0 : result; // 如果result还是初始值，代表没有找到合适的子序列，按题目要求返回0 } }; 很不幸，由于这个写法的时间复杂度为\\(O(n^2)\\)，没有AC，超时了 LeetCode-209-寄 正确解法 滑动窗口法 什么是滑动窗口呢，这里给出一个百科链接，讲述的是TCP协议中的滑动窗口。 下面我用自己的语言描述一下滑动窗口。所谓滑动窗口，是指在序列中取一段子序列，其前后边界是可以随时按照情况进行灵活调整的。 但如果仍然使用上面的两个for循环来表示起始和终止位置的话，那和“灵活”两个字怕是要说再见了。 可以仅适用一个for循环来表示后指针，在循环内，对左指针进行调整。这里偷一个代码随想录网站上的动图，来更好地说明滑动窗口。 滑动窗口动图示意，图来自代码随想录 class Solution { public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int result = INT32_MAX; int sum = 0; int subLength = 0; int leftIndex = 0; // 左指针 for (int rightIndex = 0; rightIndex &lt; nums.size(); rightIndex++) { // 右指针 sum += nums[rightIndex]; // 移动右指针之后，更新当前窗口内元素之和 while (sum &gt;= target) { // 若当前窗口之和符合条件，则进入判断，若不符合条件，则进入for循环的下一次循环 subLength = rightIndex - leftIndex + 1; // 计算当前窗口的长度，并与记录值对比，若小于记录的长度值，则更新记录值 result = result &lt; subLength ? result : subLength; sum -= nums[leftIndex++]; // 将窗口左侧向右移动 } } return result == INT32_MAX ? 0 : result; } }; 这个解法使用了一个for循环来遍历数组，for循环内又有一个while循环，所以时间复杂度是\\(O(b^2)\\)，但是while循环执行一次，左指针就会向右移动一次，而左指针移动的次数是和数组的长度是线性相关的，所以整个过程中while循环的执行次数是\\(O(n)\\)，与for循环的次数无关。 故该解法的时间复杂度为\\(O(2 * n) = O(n)\\)。 使用了常数个变量，空间复杂度为\\(O(1)\\)。 59.螺旋矩阵II 代码随想录链接 题目 LeetCode-59 给定一个正整数n，以顺时针方向螺旋填充\\(n * n\\)的一个矩阵 自己的思考 这题本科的时候绝对做过。需要设定一些控制变量，用于记录当前填充的坐标，但是怎么设置控制变量，是非常关键的地方，然后想不出来了 解法 在设计控制变量的时候，要考虑好在什么条件下，需要按照上右下左四个边的顺序进行进行下一个边的填充。 还要考虑到填充的时候，边与边的重叠部分，应该怎么处理，比如： 重叠部分由当前边填写 由下一个边填写 当然甚至还可以： + 两个边都填写，然后再调整要填写的数字 这里选择由下一个边填写的方法，原因是在完成一个loop之后，下一个loop开始的位置比较容易计算。 class Solution { public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; result(n, vector&lt;int&gt;(n, 0)); // 结果矩阵 int startx = 0, starty = 0; // 下一个loop开始时的坐标 int offset = 1; // 控制填写一条边的时候，应该剩下几个位置不填写，offset初始为1即表示重叠部分在下一个边填写 int loop = n / 2; // 需要进行多少次螺旋 int mid = n / 2; // 计算是否需要对最中间的位置单独进行填充 int count = 1; // 记录下次填充的数字 int i, j; // 当前填充的位置坐标 while (loop--) { i = startx; // 自左上方开始的横纵坐标 j = starty; for (j = starty; j &lt; n - offset; j++) result[i][j] = count++; // 填写上边 for (i = startx; i &lt; n - offset; i++) result[i][j] = count++; // 填写右边 for (; j &gt; starty; j--) result[i][j] = count++; // 填写下边，这里的 j &gt; starty 也是为了控制重叠部分在下一条边填写 for (; i &gt; startx; i--) result[i][j] = count++; // 填写左边，这里的 i &gt; startx 同上理 startx++; // 完成一次四边填写后，调整起始位置 starty++; offset++; // 完成一次四边填写，offset应该+1来控制上边和右边的填写不覆盖掉之前填写的内容 } if (n % 2) result[mid][mid] = count; // 若 n 为基数，需要针对中心位置单独填写 return result; } }; 代码时间复杂度为\\(O(n^2)\\)，空间复杂度为\\(O(n^2)\\)。 数组总结 在这个数组的专题内，学习到的方法主要有 二分法 用于查找，主要思想是在有序的数组里，通过左边界和有边界计算出来区间中间位置，根据中间位置的数据与目标数据的大小关系来调整下一次寻找的左右区间。 关键的一点是坚持自己刚开始设定的对于区间的定义（是左闭右开、左开右闭亦或是左闭右闭），并贯穿到所写题目的整个代码当中。 时间复杂度为\\(O(logn)\\) 例题：LeetCode-704 二分查找 双指针法 顾名思义，使用两个指针在一个for循环下，完成两个for循环的工作，使得时间复杂度降低。 双指针法既可以是同时从一个方向起步，例如LeetCode-27；也可以是分别从数组的开始和末尾向中间靠拢，例如LeetCode-977 双指针法还经常在链表中使用。 滑动窗口 滑动窗口可以用于求一个数组中子序列之用，相比于暴力法显著地降低了时间复杂度。 要理解滑动窗口，关键之处就在于理解窗口的起始位置和结束位置是怎么调整的。例题：LeetCode-209 本文上面的部分有滑动窗口的示意图。 模拟行为 例如模拟螺旋填充矩阵。这类题目主要考察对于代码循环边界控制的能力。要做好这类题目，关键是需要坚持好边界上的处理方法，从一而终。","link":"/2023/02/16/algorithm-train-day2/"},{"title":"Mac下Clion的OpenGL环境配置","text":"Mac下Clion的OpenGL环境配置 安装glfw/glew $ brew install glew $ brew install glfw 对工程内CMakeLists.txt进行更改： cmake_minimum_required(VERSION 3.14) project(XXX) set(CMAKE_CXX_STANDARD 11) # 添加头文件 set(GLEW_H /usr/local/Cellar/glew/2.1.0/include/GL) set(GLFW_H /usr/local/Cellar/glfw/3.2.1/include/GLFW) include_directories(${GLEW_H} ${GLFW_H}) # 添加目标链接 set(GLEW_LINK /usr/local/Cellar/glew/2.1.0/lib/libGLEW.2.1.dylib) set(GLFW_LINK /usr/local/Cellar/glfw/3.2.1/lib/libglfw.3.dylib) link_libraries(${OPENGL} ${GLEW_LINK} ${GLFW_LINK}) # 执行编译命令 set(SOURCE_FILES main.cpp) add_executable(XXX ${SOURCE_FILES}) if (APPLE) target_link_libraries(XXX \"-framework OpenGL\") target_link_libraries(XXX \"-framework GLUT\") endif() 将上方的XXX改为自己的工程名称即可","link":"/2019/05/28/mac-clion-opengl/"},{"title":"Mac手动切换显卡","text":"手动切换Mac 显卡 主力电脑是一台15年的MacBook Pro 15寸顶配，有的时候，某些程序在运行时系统会把图形卡模式自动调整为高性能，就觉得对性能有影响，想手动切换。 系统自带的切换只能选择自动和独显，所以要使用其他方法 ### 终端切换 强制使用核显(集成显卡) $ sudo pmset -a GPUSwitch 0 强制使用独立显卡 $ sudo pmset -a GPUSwitch 1 自动切换 $ sudo pmset -a GPUSwitch 2 查看是否切换成功 $ pmset -g 使用第三方软件 Homebrew 安装 gfxCardStatus $ brew cask install gfxCardStatus","link":"/2019/05/27/mac-select-gpu/"},{"title":"微信小程序云开发数据库联表查找","text":"需求分析 现在有以下集合 orders集合： [ {\"_id\":4,\"book\":\"novel 1\",\"price\":30,\"quantity\":2}, {\"_id\":5,\"book\":\"science 1\",\"price\":20,\"quantity\":1}, {\"_id\":6} ] books集合： [ {\"_id\":\"book1\",\"author\":\"author 1\",\"category\":\"novel\",\"stock\":10,\"time\":1564456048486,\"title\":\"novel 1\"}, {\"_id\":\"book3\",\"author\":\"author 3\",\"category\":\"science\",\"stock\":30,\"title\":\"science 1\"}, {\"_id\":\"book4\",\"author\":\"author 3\",\"category\":\"science\",\"stock\":40,\"title\":\"science 2\"}, {\"_id\":\"book2\",\"author\":\"author 2\",\"category\":\"novel\",\"stock\":20,\"title\":\"novel 2\"}, {\"_id\":\"book5\",\"author\":\"author 4\",\"category\":\"science\",\"stock\":50,\"title\":null}, {\"_id\":\"book6\",\"author\":\"author 5\",\"category\":\"novel\",\"stock\":\"60\"} ] 要求进行联表查询，返回结果，匹配字段为orders的book字段和books的title字段 # 代码 const db = cloud.database() db.collection('orders').aggregate() .lookup({ from: 'books', localField: 'book', foreignField: 'title', as: 'bookList', }) .end() .then(res => console.log(res)) .catch(err => console.error(err)) 得到的结果为： [ { \"_id\": 4, \"book\": \"novel 1\", \"price\": 30, \"quantity\": 2, \"bookList\": [ { \"_id\": \"book1\", \"title\": \"novel 1\", \"author\": \"author 1\", \"category\": \"novel\", \"stock\": 10 } ] }, { \"_id\": 5, \"book\": \"science 1\", \"price\": 20, \"quantity\": 1, \"bookList\": [ { \"_id\": \"book3\", \"category\": \"science\", \"title\": \"science 1\", \"author\": \"author 3\", \"stock\": 30 } ] }, { \"_id\": 6, \"bookList\": [ { \"_id\": \"book5\", \"category\": \"science\", \"author\": \"author 4\", \"stock\": 50, \"title\": null }, { \"_id\": \"book6\", \"author\": \"author 5\", \"stock\": \"60\", \"category\": \"novel\" } ] } ] HINT：其中localField字段和foreignField字段，其中一个可以指定为Array。 改进 上面的代码里会生成一个新的字段bookList，若要将查询结果直接并入上一级，可有： var db = cloud.database() var $ = db.command.aggregate db.collection('orders').aggregate() .lookup({ from: \"books\", localField: \"book\", foreignField: \"title\", as: \"bookList\" }) .replaceRoot({ newRoot: $.mergeObjects([ $.arrayElemAt(['$bookList', 0]), '$$ROOT' ]) }) .project({ bookList: 0 }) .end() .then(res => console.log(res)) .catch(err => console.error(err)) 其中replaceRoot指定的是新生成的数据有哪些字段，必须传入newRoot参数 project指定要保留哪些字段，0为不保留，1为保留 引用 微信官方文档·小程序","link":"/2020/03/12/miniapp-lookup/"},{"title":"腾讯云SCF云函数部署OneDrive共享盘","text":"更新 更新于2022年7月 腾讯云SCF大幅削减了免费额度，请事先查阅收费标准再决定是否使用。 前情提要 申请了Office365技术社区成员，通过后获得了一个Office 365 E3的账号，其中包含1T容量的OneDrive for business世纪互联版。物要尽其用，用这个搭一个网盘。 &gt; OneDrive for business下的文件，组织的管理员可以查看，私人文件请放OneDrive个人版 教育邮箱白嫖的1T空间需要有管理员才可以继续搭建 # 准备工作 + 自己腾讯云账户SecretID和SecretKey + SCF函数文件 点击去Github 新建云函数 点击去云函数控制台 新建一个云函数，选择自己想要的区域，新建函数，运行环境选择Php 7.2，选择空白模板，下一步 OneDrive个人版选择内地区域可能会有问题，建议选择中国香港 拉到下方高级配置，你刚才选择的区域Region官方对应列表 点击完成 上传代码文件 返回到函数列表，点击函数，选择函数代码，更改提交方法，把解压缩的代码传上去，保存 添加触发方式 在触发方式内添加触发方式，选择API网关触发方式，将启用集成响应打钩，其余默认即可 获得访问路径 配置网盘参数 访问上一步内获得的链接 填写之前获得的SecretKey和SecretID，设置密码，确认 稍等会跳转到首页，点击左上角的管理，添加Onedrive盘 选择自己对应的版本： 怎么样选择自己的版本： 在浏览器里打开OneDrive的文件目录的首页，看地址栏的域名 域名 版本 onedrive.live.com 个人版 *****.sharepoint.cn 商业世纪互联版 *****.sharepoint.com 商业国际版 这里我用的是世纪互联版，选第二个 确认后会调到授权界面，授权即可 稍等即可跳转到首页 完善体验 网盘配置 在云函数环境变量处可以添加以下值（说明来自开发者）： 变量名 说明 sitename 网站的名称，不添加会显示为‘请在环境变量添加sitename’。 admin 管理密码，不添加时不显示登录页面且无法登录。 adminloginpage 管理登录的页面不再是'?admin'，而是此设置的值。如果设置，登录按钮及页面隐藏。 public_path 使用API长链接访问时，显示网盘文件的路径，不设置时默认为根目录；不能是private_path的上级（public看到的不能比private多，要么看到的就不一样）。 private_path 使用自定义域名访问时，显示网盘文件的路径，不设置时默认为根目录。 domain_path 格式为\"a1.com:/dir/path1|b1.com:/path2\"，比private_path优先。 imgup_path 设置图床路径，不设置这个值时该目录内容会正常列文件出来，设置后只有上传界面，不显示其中文件（登录后显示）。 passfile 自定义密码文件的名字，可以是'pppppp'，也可以是'aaaa.txt'等等；密码是这个文件的内容，可以空格、可以中文；列目录时不会显示，只有知道密码才能查看或下载此文件。 自定义域名 触发方式下选择API服务名 在自定义域名下选择新建 填写域名，路径映射选择自定义，填/，环境选择发布 如果没有证书的话，可以去控制台免费申请证书 点击提交前，请先将自定义的域名用CNAME方式指向图中的公网二级域名 在管理API下，点击编辑 路径改为/ 下一步 勾选是否启用响应集成 下一步 返回类型选择HTML 完成，点击前往发布服务 点击发布 写点备注，提交 部署完成 已经可以用来访问了","link":"/2020/03/12/scf-onedrive/"},{"title":"基于Wechaty的群学习内容推送工具","text":"Author: @GilesWong Code: @GilesWong/wechaty-xiaowang 功能 定时采集英语的每日一题，推送到群里 早晨问好，同时发送当天天气预报，每半天检查一次未来 24 小时内设定的经纬度处是否有降水。 采集网站上的新闻早报，补充时政知识 发送每日一句 图灵机器人对话 （来源于第三方的数据仅供学习之用，请经常访问这些优质网站） ## 特点 使用腾讯云云函数进行定时获取信息的操作，减少了服务器上的配置难度 使用 Node.js Express 对 Wechaty 进行了封装，后续功能可以本地写好 python 或 nodejs 云函数后，直接部署在腾讯云上，不用调整服务器 使用 pm2 进行 wechaty 运行状态的维持（后续可以考虑改为使用无服务器的环境，比如 Leancloud、Heroku 容器等，减少服务器的开支） 功能示例 项目结构 |-- wechaty-xiaowang |-- index.js //主程序 |-- package-lock.json |-- package.json |-- puppet-config.js //pupet参数 |-- serverchan.js //通过方糖报告错误 |-- tulingbot.js //图灵机器人 |-- cloudFunctions // 运行在腾讯云上的云函数爬虫 |-- dailyEnglishTest //英语每日一题 |-- dailySentence //英语每日一句 |-- moringNews //每日早报 |-- rainDetection //降雨提醒 |-- weatherTip //早晨问好，及天气预报 架构说明 服务器端 Express + Wechaty 开放一个 HTTP 接口用于访问，传入 HTTP 接口的内容会被发送到预先指定的群内 云函数端 定时获取信息，并通过 HTTP 调用发送给 Wechaty 机器人 使用 wechaty 的部署 填写代码中的配置，如Token，服务器地址、端口等 上传至服务器 在其目录下，获取所有用到的 NPM 包 npm i 使用node index.js命令，启动wechaty，并扫码登录 （可选）调试好之后，可选择使用pm2等工具维持wechaty的运行 （可选）使用Nginx的反向代理功能来实现HTTPS，增强安全性 （可选）使用cloudflare的防火墙规则或者Nginx，来将访问权限限制到特定的范围，增强安全性 云函数的部署 打开 https://console.cloud.tencent.com/scf/index 注册并新建云函数 新建时选择空白函数即可,然后选择目前要增加的函数的环境，之后点击下一步 Python 3.6 Node.js 12.16 在提交方法处，选择上传文件夹 选择当前增加的函数的文件夹，上传即可 新建完成后，返回云函数主页面，点击函数服务- 触发管理 弹出的创建触发器的页面内，选择自定义触发，填入Cron表达式 Cron表达式用法见：https://cloud.tencent.com/document/product/583/9708#cron-.E8.A1.A8.E8.BE.BE.E5.BC.8F 完成 对于每日新闻的代码，其运行于Coding的定时构建计划内，详见：https://help.coding.net/docs/devops/ci/trigger.html 致谢 JUZI Bot提供的Token，使这个小项目具有可行性 Wechaty (非常优秀的项目) 腾讯云（提供了几乎免费的云函数） Coding（提供了免费使用的构建计划的主机） ```","link":"/2020/08/24/wechaty/"}],"tags":[{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"代码随想录","slug":"代码随想录","link":"/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"},{"name":"Transfer Learning","slug":"Transfer-Learning","link":"/tags/Transfer-Learning/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"Clion","slug":"Clion","link":"/tags/Clion/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Serverless","slug":"Serverless","link":"/tags/Serverless/"},{"name":"Onedrive","slug":"Onedrive","link":"/tags/Onedrive/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"}],"categories":[],"pages":[]}