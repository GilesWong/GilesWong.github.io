{"posts":[{"title":"2021级西安交通大学计算机专硕上岸经验","text":"个人情况 计算机科班, 双非, 无科研经历, 做过两个小的外包项目, 绩点4.1, 20%左右 四六级大一过的, 四级600分, 六级558分 初试成绩:政治75, 英语二86, 数学二126, 专业课912 119, 总分 406分, 初试排名目测是25左右 最后总排名15~20. 去年在王道论坛看了20各位学长的经验贴, 得到了许多帮助. 现在把自己的一些心得写一下, 希望能帮助到备考的你. 仅供参考. 初试准备 正式开始准备基本上是从6月初开始的,去学校提供的考研教室,每天差不多7点起,7-9月份晚上到8点,之后就去锻炼. 10月份起就6点半起,到9点结束学习. 相比着之前发帖的大佬,我觉得我的学习效率可能远不如他. 考研有一个复习的法则: 多次, 全面. 政治 20年的特殊形势, 在政治卷子上的影响就体现在各个老师押题押的都很准(因为不得不考这些),导致最后大家的分数普遍较高.同时也就是说, 大家的政治主要靠的还是考前的一个月突击, 在此之前政治不要开始过早过晚, 月初就可. 我自己用的是徐涛老师的核心考案, 听徐涛老师的强化班的课(徐涛老师的课可能是那段时间快乐的源泉之一),另外买了肖秀荣老师的1000题,听一章课,做一章选择题,大题不用做.虽然题和课不是同一个老师的,但是在章节分布上还是差不多的,这样搭配没问题的. (私以为的)重点来了: 1000题上做过的选择题,要定时进行复习(主要是重做). 我推荐使用一些辅助记忆的方法来完成,比如说艾宾浩斯遗忘曲线等. 我使用的是iPad上面的软件(开发者把广告费结一下谢谢), 卡片只需要添加哪一页哪一题即可,然后按照查阅计划重复做. 11月份等肖8出来之后, 开始做肖8的选择题, 做法和1000题一样,尽量把所有选择题都搞懂. 大题的话B站找带背视频(我看的空卡的). 肖4出来之后,选择题还是全部搞懂,大题试着自己做一下,同样也是找带背视频,背下来. 省流助手: - 9月初开始就行 - 徐涛 - 徐涛强化班 - 肖秀荣1000题 - 1000题的错题 - 11月份之后肖8 肖4 - 宝藏UP主的带背视频 英语 英语是门语言,想要成绩好的话,还是要多背单词,词汇量上去了题目完全就不是问题. 我从19年10月份开始用背单词软件(墨墨背单词, 其他软件也可以)背单词, 把考研要求的词汇全背了. 背单词这个过程要一直持续到初试考完英语那天,一定要坚持下去. 7月份开始,做英语往年真题. 英语二可以先做英语一的题目, 然后再做英语二的. 我用的是黄皮书. 阅读理解每道错题都要找出为什么错,错在哪里. 作文在考前40天左右,开始背作文书,我背的是王江涛的作文预测,里面的20篇要背的非常熟.基本上作文就没什么问题了. 要点: - 背单词直到初试英语结束 - 7月份开始做真题 - 背作文书 数学 21的数学算是...不要太简单, 我数学底子比较差, 都可以考到126分. 按照大小年的规律, 22的同学们要小心了, 22的数学大概率会非常难. 而且数学非常能拉分, 所以数学一定要抓好.我数学从5月份开始准备(说实话, 晚了), 高数跟的是武忠祥老师, 线代跟的是李永乐老师. 材料全是他们的配套材料. 基础部分建议就6月份及之前, 开始学的话就先把高数基础班过一遍, 再过线代, 过的时候看一节课, 做一节课对应的习题, 把错误的习题拿红笔标注一下, 方便重复去做. 做完一节课之后可以再反过头来, 把这节的理论知识再过一遍, 重点放在自己不熟练的地方. 强化阶段建议7-9月. 这段时间非常关键, 是数学提分的重要阶段. 武忠祥老师的高数强化资料和李永乐老师的线代强化资料上面的题目都是非常好的. 把这些题能够吃透, 130应该是没问题的, 不要怕错题, 发现了错题, 解决一个问题, 才能进步. 10-11月份, 开始做真题, 各家的真题都可以买, 没什么特别大的区别, 做真题的话把最近15年的做题吃透就可以了, 抽个时间可以试着给自己来一次模拟考试. 11月底就开始刷模拟卷, 我用的模拟卷是李林老师的6套卷和4套卷, 题目难度适中, 比较适合数学二的考试来做. 专业课 21专业课课程代码不变, 初试科目比20少了一门操作系统(不要以为初试科目少就比其他好考, 西交复试有笔试). 数据结构这门课, 没什么好说的, 王道吃透做透就行了. 试卷上数据结构总共有选择题, 大题, 以及代码题三种. 选择题是5道, 大题5道, 代码题1道. 这些题目在王道上都有比较接近或类似的题目. 参考书籍的散列表部分可以看一下, 有王道上面没有的知识点, 前些年考过. 计算机组成原理这门课是比较不好做的. 一定要买王换招老师的那本书, 然后反复啃, 反复看, 把课后习题搞懂就问题不大. 试卷上计算机组成原理的题目有填空题, 简答题, 计算题. 简答题的占比还是很大的, 这点务必要注意. 课后习题里面的简答题和书上的一些重要的知识点, 都有可能出简答题. 复试 复试阶段有笔试, 机试, 面试(面试包括英语面试, 专业提问以及老师们对你的自由问答). 现阶段先准备初试即可, 初试完之后觉得可以的话, 再准备复试. 笔试可选 操作系统, 计算机网络, 离散数学, 数据库, 编译原理, 软件工程. 六选二. 难度也是不小的. 同样还是喜欢考简答题, 还有名词解释的题目(给你英文单词, 让你解释这是什么东西, 回答时中英文都可). 最低60分. 机试可用C, C++, Java. 五道题目, 总体来说还是难度不大的. 考一些基本操作. 最低分50分. 面试部分基本上就是自我介绍, 文献翻译, 专业提问, 老师自由提问这四个部分.","link":"/2021/04/09/2021-xjtu-postgraduate-admission-experience/"},{"title":"11.1 迁移学习【斯坦福21秋季：实用机器学习中文版】","text":"本节课程课件： 课件 自己做的思维导图： 导图 迁移学习的出发点 - 在一个任务上学习到的知识，可以在另外一个地方用到 因为训练要花钱，还要搞数据集 途径 训练好的模型做成特征抽取的模块，得到特征干别的事情，比如作为另外一个模型的输入 在相关的任务上训练一个模型，在另外一个任务上直接用，例如GPT系列 在训练好的模型上，针对新的任务进行微调（本节内容） 相关领域 半监督学习 极端情况下，新的任务，不给标记；或者只给几张有标记 多任务学习，每一个任务都有自己的数据但不是很够，但任务之间又有相关性 转移知识 - 有很多大规模的标好的数据集，尤其是图片分类任务上（因为标记很容易） 计算机视觉的迁移学习里面，存在很多效果比较好的模型，希望把这些模型的知识拓展到自己的任务上去 刚开始进行任务的时候可能不会投入太多，看能不能利用别人在标记好的、比自己的数据集大10倍，100倍的数据集上面学到的一些东西迁移过来，试试效果 预训练模型 - 用的最多的迁移学习的方法 一般来说，一个神经网络大概分为两块 编码器 可以认为是特征提取器 将像素转化为在语义空间里面线性可分的一些特征（浅表示） 解码器 可能就是个线性层 把编码器的输出映射为最终结果，做决策 例如 给个猫的图片 可以认为除了最后一层之外的，都是编码器 最后一层把语义特征（如1024的特征向量），转化为语义空间内的表示 也可以认为最后几层都是解码器，剩下的是编码器 预训练模型 在比较大的数据集上训练好的一个模型 训练的数据集大，可以认为其有一定的泛化能力 泛化能力指，放到别的任务或者数据集上，多多少少也是能帮点忙 虽然目标任务可能不会对猫感兴趣，但是编码器部分多多少少学会了点怎么样去处理像素的信息 在ImageNet上训练的模型，能对其他任务的图片做特征提取，总比从随机开始好 Fine-Tune技巧 - 通常认为，在深度学习中微调能够带来最好的效果 在新的任务上面，构建一个新的模型，其架构要与预训练模型一样 如一个在ImageNet上训练好的ResNet 50模型 在新的任务上面，也要用一个ResNet 50模型（可以先找找在当前任务的特定架构上是不是有比较好的预训练模型） 初始化模型 新模型的特征提取器（编码器）的权重直接从预训练模型得到 解码器的权重随机初始化 不同任务的语义空间不同 例如图中右侧的例子 在限制搜索空间，进行训练 因为之前效果已经比较好了，已经在最优解附近了 要把学习率调的小 例如正常是0.1，现在要用1e-3 epoch数要小 例如 不做特别的限制的话，不管是fine-tune还是随机初始化整个网络，在足够长的时间下，网络都会达到一个特定的程度，但这个程度并非是最佳状态 泛化误差和训练误差是不一样的 在数据集不大且网络足够复杂的情况下，网络是可以记住整个数据集的 训练误差最低的时候，泛化误差不一定更好 在完全拟合自己的数据和保留在大数据集上的泛化能力之间，做一个权衡 冻结底层网络 - 限制搜索空间的另一种方法 因为神经网络有个比较层次化的学习过程 在最底层学到一些底层的特征的表示，像素底层特征，学习到的纹理是什么形状、颜色的知识 如一个圆圈，图形的边 层数越来越高的时候，多多少少会学到一些更大，更全局的东西，更加跟语义相关 最下面的层在微调的时候不动 例如第0层学习率为0，第1层为1e-8，第二层为1e-7 通常做法，固定住最下面一些层，往上面一些层学习率为1e-3，再往上是1e-1 需要固定多少层是需要调的 若目标任务和预训练模型之间差比较大的话，需要多训练一些层 差异小的话，可以固定更多层，极端情况下甚至可以只允许最后一层进行训练 在哪儿找与训练模型 - 在微调的时候怎么样找到一个与训练模型，很重要 首先有没有 例如要注重latency的话，找个训练好的MobileNet 其次是考虑在什么样的大数据集上 例如是在ImageNet上训练好的 各种各样的Hub Timm的Hub Fine-Tune应用 - 使用在大数据集预训练好的模型，Fine-Tune到自己的任务上，是过去七八年至现在，在CV方面都是一个主流方法 - 目标检测/分割----图片相似但目标不同 - 医学/卫星图像识别----任务相同但图像不同 微调加速了收敛 开始的点不是随机初始化的点，而是比较靠近目标的点 不一定提升精度 预训练的数据集和目标数据集比较像的时候，一般结果会比只在目标数据集上训练好 有时候直接在目标数据集上训练时也会得到一个相似的结果，特别是在目标数据集比较大的情况下 通常不会让精度变得更低，So why not? 总结 - 通常会在比较大的数据集上训练预训练好的模型 在新的任务上，初始化一个编码器部分的权重和预训练模型权重一样的模型，解码器权重随机初始化 微调通常来说加速收敛，有时会提升精度，但不会使得精度变差","link":"/2022/07/23/cs329p-slides-transfer-learning/"},{"title":"代码随想录算法训练营第一天 | 704. 二分查找、27. 移除元素","text":"希望自己能够坚持下去 自己的小破站好久没更了就是说。 二分查找 代码随想录-二分查找 ### 适合条件 给定一个有序的数组，从其中找出指定的元素的位置 思路 将查找区间一分为二，通过对比区间中间值与目标值的大小来确定： 中间值是否就是目标值所在 若中间值不是目标值，确定下个循环的查找区间的移动方向 跳出循环的条件，区间的左边界大于区间的右边界 例题 LeetCode-704 二分查找 LeetCode-704 题目的描述就是给定了有序数组，在O(logn)的时间内找出给定值的索引，若给定值不存在，则输出-1。 在O(logn)的时间内完成这个操作，必定是需要使用和区间划分有关的方法。 根据区间定义的不同，有两种解题方法。 #### 解法一 如果目标值在区间[left, right]内 class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int size = nums.size(); // 下面一行确定初次循环时的查找区间的左右边界 int left = 0, right = size - 1; while (left &lt;= right) { // 循环结束条件 /** * 根据左右边界计算出中间位置的索引， * 之所以不使用 mid = (left + right) / 2 是因为防止溢出 */ int mid = left + ((right - left) / 2); if (nums[mid] == target) return mid; // 若中间值为目标值，则返回中间值 if (nums[mid] &gt; target) { // 若中间值大于目标值，即要找的目标值应该在中间值的左侧，则将区间右边界向左调整 right = mid - 1; continue; } if (nums[mid] &lt; target) { // 若中间值小于目标值，即目标值应该在中间值的右侧，则将区间左边界向右调整 left = mid + 1; continue; } } return -1; // 当找不到目标值时，返回 -1 } }; 解法二 如果目标值在[left, right)内 class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { // 下面一行确定初次循环时的查找区间的左右边界 int left = 0, right = nums.size(); while (left &lt; right) { // 循环结束条件 /** * 根据左右边界计算出中间位置的索引， * 之所以不使用 mid = (left + right) / 2 是因为防止溢出 */ int mid = left + ((right - left) / 2); if (nums[mid] == target) return mid; // 若中间值为目标值，则返回中间值 if (nums[mid] &gt; target) { // 若中间值大于目标值，即要找的目标值应该在中间值的左侧，则将区间右边界向左调整 right = mid; continue; } if (nums[mid] &lt; target) { // 若中间值小于目标值，即目标值应该在中间值的右侧，则将区间左边界向右调整 left = mid + 1; continue; } } return -1; // 当找不到目标值时，返回 -1 } }; 类似题目 LeetCode-34 寻找可能重复的目标值的存在区间 分别利用二分法找最左边的目标值和最右侧的目标值。 class Solution { public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int leftBorder = getLeftBorder(nums, target); // 分别调用封装好的函数去找左右边界，性能可能稍差，但代码逻辑会清晰些 int rightBorder = getRightBorder(nums, target); if (leftBorder == -2 || rightBorder == -2) return {-1, -1}; // 不存在目标值的返回 if (rightBorder - leftBorder &gt; 1) return {leftBorder + 1, rightBorder - 1}; return {-1, -1}; } int getLeftBorder(vector&lt;int&gt; &amp;nums, int target) {// 找左边界，其实是找目标值的左侧紧挨着的非目标值的数 int left = 0, right = nums.size() - 1; int leftBorder = -2; while (left &lt;= right) { // 循环结束条件 int mid = left + ((right - left) / 2); // 求中间位置 if (nums[mid] &gt;= target) {// 由于要找的是左边界，当中间值大于等于目标值时，应当将当前寻找的边界取中间值左侧 right = mid - 1; // 右边界取在中间值左侧 leftBorder = right; // 为了处理可能存在的中间值等于目标值的情况，要将寻找的左边界置为当前的右边界 } else { // 若中间值小于目标值，证明要找的边界在中间值右边 left = mid + 1; } } return leftBorder; } int getRightBorder(vector&lt;int&gt; &amp;nums, int target) { // 找右边界，其实是找目标值右侧紧挨着的非目标值的数 int left = 0, right = nums.size() - 1; int rightBorder = -2; while (left &lt;= right) { // 循环结束条件 int mid = left + ((right - left) / 2); if (nums[mid] &gt; target) { // 中间值大于目标，应该取左区间 right = mid - 1; } else { // 中间值小于等于目标，应该取右区间，并更新rightBorder为右区间的首位 left = mid + 1; rightBorder = left; } } return rightBorder; } }; 移除元素 代码随想录-移除元素 题目要求 给定一个数组，和一个值，将数组中等于给定值的数据移出，返回剩下的数据组成的数组以及该数组的大小。 思路 解法一 暴力法，没有什么是for循环嵌套不能解决的（然后时间复杂度就上去了捏） 思路是，一个for循环用于遍历给定数组，遍历过程中若遇到与给定值相同的数，则使用一个新的for循环，将当前位置之后的全部数据，向前移动一位，同时还需要注意将遍历的索引置于正确位置。 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int size = nums.size(); // 记录数组的实时大小 for (int i = 0; i &lt; size; i++) { // 遍历数组 if (nums[i] == val) { // 若等于目标值，就使用一个新的for循环将后续数据向前移动一位 for (int j = i; j &lt; size - 1; j++) { nums[j] = nums[j + 1]; } i--; // 移动后，当前位置数据发生变化，该位置需要重新判断一次 size--; // 覆盖掉了一位数据，数组大小-1 } } return size; } }; 两个for循环且每个循环的循环次数与给定数组的大小线性有关，故时间复杂度为\\(O(n^2)\\)。 使用了常数个变量，故空间复杂度为\\(O(1)\\)。 解法二 双指针法 思想是同时保留两个指针，快指针用于遍历原数组，慢指针用于保存结果数组。当快指针遇到与给定值相同的数据时，什么也不做，只是单纯地将快指针移动到下一位；若快指针遇见了非给定值的数，则将快指针当前指向的数拷贝至慢指针指向的位置，并将慢指针后移一位。 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int slowIndex = 0; // 用于指向结果数组的末尾 for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) { // 遍历数组 if (val != nums[fastIndex]) { // 若遇到了非给定值的数，则将其保存下来，复制至slowIndex指向的位置，slowIndex向后移一位 nums[slowIndex++] = nums[fastIndex]; } // 若遇到了给定值的数，则什么都不做，相当于将其丢弃 } return slowIndex; // slowIndex在最后一次复制操作后的自增，正好为结果数组的大小 } }; 使用了一个for循环，循环的次数和数组大小线性相关，故时间复杂度为\\(O(n)\\)。 使用了常数个变量，故空间复杂度为\\(O(1)\\)。 解法三 另一种双指针法 类似于快速排序分区的过程，左指针从数组左侧出发，依次寻找一个等于给定值的数，等待被替换，找到后，右指针从数组末尾出发，找到一个不为给定值的数据，用于替换左指针指向的数据。 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int left = 0, right = nums.size() - 1; // 左右指针的起始位置 while (left &lt;= right) { // 循环进行条件 while (left &lt;= right &amp;&amp; nums[left] != val) { // 从左侧寻找一个与给定值相同的数，等待被替换 left++; } while (left &lt;= right &amp;&amp; nums[right] == val) { // 从右侧寻找一个非给定值的数，用于替换左指针找到的数 right--; } if (left &lt; right) { // 确保是因为找到了被替换数据和替换数据，才进行替换 nums[left++] = nums[right--]; } } return left; } }; 代码中循环次数和数组大小线性相关，故时间复杂度为\\(O(n)\\)，使用了常数个变量，故空间复杂度为\\(O(1)\\)。","link":"/2023/02/15/algorithm-train-day1/"},{"title":"Mac下Clion的OpenGL环境配置","text":"Mac下Clion的OpenGL环境配置 安装glfw/glew $ brew install glew $ brew install glfw 对工程内CMakeLists.txt进行更改： cmake_minimum_required(VERSION 3.14) project(XXX) set(CMAKE_CXX_STANDARD 11) # 添加头文件 set(GLEW_H /usr/local/Cellar/glew/2.1.0/include/GL) set(GLFW_H /usr/local/Cellar/glfw/3.2.1/include/GLFW) include_directories(${GLEW_H} ${GLFW_H}) # 添加目标链接 set(GLEW_LINK /usr/local/Cellar/glew/2.1.0/lib/libGLEW.2.1.dylib) set(GLFW_LINK /usr/local/Cellar/glfw/3.2.1/lib/libglfw.3.dylib) link_libraries(${OPENGL} ${GLEW_LINK} ${GLFW_LINK}) # 执行编译命令 set(SOURCE_FILES main.cpp) add_executable(XXX ${SOURCE_FILES}) if (APPLE) target_link_libraries(XXX \"-framework OpenGL\") target_link_libraries(XXX \"-framework GLUT\") endif() 将上方的XXX改为自己的工程名称即可","link":"/2019/05/28/mac-clion-opengl/"},{"title":"微信小程序云开发数据库联表查找","text":"需求分析 现在有以下集合 orders集合： [ {\"_id\":4,\"book\":\"novel 1\",\"price\":30,\"quantity\":2}, {\"_id\":5,\"book\":\"science 1\",\"price\":20,\"quantity\":1}, {\"_id\":6} ] books集合： [ {\"_id\":\"book1\",\"author\":\"author 1\",\"category\":\"novel\",\"stock\":10,\"time\":1564456048486,\"title\":\"novel 1\"}, {\"_id\":\"book3\",\"author\":\"author 3\",\"category\":\"science\",\"stock\":30,\"title\":\"science 1\"}, {\"_id\":\"book4\",\"author\":\"author 3\",\"category\":\"science\",\"stock\":40,\"title\":\"science 2\"}, {\"_id\":\"book2\",\"author\":\"author 2\",\"category\":\"novel\",\"stock\":20,\"title\":\"novel 2\"}, {\"_id\":\"book5\",\"author\":\"author 4\",\"category\":\"science\",\"stock\":50,\"title\":null}, {\"_id\":\"book6\",\"author\":\"author 5\",\"category\":\"novel\",\"stock\":\"60\"} ] 要求进行联表查询，返回结果，匹配字段为orders的book字段和books的title字段 # 代码 const db = cloud.database() db.collection('orders').aggregate() .lookup({ from: 'books', localField: 'book', foreignField: 'title', as: 'bookList', }) .end() .then(res => console.log(res)) .catch(err => console.error(err)) 得到的结果为： [ { \"_id\": 4, \"book\": \"novel 1\", \"price\": 30, \"quantity\": 2, \"bookList\": [ { \"_id\": \"book1\", \"title\": \"novel 1\", \"author\": \"author 1\", \"category\": \"novel\", \"stock\": 10 } ] }, { \"_id\": 5, \"book\": \"science 1\", \"price\": 20, \"quantity\": 1, \"bookList\": [ { \"_id\": \"book3\", \"category\": \"science\", \"title\": \"science 1\", \"author\": \"author 3\", \"stock\": 30 } ] }, { \"_id\": 6, \"bookList\": [ { \"_id\": \"book5\", \"category\": \"science\", \"author\": \"author 4\", \"stock\": 50, \"title\": null }, { \"_id\": \"book6\", \"author\": \"author 5\", \"stock\": \"60\", \"category\": \"novel\" } ] } ] HINT：其中localField字段和foreignField字段，其中一个可以指定为Array。 改进 上面的代码里会生成一个新的字段bookList，若要将查询结果直接并入上一级，可有： var db = cloud.database() var $ = db.command.aggregate db.collection('orders').aggregate() .lookup({ from: \"books\", localField: \"book\", foreignField: \"title\", as: \"bookList\" }) .replaceRoot({ newRoot: $.mergeObjects([ $.arrayElemAt(['$bookList', 0]), '$$ROOT' ]) }) .project({ bookList: 0 }) .end() .then(res => console.log(res)) .catch(err => console.error(err)) 其中replaceRoot指定的是新生成的数据有哪些字段，必须传入newRoot参数 project指定要保留哪些字段，0为不保留，1为保留 引用 微信官方文档·小程序","link":"/2020/03/12/miniapp-lookup/"},{"title":"macOS 10.15 ”app已损坏，无法打开“ 解决方法","text":"问题表现 安装了网上下载来的破解软件（大写加粗的穷）后，双击发现 不！能！用！还提示你扔到垃圾桶。 因为实在莫得钱去买软件，只能去找解决方案 # 命令行处理 将下载到的App拖入应用程序后，打开终端（iTerm等都可以），输入以下命令： $ sudo xattr -rd com.apple.quarantine 输入完先不要按下Enter，打开finder到应用程序那里，找到你下载的破解App，将其拖入到终端内。会变成类似于下面的 $ sudo xattr -rd com.apple.quarantine /Applications/xxx.app 其中xxx是你要用的软件的名字。这个时候按下回车，并输入当前用户的密码（输入密码的时候是看不见的，直接输就好），按下回车。 再打开就好了。","link":"/2019/12/18/mac-catalina-damaged-app/"},{"title":"腾讯云SCF云函数部署OneDrive共享盘","text":"更新 更新于2022年7月 腾讯云SCF大幅削减了免费额度，请事先查阅收费标准再决定是否使用。 前情提要 申请了Office365技术社区成员，通过后获得了一个Office 365 E3的账号，其中包含1T容量的OneDrive for business世纪互联版。物要尽其用，用这个搭一个网盘。 &gt; OneDrive for business下的文件，组织的管理员可以查看，私人文件请放OneDrive个人版 教育邮箱白嫖的1T空间需要有管理员才可以继续搭建 # 准备工作 + 自己腾讯云账户SecretID和SecretKey + SCF函数文件 点击去Github 新建云函数 点击去云函数控制台 新建一个云函数，选择自己想要的区域，新建函数，运行环境选择Php 7.2，选择空白模板，下一步 OneDrive个人版选择内地区域可能会有问题，建议选择中国香港 拉到下方高级配置，你刚才选择的区域Region官方对应列表 点击完成 上传代码文件 返回到函数列表，点击函数，选择函数代码，更改提交方法，把解压缩的代码传上去，保存 添加触发方式 在触发方式内添加触发方式，选择API网关触发方式，将启用集成响应打钩，其余默认即可 获得访问路径 配置网盘参数 访问上一步内获得的链接 填写之前获得的SecretKey和SecretID，设置密码，确认 稍等会跳转到首页，点击左上角的管理，添加Onedrive盘 选择自己对应的版本： 怎么样选择自己的版本： 在浏览器里打开OneDrive的文件目录的首页，看地址栏的域名 域名 版本 onedrive.live.com 个人版 *****.sharepoint.cn 商业世纪互联版 *****.sharepoint.com 商业国际版 这里我用的是世纪互联版，选第二个 确认后会调到授权界面，授权即可 稍等即可跳转到首页 完善体验 网盘配置 在云函数环境变量处可以添加以下值（说明来自开发者）： 变量名 说明 sitename 网站的名称，不添加会显示为‘请在环境变量添加sitename’。 admin 管理密码，不添加时不显示登录页面且无法登录。 adminloginpage 管理登录的页面不再是'?admin'，而是此设置的值。如果设置，登录按钮及页面隐藏。 public_path 使用API长链接访问时，显示网盘文件的路径，不设置时默认为根目录；不能是private_path的上级（public看到的不能比private多，要么看到的就不一样）。 private_path 使用自定义域名访问时，显示网盘文件的路径，不设置时默认为根目录。 domain_path 格式为\"a1.com:/dir/path1|b1.com:/path2\"，比private_path优先。 imgup_path 设置图床路径，不设置这个值时该目录内容会正常列文件出来，设置后只有上传界面，不显示其中文件（登录后显示）。 passfile 自定义密码文件的名字，可以是'pppppp'，也可以是'aaaa.txt'等等；密码是这个文件的内容，可以空格、可以中文；列目录时不会显示，只有知道密码才能查看或下载此文件。 自定义域名 触发方式下选择API服务名 在自定义域名下选择新建 填写域名，路径映射选择自定义，填/，环境选择发布 如果没有证书的话，可以去控制台免费申请证书 点击提交前，请先将自定义的域名用CNAME方式指向图中的公网二级域名 在管理API下，点击编辑 路径改为/ 下一步 勾选是否启用响应集成 下一步 返回类型选择HTML 完成，点击前往发布服务 点击发布 写点备注，提交 部署完成 已经可以用来访问了","link":"/2020/03/12/scf-onedrive/"},{"title":"Mac手动切换显卡","text":"手动切换Mac 显卡 主力电脑是一台15年的MacBook Pro 15寸顶配，有的时候，某些程序在运行时系统会把图形卡模式自动调整为高性能，就觉得对性能有影响，想手动切换。 系统自带的切换只能选择自动和独显，所以要使用其他方法 ### 终端切换 强制使用核显(集成显卡) $ sudo pmset -a GPUSwitch 0 强制使用独立显卡 $ sudo pmset -a GPUSwitch 1 自动切换 $ sudo pmset -a GPUSwitch 2 查看是否切换成功 $ pmset -g 使用第三方软件 Homebrew 安装 gfxCardStatus $ brew cask install gfxCardStatus","link":"/2019/05/27/mac-select-gpu/"},{"title":"基于Wechaty的群学习内容推送工具","text":"Author: @GilesWong Code: @GilesWong/wechaty-xiaowang 功能 定时采集英语的每日一题，推送到群里 早晨问好，同时发送当天天气预报，每半天检查一次未来 24 小时内设定的经纬度处是否有降水。 采集网站上的新闻早报，补充时政知识 发送每日一句 图灵机器人对话 （来源于第三方的数据仅供学习之用，请经常访问这些优质网站） ## 特点 使用腾讯云云函数进行定时获取信息的操作，减少了服务器上的配置难度 使用 Node.js Express 对 Wechaty 进行了封装，后续功能可以本地写好 python 或 nodejs 云函数后，直接部署在腾讯云上，不用调整服务器 使用 pm2 进行 wechaty 运行状态的维持（后续可以考虑改为使用无服务器的环境，比如 Leancloud、Heroku 容器等，减少服务器的开支） 功能示例 项目结构 |-- wechaty-xiaowang |-- index.js //主程序 |-- package-lock.json |-- package.json |-- puppet-config.js //pupet参数 |-- serverchan.js //通过方糖报告错误 |-- tulingbot.js //图灵机器人 |-- cloudFunctions // 运行在腾讯云上的云函数爬虫 |-- dailyEnglishTest //英语每日一题 |-- dailySentence //英语每日一句 |-- moringNews //每日早报 |-- rainDetection //降雨提醒 |-- weatherTip //早晨问好，及天气预报 架构说明 服务器端 Express + Wechaty 开放一个 HTTP 接口用于访问，传入 HTTP 接口的内容会被发送到预先指定的群内 云函数端 定时获取信息，并通过 HTTP 调用发送给 Wechaty 机器人 使用 wechaty 的部署 填写代码中的配置，如Token，服务器地址、端口等 上传至服务器 在其目录下，获取所有用到的 NPM 包 npm i 使用node index.js命令，启动wechaty，并扫码登录 （可选）调试好之后，可选择使用pm2等工具维持wechaty的运行 （可选）使用Nginx的反向代理功能来实现HTTPS，增强安全性 （可选）使用cloudflare的防火墙规则或者Nginx，来将访问权限限制到特定的范围，增强安全性 云函数的部署 打开 https://console.cloud.tencent.com/scf/index 注册并新建云函数 新建时选择空白函数即可,然后选择目前要增加的函数的环境，之后点击下一步 Python 3.6 Node.js 12.16 在提交方法处，选择上传文件夹 选择当前增加的函数的文件夹，上传即可 新建完成后，返回云函数主页面，点击函数服务- 触发管理 弹出的创建触发器的页面内，选择自定义触发，填入Cron表达式 Cron表达式用法见：https://cloud.tencent.com/document/product/583/9708#cron-.E8.A1.A8.E8.BE.BE.E5.BC.8F 完成 对于每日新闻的代码，其运行于Coding的定时构建计划内，详见：https://help.coding.net/docs/devops/ci/trigger.html 致谢 JUZI Bot提供的Token，使这个小项目具有可行性 Wechaty (非常优秀的项目) 腾讯云（提供了几乎免费的云函数） Coding（提供了免费使用的构建计划的主机） ```","link":"/2020/08/24/wechaty/"}],"tags":[{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Transfer Learning","slug":"Transfer-Learning","link":"/tags/Transfer-Learning/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"代码随想录","slug":"代码随想录","link":"/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"Clion","slug":"Clion","link":"/tags/Clion/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"Serverless","slug":"Serverless","link":"/tags/Serverless/"},{"name":"Onedrive","slug":"Onedrive","link":"/tags/Onedrive/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"}],"categories":[],"pages":[]}