{"posts":[{"title":"2021级西安交通大学计算机专硕上岸经验","text":"个人情况 计算机科班, 双非, 无科研经历, 做过两个小的外包项目, 绩点4.1, 20%左右 四六级大一过的, 四级600分, 六级558分 初试成绩:政治75, 英语二86, 数学二126, 专业课912 119, 总分 406分, 初试排名目测是25左右 最后总排名15~20. 去年在王道论坛看了20各位学长的经验贴, 得到了许多帮助. 现在把自己的一些心得写一下, 希望能帮助到备考的你. 仅供参考. 初试准备 正式开始准备基本上是从6月初开始的,去学校提供的考研教室,每天差不多7点起,7-9月份晚上到8点,之后就去锻炼. 10月份起就6点半起,到9点结束学习. 相比着之前发帖的大佬,我觉得我的学习效率可能远不如他. 考研有一个复习的法则: 多次, 全面. 政治 20年的特殊形势, 在政治卷子上的影响就体现在各个老师押题押的都很准(因为不得不考这些),导致最后大家的分数普遍较高.同时也就是说, 大家的政治主要靠的还是考前的一个月突击, 在此之前政治不要开始过早过晚, 月初就可. 我自己用的是徐涛老师的核心考案, 听徐涛老师的强化班的课(徐涛老师的课可能是那段时间快乐的源泉之一),另外买了肖秀荣老师的1000题,听一章课,做一章选择题,大题不用做.虽然题和课不是同一个老师的,但是在章节分布上还是差不多的,这样搭配没问题的. (私以为的)重点来了: 1000题上做过的选择题,要定时进行复习(主要是重做). 我推荐使用一些辅助记忆的方法来完成,比如说艾宾浩斯遗忘曲线等. 我使用的是iPad上面的软件(开发者把广告费结一下谢谢), 卡片只需要添加哪一页哪一题即可,然后按照查阅计划重复做. 11月份等肖8出来之后, 开始做肖8的选择题, 做法和1000题一样,尽量把所有选择题都搞懂. 大题的话B站找带背视频(我看的空卡的). 肖4出来之后,选择题还是全部搞懂,大题试着自己做一下,同样也是找带背视频,背下来. 省流助手: - 9月初开始就行 - 徐涛 - 徐涛强化班 - 肖秀荣1000题 - 1000题的错题 - 11月份之后肖8 肖4 - 宝藏UP主的带背视频 英语 英语是门语言,想要成绩好的话,还是要多背单词,词汇量上去了题目完全就不是问题. 我从19年10月份开始用背单词软件(墨墨背单词, 其他软件也可以)背单词, 把考研要求的词汇全背了. 背单词这个过程要一直持续到初试考完英语那天,一定要坚持下去. 7月份开始,做英语往年真题. 英语二可以先做英语一的题目, 然后再做英语二的. 我用的是黄皮书. 阅读理解每道错题都要找出为什么错,错在哪里. 作文在考前40天左右,开始背作文书,我背的是王江涛的作文预测,里面的20篇要背的非常熟.基本上作文就没什么问题了. 要点: - 背单词直到初试英语结束 - 7月份开始做真题 - 背作文书 数学 21的数学算是...不要太简单, 我数学底子比较差, 都可以考到126分. 按照大小年的规律, 22的同学们要小心了, 22的数学大概率会非常难. 而且数学非常能拉分, 所以数学一定要抓好.我数学从5月份开始准备(说实话, 晚了), 高数跟的是武忠祥老师, 线代跟的是李永乐老师. 材料全是他们的配套材料. 基础部分建议就6月份及之前, 开始学的话就先把高数基础班过一遍, 再过线代, 过的时候看一节课, 做一节课对应的习题, 把错误的习题拿红笔标注一下, 方便重复去做. 做完一节课之后可以再反过头来, 把这节的理论知识再过一遍, 重点放在自己不熟练的地方. 强化阶段建议7-9月. 这段时间非常关键, 是数学提分的重要阶段. 武忠祥老师的高数强化资料和李永乐老师的线代强化资料上面的题目都是非常好的. 把这些题能够吃透, 130应该是没问题的, 不要怕错题, 发现了错题, 解决一个问题, 才能进步. 10-11月份, 开始做真题, 各家的真题都可以买, 没什么特别大的区别, 做真题的话把最近15年的做题吃透就可以了, 抽个时间可以试着给自己来一次模拟考试. 11月底就开始刷模拟卷, 我用的模拟卷是李林老师的6套卷和4套卷, 题目难度适中, 比较适合数学二的考试来做. 专业课 21专业课课程代码不变, 初试科目比20少了一门操作系统(不要以为初试科目少就比其他好考, 西交复试有笔试). 数据结构这门课, 没什么好说的, 王道吃透做透就行了. 试卷上数据结构总共有选择题, 大题, 以及代码题三种. 选择题是5道, 大题5道, 代码题1道. 这些题目在王道上都有比较接近或类似的题目. 参考书籍的散列表部分可以看一下, 有王道上面没有的知识点, 前些年考过. 计算机组成原理这门课是比较不好做的. 一定要买王换招老师的那本书, 然后反复啃, 反复看, 把课后习题搞懂就问题不大. 试卷上计算机组成原理的题目有填空题, 简答题, 计算题. 简答题的占比还是很大的, 这点务必要注意. 课后习题里面的简答题和书上的一些重要的知识点, 都有可能出简答题. 复试 复试阶段有笔试, 机试, 面试(面试包括英语面试, 专业提问以及老师们对你的自由问答). 现阶段先准备初试即可, 初试完之后觉得可以的话, 再准备复试. 笔试可选 操作系统, 计算机网络, 离散数学, 数据库, 编译原理, 软件工程. 六选二. 难度也是不小的. 同样还是喜欢考简答题, 还有名词解释的题目(给你英文单词, 让你解释这是什么东西, 回答时中英文都可). 最低60分. 机试可用C, C++, Java. 五道题目, 总体来说还是难度不大的. 考一些基本操作. 最低分50分. 面试部分基本上就是自我介绍, 文献翻译, 专业提问, 老师自由提问这四个部分.","link":"/2021/04/09/2021-xjtu-postgraduate-admission-experience/"},{"title":"代码随想录算法训练营第1天 | 704. 二分查找、27. 移除元素","text":"希望自己能够坚持下去 自己的小破站好久没更了就是说。 二分查找 代码随想录-二分查找 适合条件 给定一个有序的数组，从其中找出指定的元素的位置 思路 将查找区间一分为二，通过对比区间中间值与目标值的大小来确定： 中间值是否就是目标值所在 若中间值不是目标值，确定下个循环的查找区间的移动方向 跳出循环的条件，区间的左边界大于区间的右边界 例题 LeetCode-704 二分查找 LeetCode-704 题目的描述就是给定了有序数组，在O(logn)的时间内找出给定值的索引，若给定值不存在，则输出-1。 在O(logn)的时间内完成这个操作，必定是需要使用和区间划分有关的方法。 根据区间定义的不同，有两种解题方法。 解法一 如果目标值在区间[left, right]内 class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int size = nums.size(); // 下面一行确定初次循环时的查找区间的左右边界 int left = 0, right = size - 1; while (left &lt;= right) { // 循环结束条件 /** * 根据左右边界计算出中间位置的索引， * 之所以不使用 mid = (left + right) / 2 是因为防止溢出 */ int mid = left + ((right - left) / 2); if (nums[mid] == target) return mid; // 若中间值为目标值，则返回中间值 if (nums[mid] &gt; target) { // 若中间值大于目标值，即要找的目标值应该在中间值的左侧，则将区间右边界向左调整 right = mid - 1; continue; } if (nums[mid] &lt; target) { // 若中间值小于目标值，即目标值应该在中间值的右侧，则将区间左边界向右调整 left = mid + 1; continue; } } return -1; // 当找不到目标值时，返回 -1 } }; 解法二 如果目标值在[left, right)内 class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { // 下面一行确定初次循环时的查找区间的左右边界 int left = 0, right = nums.size(); while (left &lt; right) { // 循环结束条件 /** * 根据左右边界计算出中间位置的索引， * 之所以不使用 mid = (left + right) / 2 是因为防止溢出 */ int mid = left + ((right - left) / 2); if (nums[mid] == target) return mid; // 若中间值为目标值，则返回中间值 if (nums[mid] &gt; target) { // 若中间值大于目标值，即要找的目标值应该在中间值的左侧，则将区间右边界向左调整 right = mid; continue; } if (nums[mid] &lt; target) { // 若中间值小于目标值，即目标值应该在中间值的右侧，则将区间左边界向右调整 left = mid + 1; continue; } } return -1; // 当找不到目标值时，返回 -1 } }; 类似题目 LeetCode-34 寻找可能重复的目标值的存在区间 分别利用二分法找最左边的目标值和最右侧的目标值。 class Solution { public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int leftBorder = getLeftBorder(nums, target); // 分别调用封装好的函数去找左右边界，性能可能稍差，但代码逻辑会清晰些 int rightBorder = getRightBorder(nums, target); if (leftBorder == -2 || rightBorder == -2) return {-1, -1}; // 不存在目标值的返回 if (rightBorder - leftBorder &gt; 1) return {leftBorder + 1, rightBorder - 1}; return {-1, -1}; } int getLeftBorder(vector&lt;int&gt; &amp;nums, int target) {// 找左边界，其实是找目标值的左侧紧挨着的非目标值的数 int left = 0, right = nums.size() - 1; int leftBorder = -2; while (left &lt;= right) { // 循环结束条件 int mid = left + ((right - left) / 2); // 求中间位置 if (nums[mid] &gt;= target) {// 由于要找的是左边界，当中间值大于等于目标值时，应当将当前寻找的边界取中间值左侧 right = mid - 1; // 右边界取在中间值左侧 leftBorder = right; // 为了处理可能存在的中间值等于目标值的情况，要将寻找的左边界置为当前的右边界 } else { // 若中间值小于目标值，证明要找的边界在中间值右边 left = mid + 1; } } return leftBorder; } int getRightBorder(vector&lt;int&gt; &amp;nums, int target) { // 找右边界，其实是找目标值右侧紧挨着的非目标值的数 int left = 0, right = nums.size() - 1; int rightBorder = -2; while (left &lt;= right) { // 循环结束条件 int mid = left + ((right - left) / 2); if (nums[mid] &gt; target) { // 中间值大于目标，应该取左区间 right = mid - 1; } else { // 中间值小于等于目标，应该取右区间，并更新rightBorder为右区间的首位 left = mid + 1; rightBorder = left; } } return rightBorder; } }; 移除元素 代码随想录-移除元素 题目要求 给定一个数组，和一个值，将数组中等于给定值的数据移出，返回剩下的数据组成的数组以及该数组的大小。 思路 解法一 暴力法，没有什么是for循环嵌套不能解决的（然后时间复杂度就上去了捏） 思路是，一个for循环用于遍历给定数组，遍历过程中若遇到与给定值相同的数，则使用一个新的for循环，将当前位置之后的全部数据，向前移动一位，同时还需要注意将遍历的索引置于正确位置。 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int size = nums.size(); // 记录数组的实时大小 for (int i = 0; i &lt; size; i++) { // 遍历数组 if (nums[i] == val) { // 若等于目标值，就使用一个新的for循环将后续数据向前移动一位 for (int j = i; j &lt; size - 1; j++) { nums[j] = nums[j + 1]; } i--; // 移动后，当前位置数据发生变化，该位置需要重新判断一次 size--; // 覆盖掉了一位数据，数组大小-1 } } return size; } }; 两个for循环且每个循环的循环次数与给定数组的大小线性有关，故时间复杂度为\\(O(n^2)\\)。 使用了常数个变量，故空间复杂度为\\(O(1)\\)。 解法二 双指针法 思想是同时保留两个指针，快指针用于遍历原数组，慢指针用于保存结果数组。当快指针遇到与给定值相同的数据时，什么也不做，只是单纯地将快指针移动到下一位；若快指针遇见了非给定值的数，则将快指针当前指向的数拷贝至慢指针指向的位置，并将慢指针后移一位。 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int slowIndex = 0; // 用于指向结果数组的末尾 for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) { // 遍历数组 if (val != nums[fastIndex]) { // 若遇到了非给定值的数，则将其保存下来，复制至slowIndex指向的位置，slowIndex向后移一位 nums[slowIndex++] = nums[fastIndex]; } // 若遇到了给定值的数，则什么都不做，相当于将其丢弃 } return slowIndex; // slowIndex在最后一次复制操作后的自增，正好为结果数组的大小 } }; 使用了一个for循环，循环的次数和数组大小线性相关，故时间复杂度为\\(O(n)\\)。 使用了常数个变量，故空间复杂度为\\(O(1)\\)。 解法三 另一种双指针法 类似于快速排序分区的过程，左指针从数组左侧出发，依次寻找一个等于给定值的数，等待被替换，找到后，右指针从数组末尾出发，找到一个不为给定值的数据，用于替换左指针指向的数据。 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int left = 0, right = nums.size() - 1; // 左右指针的起始位置 while (left &lt;= right) { // 循环进行条件 while (left &lt;= right &amp;&amp; nums[left] != val) { // 从左侧寻找一个与给定值相同的数，等待被替换 left++; } while (left &lt;= right &amp;&amp; nums[right] == val) { // 从右侧寻找一个非给定值的数，用于替换左指针找到的数 right--; } if (left &lt; right) { // 确保是因为找到了被替换数据和替换数据，才进行替换 nums[left++] = nums[right--]; } } return left; } }; 代码中循环次数和数组大小线性相关，故时间复杂度为\\(O(n)\\)，使用了常数个变量，故空间复杂度为\\(O(1)\\)。","link":"/2023/02/15/algorithm-train-day1/"},{"title":"代码随想录算法训练营第10天 | 栈和队列理论基础，232.用栈实现队列，225.用队列实现栈","text":"栈和队列理论基础 栈是先进后出的数据结构，队列是先进先出的结构。如图所示。 C++中的STL有三儿比较普遍的版本： HP STL，是C++ STL的第一个实现版本，而且开放源代码。 P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。 SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。 C++的栈和队列不是一个容器，而是一个容器适配器，其内部的数据存储形式可以由不同的其他数据实现，如vector, deque, list等。 目前使用最广泛的SGI STL中，deque是默认的栈的底层实现。开发者也可以指定栈的底层实现。 std::stack&lt;int, std::vector&lt;int&gt; &gt; stack; // 使用vector为底层容器的栈 队列的情况一样，SGI STL中队列一样是以deque为默认情况下的底部结构。也可以手动指定： std::queue&lt;int, std::list&lt;int&gt;&gt; queue; // 定义以list为底层容器的队列 232.用栈实现队列 代码随想录链接 题目 LeetCode-232 使用栈实现队列。又是在王道上做过的题 自己的想法 使用两个栈，A栈负责接收输入的数据，在遇到取队首或者出队操作时，若B栈为空，将A栈的元素依次弹出并压入B栈，此时B栈栈顶即为“队首”，若B栈不为空，直接操作B栈栈顶即可。 解法 class MyQueue { private: stack&lt;int&gt; in, out; // 用于接收输入数据和输出数据的两个栈 public: MyQueue() { } void push(int x) { in.push(x); // 直接放入in栈中 } int pop() { if (out.empty()) { // 若输出栈out为空 while (!in.empty()) { // 将in栈中的所有元素弹出并压入out栈 out.push(in.top()); in.pop(); } } if (!out.empty()) { // 当out栈不为空时，取值并弹出元素 int val = out.top(); out.pop(); return val; } return -1; } int peek() { int frontVal = this -&gt; pop(); // 调用已经写好的pop函数来获得队首值 out.push(frontVal); // 将值放置到原位置上 return frontVal; } bool empty() { return in.empty() &amp;&amp; out.empty(); } }; 225.用队列实现栈 代码随想录链接 题目 LeetCode-225 使用队列来实现栈。 自己的想法 重点在处理出栈操作。思路是将队列中的元素不断出队，直到原来在队尾（即“栈顶”）的元素到达队首，再对队首进行出队操作即可。 解法 class MyStack { private: queue&lt;int&gt; q; public: MyStack() { } void push(int x) { // “压栈”操作，直接进队 q.push(x); } int pop() { int size = q.size(); // 获得元素个数 int tmp; while (--size) { // 重复（队长 - 1）次 tmp = q.front(); // 队首出队并重新入队 q.pop(); q.push(tmp); } int val = q.front(); // 取此时队首并返回 q.pop(); return val; } int top() { int topVal = this -&gt; pop(); // 重复利用上面的函数，获得“栈顶” q.push(topVal); // 将该元素重新入队，复原栈 return topVal; } bool empty() { return q.empty(); } };","link":"/2023/02/24/algorithm-train-day10/"},{"title":"代码随想录算法训练营第14天 | 二叉树理论基础，二叉树遍历","text":"二叉树理论基础 一个节点指向左右两个孩子节点构成的树状结构。 二叉树的种类 满二叉树 一棵二叉树只有度为0和度为2的节点，且度为0的节点都在同一层上时，该二叉树为满二叉树。深度为k的满二叉树，节点一定有\\(2 ^k - 1\\)个。 满二叉树，图源代码随想录 完全二叉树 除了最底层节点可能没填满以外，每层节点都达到了最大值，且最底层节点都集中在左侧。 完全二叉树 二叉搜索树 二叉搜索树是个有序树，其左子树上的节点的值均小于根节点的值，右子树上的值均大于根节点的值，且左右子树也是二叉搜索树。 二叉搜索树 平衡二叉搜索树 平衡二叉搜索树实在二叉搜索树的基础上，添加以下要求： 为空树或者左右子树高度差不大于1 左右子树都是平衡二叉搜索树 平衡二叉搜索树 C++中map, set, multimap, multiset的底层实现都是平衡二叉搜索树，所以map, set的增删操作时间都是\\(O(logn)\\)。unordered_set、unordered_map 的实现是哈希表。 二叉树的存储方式 可以链式存储，也可以顺序存储 链式存储 使用链表的形式，通过左右孩子指针完成链接。 链式存储二叉树 顺序存储 就是使用数组来存储二叉树。若父节点的索引为\\(i\\)，其左孩子节点索引为\\(2 * i + 1\\)，右孩子节点索引为\\(2 * i + 2\\)。 二叉树的遍历方式 深度优先遍历 优先向深度递增的方向访问。可分为前序遍历、中序遍历、后序遍历。 广度优先遍历 优先访问同一深度的节点。有层次遍历。 二叉树的定义 struct TreeNode { int data; TreeNode *left; TreeNode *right; }; 二叉树递归遍历 例题: 前序遍历 中序遍历 后序遍历 递归遍历的写法比较简单，按照前中后三种遍历方式的定义来写即可。 前序遍历： class Solution { private: void preOrderTravel(TreeNode *root, vector&lt;int&gt; &amp;result) { if (root == NULL) return; result.push_back(root -&gt; val); // 先访问该节点 preOrderTravel(root -&gt; left, result); // 再访问左右节点 preOrderTravel(root -&gt; right, result); } public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (root == NULL) return result; preOrderTravel(root, result); return result; } }; 中序遍历: class Solution { private: void inOrderTravel(TreeNode *root, vector&lt;int&gt; &amp;result) { if (!root) return; inOrderTravel(root -&gt; left, result); // 先访问左节点 result.push_back(root -&gt; val); // 再访问中间节点 inOrderTravel(root -&gt; right, result); // 最后访问右节点 } public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; inOrderTravel(root, result); return result; } }; 后序遍历: class Solution { private: void postOrderTravel(TreeNode *root, vector&lt;int&gt; &amp;result) { if (root == NULL) return; postOrderTravel(root -&gt; left, result); // 先访问左节点 postOrderTravel(root -&gt; right, result); // 再访问右节点 result.push_back(root -&gt; val); // 最后访问中间节点 } public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; postOrderTravel(root, result); return result; } }; 二叉树迭代遍历 使用迭代来完成二叉树的遍历也是一个重点.二叉树的迭代遍历中,最主要的部分是对栈的调用. 前序遍历: class Solution { public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (root == NULL) return result; stack&lt;TreeNode*&gt; st; // 用来遍历节点的栈 st.push(root); // 将根节点入栈 while (!st.empty()) { // 栈不为空时 TreeNode *node = st.top(); // 取栈顶并出栈 st.pop(); result.push_back(node -&gt; val); // 访问节点 if (node -&gt; right) st.push(node -&gt; right); // 左右子节点存在时,先压入右子节点,再压入左子节点 if (node -&gt; left) st.push(node -&gt; left); } return result; } }; 中序遍历: class Solution { public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; // 中序遍历中处理顺序和访问顺序不一致,需要额外指针辅助 while (cur != NULL || !st.empty()) { // 当指针不为空或者栈不为空时 if (cur) { // 如果指针不为空 st.push(cur); // 指针节点压栈,指针左移 cur = cur -&gt; left; } else { // 若指针为空,意味着遇到了一颗子树遍历完成,需要进行中间节点的访问 cur = st.top(); st.pop(); result.push_back(cur -&gt; val); cur = cur -&gt; right; // 访问中间节点完毕后,指针右移 } } return result; } }; 后序遍历: 后序遍历的顺序是左右中,可以通过中右左的顺序逆转来完成. class Solution { public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; stack&lt;TreeNode*&gt; st; st.push(root); while (!st.empty()) { // 与前序遍历的代码相似,不过交换了左右节点的压栈顺序 TreeNode *cur = st.top(); st.pop(); result.push_back(cur -&gt; val); if (cur -&gt; left) st.push(cur -&gt; left); if (cur -&gt; right) st.push(cur -&gt; right); } reverse(result.begin(), result.end()); // 逆转访问记录来获得目标顺序的记录 return result; } }; 二叉树统一迭代法 上面的迭代法写的方式不够统一. 下面是三种遍历比较统一的写法. 前序遍历: class Solution { public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (root == NULL) return result; stack&lt;TreeNode*&gt; st; st.push(root); // 压入根节点 while (!st.empty()) { // 栈不为空时 TreeNode *node = st.top(); // 取栈顶 if (node) { // 若栈顶元素不是空指针,则弹出并将不为空的右指针和左指针压入 st.pop(); if (node -&gt; right) st.push(node -&gt; right); if (node -&gt; left) st.push(node -&gt; left); st.push(node); // 再压入节点本身 st.push(NULL); // 压入一个空指针,表示需要访问该节点 } else { // 栈顶是空指针时 st.pop(); node = st.top(); // 获得需要访问的节点并进行访问 st.pop(); result.push_back(node -&gt; val); } } return result; } }; 中序遍历: class Solution { public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (root == NULL) return result; stack&lt;TreeNode*&gt; st; st.push(root); // 压入根节点 while (!st.empty()) { // 栈不为空时 TreeNode *node = st.top(); // 取栈顶 if (node) { // 若栈顶元素不是空指针,则弹出并将不为空的右指针,节点指针和访问标记,左指针压入 st.pop(); if (node -&gt; right) st.push(node -&gt; right); st.push(node); // 压入节点本身 st.push(NULL); // 压入一个空指针,表示需要访问该节点 if (node -&gt; left) st.push(node -&gt; left); } else { // 栈顶是空指针时 st.pop(); node = st.top(); // 获得需要访问的节点并进行访问 st.pop(); result.push_back(node -&gt; val); } } return result; } }; 后序遍历: class Solution { public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; if (root == NULL) return result; stack&lt;TreeNode*&gt; st; st.push(root); // 压入根节点 while (!st.empty()) { // 栈不为空时 TreeNode *node = st.top(); // 取栈顶 if (node) { // 若栈顶元素不是空指针,则弹出并将节点指针和访问标记,不为空的右指针,左指针压入 st.pop(); st.push(node); // 压入节点本身 st.push(NULL); // 压入一个空指针,表示需要访问该节点 if (node -&gt; right) st.push(node -&gt; right); if (node -&gt; left) st.push(node -&gt; left); } else { // 栈顶是空指针时 st.pop(); node = st.top(); // 获得需要访问的节点并进行访问 st.pop(); result.push_back(node -&gt; val); } } return result; } };","link":"/2023/02/28/algorithm-train-day14/"},{"title":"代码随想录算法训练营第11天 | 20. 有效的括号，1047. 删除字符串中的所有相邻重复项，150. 逆波兰表达式求值","text":"20. 有效的括号 (代码随想录链接)[https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html] 题目 LeetCode-20 给定一个只包含了()6种字符的字符串，判断该字符串中的括号是否满足左右匹配。 自己的想法 遇到左侧符号[({就进栈，遇到右侧符号])}就判断栈顶是否为对应的左侧符号，若是则将左侧符号弹出，若不匹配，则不满足条件。若遍历完成后，栈中仍有元素，则也不满足条件。 题解 class Solution { private: stack&lt;char&gt; cs; public: bool isPair(char a, char b) { // 判断a是否为b的对应左侧符号 if (a == '(' &amp;&amp; b == ')') return true; if (a == '[' &amp;&amp; b == ']') return true; if (a == '{' &amp;&amp; b == '}') return true; return false; } bool isValid(string s) { for (char c : s) { // 遍历字符串中的字符 if (c == '(' || c == '{' || c == '[') cs.push(c); // 若为左侧字符，则入栈 else { // 若为右侧字符 if (cs.empty()) return false; // 栈中没有内容，不匹配 char topChar = cs.top(); // 判断栈顶符号是否和当前的右侧符号匹配 if (isPair(topChar, c)) cs.pop(); else return false; } } if (!cs.empty()) return false; // 遍历完成后，栈若不为空，则仍不满足条件 return true; } }; 1047. 删除字符串中的所有相邻重复项 (代码随想录链接)[https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html] 题目 LeetCode-1047 去除字符串中所有的相同相邻字符。 自己的想法 遍历给定的字符串，设遍历获得的字符为c，若c和新的结果字符串末尾的字符相同，则将结果字符串的末尾字符取出；若不同，则将c拼接在新的字符串的结尾。实际上将字符串当做了一个栈。 题解 class Solution { public: string removeDuplicates(string s) { string result; // 初始化一个结果字符串 for (char c : s) { // 遍历给定的字符串 if (result.empty() || result.back() != c) { // 若字符串为空或者字符串末尾字符不等于当前遍历到的字符 result.push_back(c); // 将该字符加入结果字符串 } else { result.pop_back(); // 否则就将结果字符串的末尾字符去除 } } return result; } }; 150. 逆波兰表达式求值 (代码随想录链接)[https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html] 题目 LeetCode-150 根据逆波兰表达式，求该表达式的值。 自己的想法 Yet Anther Problem Appeared in WANGDAO. 设两个栈，一个用于存储运算数，一个用于暂存运算符。遍历表达式，遇到运算数就将数据压栈，遇到运算符时，先查看运算符的栈栈顶的运算符，若当前运算符的顺序高于栈顶运算符时，则将运算符入栈，否则取运算数栈顶两个数字，使用当前运算符进行运算，并将结果压入运算数栈中。遍历完成后若运算符栈仍有运算符，继续取出做运算。最后返回运算数栈的栈顶数字即可。 题解 class Solution { public: bool hasPriority(char a, char b) { // 对比运算符优先级 if ((a == '*' || a == '/') &amp;&amp; (b == '+' || b == '-')) return true; return false; } int evalRPN(vector&lt;string&gt;&amp; tokens) { stack&lt;int&gt; nums; stack&lt;char&gt; ops; for (string s : tokens) { if (s != &quot;+&quot; &amp;&amp; s != &quot;-&quot; &amp;&amp; s != &quot;*&quot; &amp;&amp; s != &quot;/&quot;) nums.push(stoi(s)); // 将遇到的每个运算数入栈 else { char c = s[0]; if (ops.empty() || !hasPriority(s[0], ops.top())) { // 满足进行运算的条件 int a = nums.top(); nums.pop(); int b = nums.top(); nums.pop(); int num = 0; if (c == '+') num = a + b; else if (c == '-') num = b - a; else if (c == '*') num = a * b; else if (c == '/') num = b / a; nums.push(num); } else { ops.push(c); } } } return nums.top(); } };","link":"/2023/02/25/algorithm-train-day11/"},{"title":"代码随想录算法训练营第16天 | 104.二叉树的最大深度, 111.二叉树的最小深度, 222.完全二叉树的节点个数","text":"104.二叉树的最大深度 代码随想录链接 题目 返回给定二叉树的最大深度. 自己的想法 层序遍历一下, 返回最后一层深度. 题解 层序遍历: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int maxDepth(TreeNode* root) { if (!root) return 0; int depth = 0; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); depth++; // 每遍历一层, depth就自增1 for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return depth; } }; 递归法: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int maxDepth(TreeNode* root) { if (!root) return 0; return 1 + max(maxDepth(root -&gt; left), maxDepth(root -&gt; right)); // 左侧节点个数 + 右侧节点个数 + 自身 } }; 111.二叉树的最小深度 代码随想录链接 题目 返回二叉树的最小深度. 自己的想法 层序遍历, 在遇到第一个无左右孩子的节点时, 返回当前深度. 题解 层序遍历: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int minDepth(TreeNode* root) { if (!root) return 0; queue&lt;TreeNode *&gt; que; que.push(root); int level = 0; while (!que.empty()) { level++; int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (!(node -&gt; left) &amp;&amp; !(node -&gt; right)) return level; // 遇到无左右孩子的节点就返回当前深度 if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return level; } }; 递归: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int minDepth(TreeNode* root) { if (root == nullptr) return 0; if ((root -&gt; left == nullptr) &amp;&amp; (root -&gt; right != nullptr)) return 1 + minDepth(root -&gt; right); // 只有右孩子就只计算右子树的最小深度 if ((root -&gt; left != nullptr) &amp;&amp; (root -&gt; right == nullptr)) return 1 + minDepth(root -&gt; left); // 只有左孩子就只计算左子树的最小深度 return 1 + min(minDepth(root -&gt; left), minDepth(root -&gt; right)); // 左右孩子都有就取左右子树的最小值 } }; 222.完全二叉树的节点个数 代码随想录链接 题目 统计给定的完全二叉树有多少个节点. 自己的想法 不管什么遍历, 个数查一下. 但时间复杂度是\\(O(n)\\). 应该要针对于完全二叉树的特性, 使用一些方法来降低时间复杂度. 题解 当做普通二叉树来层序遍历: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int countNodes(TreeNode* root) { if (!root) return 0; int count = 0; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); count++; // 查个数 if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return count; } }; 当做普通二叉树来递归: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int countNodes(TreeNode* root) { if (!root) return 0; return 1 + countNodes(root -&gt; left) + countNodes(root -&gt; right); } }; 针对完全二叉树的特性, 来优化时间复杂度. 完全二叉树的叶子结点一定是积累在最后一层的靠左部分. 其中部分子树是满二叉树, 满足从任意节点出发, 最左下的节点和最后下的节点与出发节点的高度差一致的特性. 可以在计算时, 判断当前节点出发的树是否是满二叉树, 如果是, 用公式计算即可, 如果不是, 再使用类似于上面的递归方法来统计节点个数. 针对完全二叉树的方法: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int countNodes(TreeNode* root) { if (!root) return 0; TreeNode *left = root -&gt; left; TreeNode *right = root -&gt; right; int leftDepth = 0, rightDepth = 0; while (left) { // 最左下节点的高度差 left = left -&gt; left; leftDepth++; } while (right) { // 最右下节点的高度差 right = right -&gt; right; rightDepth++; } if (leftDepth == rightDepth) { // 高度差一致, 说明这个子树是完全二叉树, 快速计算个数 return (2 &lt;&lt; leftDepth) - 1; } return countNodes(root -&gt; left) + countNodes(root -&gt; right) + 1; // 若子树不是完全二叉树, 就递归计算这个子树的个数 } };","link":"/2023/03/02/algorithm-train-day16/"},{"title":"代码随想录算法训练营第13天 | LeetCode - 239.滑动窗口最大值，347.前 K 个高频元素，栈和队列总结","text":"239.滑动窗口最大值 代码随想录链接 题目 LeetCode 239 在给定的一个数组中，进行一个大小为k的滑动窗口的移动，将每次移动过程中窗口的最大值保存下来并返回。 自己的思路 暴力法，然后Time Limit Exceeded. 使用一个队列，随着窗口的移动，队列也同时移动，并且队列的队首应该是当前窗口中的最大值。 要实现这样一个数据结构，需要自己定义一个队列并进行维护。这个队列只需要维护可能成为最大值的元素，保证队列里的元素从大到小进行排列。 在pop时，如果窗口移出的元素等于单调队列的出口元素，则将该元素从队列弹出，否则不进行任何操作；在push时，若窗口加入的元素大于队尾元素，则将队尾的元素依次取出，直到对空或队尾元素大于窗口加入的元素，再将该元素push入队。这样操作后，队首即为当前窗口的最大值。 为了实现这样一个数据结构，即满足需要在队首队尾进行操作的条件，使用deque来实现这个队列最合适。 关于deque和queue的区别，可以参照(这个文章)[https://zhuanlan.zhihu.com/p/77981148] 解法 class MonotonicQueue { // 单调队列 private: deque&lt;int&gt; que; // 使用deque实现 public: void pop(int val) { if (!que.empty() &amp;&amp; que.front() == val) { // 当队列不为空且队首等于滑动窗口移出的值时，弹出队首 que.pop_front(); } } void push (int val) { while (!que.empty() &amp;&amp; val &gt; que.back()) { // 若不满足队尾元素大于窗口加入的元素的条件，就不断弹出队尾直到满足条件后再将该值加入队伍 que.pop_back(); } que.push_back(val); } int front() { // 设计的队列的队首在任意时刻都是对应时刻滑动窗口中的最大值 return que.front(); } }; class Solution { public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { MonotonicQueue mq; vector&lt;int&gt; result; for (int i = 0; i &lt; k; i++) mq.push(nums[i]); // 将前k个数据加入 result.push_back(mq.front()); // 取前k个数据的最大值 for (int i = k; i &lt; nums.size(); i++) { // 使用一个for循环来移动窗口 mq.pop(nums[i - k]); // 从队列中移出滑动窗口移出的值 mq.push(nums[i]); // 将滑动窗口中新加入的值加入队列 result.push_back(mq.front()); // 取此时队列的最大值，并放入结果数组中 } return result; } }; 该方法的时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(k)\\)。 347.前 K 个高频元素 代码随想录链接 题目 LeetCode 347 给定一个数组和一个数字K，返回在该数组中出现频率最高的前k个数字。 自己的思路 统计元素的出现次数可以使用map来实现，而按照出现次数来排列前k个元素可以使用优先级队列。 为什么不用快排来对所有出现的元素的频率进行排序？因为我们最后只求前k个，可以只维护前k个可能的元素就好。 优先级队列在默认情况下是使用大顶堆进行排序，在这个题目中，如果每次更新大顶堆时，都将最大的元素弹出，不能保留高频元素。所以要使用小顶堆，将最小的元素弹出，剩下的才是最大的元素。 解法 class MinHeapComp { // 根据map的结构定义大小如何对比 public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt; &amp;rhs) { return lhs.second &gt; rhs.second; } }; class Solution { public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; map; for (int i : nums) { // 将所有元素的出现次数进行统计 map[i]++; } priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, MinHeapComp&gt; que; // 使用优先级队列来实现小顶堆排序 for (auto it = map.begin(); it != map.end(); it++) { // 遍历map，将map中的值推入 que.push(*it); if (que.size() &gt; k) { // 并弹出多余的元素 que.pop(); } } vector&lt;int&gt; result(k); for (int i = k - 1; i &gt;= 0; i--) { // 不断取小顶堆的值，以倒序的方式，放入结果数组中 result[i] = que.top().first; que.pop(); } return result; } }; 栈和队列总结 理论基础 栈和队列都是容器适配器，其底层实现可以有: vector deque list 不同的实现方式，对于数据的实际存储方式是有影响的。C++中，栈和队列的默认底层实现都是deque。 栈与队列相互实现 例如用栈来实现队列，用队列来实现栈，这种题目考察的是对于栈和队列特性的了解和使用。 例题: 栈实现队列 队列实现栈 括号匹配问题 这是使用栈来解决的经典问题。 例题： 括号匹配问题 字符串去重 将字符串按顺序放到一个串中，若要放入的字符与栈顶相同，就丢弃这两个字符。 例题： 字符串去重 逆波兰表达式 按照逆波兰表达式的顺序求出对应式子的答案，也是栈的经典应用题目。 例题： 逆波兰表达式求解 滑动窗口最大值 这个题目中一个比较重要的应用是单调队列，即单调递增或单调递减的队列。 例题： 滑动窗口最大值 求前k个高频元素 这个题目里面着重讲了优先级队列，优先级队列其实就是个堆，内部元素自动按照元素的权值进行排列。 求前K个高频元素","link":"/2023/02/27/algorithm-train-day13/"},{"title":"代码随想录算法训练营第15天 | 二叉树层序遍历, 226.翻转二叉树, 101.对称二叉树","text":"二叉树层序遍历 二叉树的层序遍历可以通过队列来完成, 要点在于访问一个节点时, 将其左右孩子指针送入队列中. 最基础的层序遍历: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int&gt; levelOrder(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; queue&lt;TreeNode*&gt; que; que.push(root); while (!que.empty()) { TreeNode *node = que.front(); result.push_back(node -&gt; val); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } return result; } }; 就真的只是能得到层序遍历的顺序而已. 如果要在遍历的每层节点处, 分层进行一些操作, 就需要在遍历的时候, 多出一些对于队列的判定. 有明显层次的层序遍历: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; result; if (!root) return result; queue&lt;TreeNode*&gt; que; que.push(root); while (!que.empty()) { vector&lt;int&gt; vec; int qsize = que.size(); // 当前队列的大小即为要遍历的下一层的节点数 for (int i = 0; i &lt; qsize; i++) { // 只遍历这一层, 下一层在下一次while循环内进行遍历 TreeNode *node = que.front(); vec.push_back(node -&gt; val); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } result.push_back(vec); } return result; } }; 在带有层次的层序遍历的代码的基础上, 可以写出很多题目的答案. 如: 102. 二叉树的层序遍历 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; result; if (!root) return result; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty()) { vector&lt;int&gt; vec; int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); vec.push_back(node -&gt; val); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } result.push_back(vec); } return result; } }; 107. 二叉树的层序遍历 II /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; result; if (!root) return result; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); vector&lt;int&gt; levelResult; for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); levelResult.push_back(node -&gt; val); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } result.push_back(levelResult); } reverse(result.begin(), result.end()); // 层序遍历,再把层次逆转一下 return result; } }; 199. 二叉树的右视图 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int&gt; rightSideView(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { // 层序遍历, 但只记录每层最后一个节点 TreeNode *node = que.back(); result.push_back(node -&gt; val); int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return result; } }; 637. 二叉树的层平均值 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;double&gt; averageOfLevels(TreeNode* root) { vector&lt;double&gt; result; if (!root) return result; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { // 层序遍历, 每层节点求和并求平均 int qsize = que.size(); double sum = 0; for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); sum += node -&gt; val; if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } sum /= qsize; result.push_back(sum); } return result; } }; 429. N 叉树的层序遍历 /* // Definition for a Node. class Node { public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; } }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { vector&lt;vector&lt;int&gt;&gt; result; if (!root) return result; queue&lt;Node *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); vector&lt;int&gt; levelResult; for (int i = 0; i &lt; qsize; i++) { Node *node = que.front(); que.pop(); levelResult.push_back(node -&gt; val); // 就是对左右节点的判断, 变成了对于一个指针数组的遍历判断 for (Node *n : node -&gt; children) { if (n) que.push(n); } } result.push_back(levelResult); } return result; } }; 515. 在每个树行中找最大值 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int&gt; largestValues(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); int max = INT_MIN; // 每层记录一个最大值 for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; val &gt; max) max = node -&gt; val; if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } result.push_back(max); } return result; } }; 116. 填充每个节点的下一个右侧节点指针 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public: Node* connect(Node* root) { if (!root) return root; queue&lt;Node *&gt; que; que.push(root); while (!que.empty()) { // 层序遍历, 按照先后加next指针 int qsize = que.size(); if (qsize == 1) { que.front() -&gt; next = NULL; if (que.front() -&gt; left) que.push(que.front() -&gt; left); if (que.front() -&gt; right) que.push(que.front() -&gt; right); que.pop(); } for (int i = 1; i &lt; qsize; i++) { Node *first = que.front(); que.pop(); Node *second = que.front(); first -&gt; next = second; if (first -&gt; left) que.push(first -&gt; left); if (first -&gt; right) que.push(first -&gt; right); if (i == qsize - 1) { que.pop(); if (second -&gt; left) que.push(second -&gt; left); if (second -&gt; right) que.push(second -&gt; right); second -&gt; next == NULL; } } } return root; } }; 117. 填充每个节点的下一个右侧节点指针 II 好像和上面那题代码没差. /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public: Node* connect(Node* root) { if (!root) return root; queue&lt;Node *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); if (qsize == 1) { que.front() -&gt; next = NULL; if (que.front() -&gt; left) que.push(que.front() -&gt; left); if (que.front() -&gt; right) que.push(que.front() -&gt; right); que.pop(); } for (int i = 1; i &lt; qsize; i++) { Node *first = que.front(); que.pop(); Node *second = que.front(); first -&gt; next = second; if (first -&gt; left) que.push(first -&gt; left); if (first -&gt; right) que.push(first -&gt; right); if (i == qsize - 1) { que.pop(); if (second -&gt; left) que.push(second -&gt; left); if (second -&gt; right) que.push(second -&gt; right); second -&gt; next == NULL; } } } return root; } }; 104. 二叉树的最大深度 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int maxDepth(TreeNode* root) { if (!root) return 0; int depth = 0; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { // 就层序遍历的时候加个数数数数 int qsize = que.size(); depth++; for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return depth; } }; 111. 二叉树的最小深度 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int minDepth(TreeNode* root) { if (!root) return 0; queue&lt;TreeNode *&gt; que; que.push(root); int level = 0; while (!que.empty()) { level++; int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (!(node -&gt; left) &amp;&amp; !(node -&gt; right)) return level; // 遇见没有左右孩子的节点就返回当前是几层 if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return level; } }; 做复制完上面这些题之后, 力扣已做题目瞬间+10. 226.翻转二叉树 代码随想录链接 题目 把整个二叉树翻转一下. 自己的想法 可以递归, 可以迭代(层序, 前序(某种意义上的))来完成. 题解一 递归: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: void invert(TreeNode *root) { if (!root) return; // 空节点就什么也不做 swap(root -&gt; left, root -&gt; right); // 交换节点的左右孩子 invert(root -&gt; left); // 对左孩子进行相同操作 invert(root -&gt; right); // 对右孩子进行相同操作 } public: TreeNode* invertTree(TreeNode* root) { invert(root); return root; } }; 题解二 前序迭代, 其实就是在遍历访问的时候, \"访问\"的操作变成了交换左右孩子的操作. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* invertTree(TreeNode* root) { if (!root) return root; stack&lt;TreeNode *&gt; stack; stack.push(root); while (!stack.empty()) { // 使用了昨天提到的统一风格的迭代遍历实现 TreeNode *node = stack.top(); if (node) { stack.pop(); if (node -&gt; right) stack.push(node -&gt; right); if (node -&gt; left) stack.push(node -&gt; left); stack.push(node); stack.push(NULL); } else { stack.pop(); node = stack.top(); stack.pop(); swap(node -&gt; left, node -&gt; right); // 交换左右孩子 } } return root; } }; 题解三 层序遍历, 同样也是把\"访问\"的操作变成了交换左右节点的操作. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* invertTree(TreeNode* root) { if (!root) return root; queue&lt;TreeNode *&gt; que; que.push(root); while (!que.empty()) { int qsize = que.size(); for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); swap(node -&gt; left, node -&gt; right); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return root; } }; 101.对称二叉树 代码随想录链接 题目 判断整个二叉树是否是左右对称的. 自己的想法 先想到的是递归法, 先检查左右孩子是否相同, 再递归地去检查左右孩子起始的子树是否和镜面对应的子树相同 题解一 递归法: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: bool compare(TreeNode *left, TreeNode *right) { if (!left &amp;&amp; !right) return true; if (!left || !right || (left -&gt; val != right -&gt; val)) return false; // 如果左右孩子不同, 则不满足条件 return compare(left -&gt; left, right -&gt; right) &amp;&amp; compare(left -&gt; right, right -&gt; left); // 递归地检查子树. } public: bool isSymmetric(TreeNode* root) { if (!root) return true; return compare(root -&gt; left, root -&gt; right); } }; 题解二 使用队列来记录下次要对比的子树的根: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if (!root) return true; queue&lt;TreeNode *&gt; que; que.push(root -&gt; left); que.push(root -&gt; right); while (!que.empty()) { TreeNode *left = que.front(); // 相邻的两个节点是要对比的对象 que.pop(); TreeNode *right = que.front(); que.pop(); if (!left &amp;&amp; !right) continue; if (!left || !right || (left -&gt; val != right -&gt; val)) return false; que.push(left -&gt; left); // 左孩子的左子树和右孩子的右子树要对比, 一起放入队列 que.push(right -&gt; right); que.push(left -&gt; right); // 左孩子的右子树和右孩子的左子树需要对比, 一起放入队列 que.push(right -&gt; left); } return true; } }; 题解三 相似地, 使用栈来记录下次要对比的字数的根节点: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if (!root) return true; queue&lt;TreeNode *&gt; que; que.push(root -&gt; left); que.push(root -&gt; right); while (!que.empty()) { TreeNode *left = que.front(); // 同样是取两个节点对比 que.pop(); TreeNode *right = que.front(); que.pop(); if (!left &amp;&amp; !right) continue; if (!left || !right || (left -&gt; val != right -&gt; val)) return false; que.push(left -&gt; left); // 同样地将要对比的节点压入栈中 que.push(right -&gt; right); que.push(left -&gt; right); que.push(right -&gt; left); } return true; } };","link":"/2023/03/01/algorithm-train-day15/"},{"title":"代码随想录算法训练营第17天 | 110.平衡二叉树, 257. 二叉树的所有路径, 404.左叶子之和","text":"110.平衡二叉树 代码随想录链接 题目 判断一个二叉树是否是平衡二叉树, 即该二叉树的任意一个子树的左右子树高度差都不超过1. 自己的想法 递归判断左右子树的高度是否满足要求. 题解 递归法： class Solution { private: int getHeight(TreeNode* node) { if (!node) return 0; int leftHeight = getHeight(node -&gt; left); // 递归判断左子树的高度 if (leftHeight == -1) return -1; // 若左子树不平衡，则直接返回-1 int rightHeight = getHeight(node -&gt; right); // 递归判断右子树的高度 if (rightHeight == -1) return -1; // 若右子树不平衡，则直接返回-1 return abs(leftHeight - rightHeight) &gt; 1 ? -1 : 1 + max(leftHeight, rightHeight); // 若左右子树平衡，根据左右子树高度差判断 } public: bool isBalanced(TreeNode* root) { return getHeight(root) == -1 ? false : true; } }; 迭代法： class Solution { private: int getDepth(TreeNode* cur) { // 层序遍历，获得输入节点的高度 if (!cur) return 0; int depth = 0; queue&lt;TreeNode *&gt; que; que.push(cur); while (!que.empty()) { int qsize = que.size(); depth++; for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; left) que.push(node -&gt; left); if (node -&gt; right) que.push(node -&gt; right); } } return depth; } public: bool isBalanced(TreeNode* root) { if (!root) return true; stack&lt;TreeNode *&gt; st; st.push(root); while (!st.empty()) { // 先序遍历 TreeNode *node = st.top(); st.pop(); if (abs(getDepth(node -&gt; left) - getDepth(node -&gt; right)) &gt; 1) { return false; } // 判断左右子树高度差是否大于一 if (node -&gt; right) st.push(node -&gt; right); if (node -&gt; left) st.push(node -&gt; left); } return true; } }; 这个地方的迭代法重复计算了好些层的数值，效率没有上面递归法高。 257.二叉树的所有路径 代码随想录链接 题目 返回从根节点出发到达每个叶子节点的路径。 自己的想法 前序遍历，访问一个节点的操作是判断其是否为叶子节点，若为叶子节点，则从根节点到这个节点的路径记录下来。 题解 递归法： class Solution { private: void traversal(TreeNode *cur, vector&lt;int&gt; &amp;path, vector&lt;string&gt; &amp;result) { path.push_back(cur -&gt; val); // 访问到这个节点时，再将该节点加入路径 if (!(cur -&gt; left) &amp;&amp; !(cur -&gt; right)) { // 如果是叶子节点，就记录路径 string sPath; for (int i = 0; i &lt; path.size() - 1; i++) { sPath += to_string(path[i]); sPath += &quot;-&gt;&quot;; } sPath += to_string(cur -&gt; val); result.push_back(sPath); } if (cur -&gt; left) { // 递归左孩子 traversal(cur -&gt; left, path, result); path.pop_back(); // 递归左子树完毕后，将左孩子从路径中去除 } if (cur -&gt; right) { // 递归右孩子 traversal(cur -&gt; right, path, result); path.pop_back(); // 递归右子树完毕后，将右孩子从路径中去除 } } public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) { vector&lt;string&gt; result; vector&lt;int&gt; path; if (!root) return result; traversal(root, path, result); return result; } }; 迭代法： 前序遍历，并使用栈来记录当前遍历从根节点出发的路径。 class Solution { public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) { vector&lt;string&gt; result; stack&lt;string&gt; pathSt; stack&lt;TreeNode*&gt; st; if (!root) return result; st.push(root); pathSt.push(to_string(root -&gt; val)); while (!st.empty()) { // 使用栈来遍历节点 TreeNode *node = st.top(); st.pop(); string path = pathSt.top(); pathSt.pop(); if (!(node -&gt; left) &amp;&amp; !(node -&gt; right)) { result.push_back(path); } // 如果当前节点是椰子节点, 就记录下来该节点的路径 if (node -&gt; right) { st.push(node -&gt; right); pathSt.push(path + &quot;-&gt;&quot; + to_string(node -&gt; right -&gt; val)); } // 栈内推入节点和节点的路径 if (node -&gt; left) { st.push(node -&gt; left); pathSt.push(path + &quot;-&gt;&quot; + to_string(node -&gt; left -&gt; val)); } } return result; } }; 404.左叶子之和 代码随想录链接 题目 返回给定的二叉树的所有左叶子结点的值之和. 自己的想法 在遍历的时候加一个判断, 如果左孩子存在且是叶子结点, 就将左孩子的值加和. 题解 递归法: class Solution { public: int sumOfLeftLeaves(TreeNode* root) { if (!root) return 0; if (!(root -&gt; left) &amp;&amp; !(root -&gt; right)) return 0; int leftVal = sumOfLeftLeaves(root -&gt; left); // 求左子树中的左叶子结点值之和 if (root -&gt; left &amp;&amp; !(root -&gt; left -&gt; left) &amp;&amp; !(root -&gt; left -&gt; right)) { // 如果左孩子是个叶子结点, 将其值加和 leftVal += root -&gt; left -&gt; val; } int rightVal = sumOfLeftLeaves(root -&gt; right); // 求右子树中左叶子结点值之和 return leftVal + rightVal; } }; 迭代法: class Solution { public: int sumOfLeftLeaves(TreeNode* root) { int result = 0; if (!root) return result; stack&lt;TreeNode *&gt; st; st.push(root); while (!st.empty()) { // 统一写法的中序遍历 TreeNode *node = st.top(); if (node) { st.pop(); st.push(node); st.push(NULL); if (node -&gt; right) st.push(node -&gt; right); if (node -&gt; left) st.push(node -&gt; left); } else { // &quot;访问&quot;一个节点, 判断左孩子是不是叶子结点 st.pop(); node = st.top(); st.pop(); if (node -&gt; left &amp;&amp; !(node -&gt; left -&gt; left) &amp;&amp; !(node -&gt; left -&gt; right)) result += node -&gt; left -&gt; val; } } return result; } };","link":"/2023/03/03/algorithm-train-day17/"},{"title":"代码随想录算法训练营第18天 | 513.找树左下角的值, 112. 路径总和, 113.路径总和ii, 105.从前序与中序遍历序列构造二叉树, 106.从中序与后序遍历序列构造二叉树","text":"513.找树左下角的值 代码随想录链接 题目 给定一颗二叉树, 返回树的最后一层的最左侧叶子结点的值. 自己的想法 迭代法的话就层序遍历, 判断当前访问的一层是否都是叶子节点, 若是, 则输出该层第一个节点的值. 递归法的话就要使用前序遍历了, 在不断往下遍历时, 标记最深的叶子节点. 题解 迭代法: class Solution { public: int findBottomLeftValue(TreeNode* root) { int result = 0; queue&lt;TreeNode *&gt; que; if (!root) return result; que.push(root); while (!que.empty()) { int qsize = que.size(); bool hasChild = false; result = que.front() -&gt; val; // 取该层最左侧节点的值 for (int i = 0; i &lt; qsize; i++) { TreeNode *node = que.front(); que.pop(); if (node -&gt; left) { hasChild = true; que.push(node -&gt; left); } if (node -&gt; right) { hasChild = true; que.push(node -&gt; right); } } if (!hasChild) return result; // 如果本层节点都没有子节点, 则返回本层第一个节点的值 } return result; } }; 递归法: class Solution { private: int maxDepth = INT_MIN; // 记录最大叶子节点的深度, 用于比较 int result; // 最终的值 void traversal(TreeNode *root, int depth) { if (root -&gt; left == NULL &amp;&amp; root -&gt; right == NULL) { // 是叶子节点就和记录进行对比 if (depth &gt; maxDepth) { maxDepth = depth; result = root -&gt; val; } return; } if (root -&gt; left) traversal(root -&gt; left, depth + 1); // 递归遍历左子树 if (root -&gt; right) traversal(root -&gt; right, depth + 1); // 递归遍历右子树 } public: int findBottomLeftValue(TreeNode* root) { traversal(root, 0); return this -&gt; result; } }; 112. 路径总和 113.路径总和ii 代码随想录链接 题目 112题是只要求判断是否有路径之和等于给定值, 而113题要求输出这些路径, 除此之外没有区别. 自己的想法 迭代法的话使用前序遍历, 存储根节点到当前节点的值, 进行判断 递归法同样是使用前序遍历. 题解 112 递归法: class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { if (!root) return false; if (!(root -&gt; left) &amp;&amp; !(root -&gt; right) &amp;&amp; targetSum == root -&gt; val) return true; // 判断当前节点是否符合 return hasPathSum(root -&gt; left, targetSum - root -&gt; val) || hasPathSum(root -&gt; right, targetSum - root -&gt; val); // 将给定值减去当前节点的值, 并递归判断左孩子和右孩子 } }; 112 迭代法: class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { if (!root) return false; stack&lt;pair&lt;TreeNode*, int&gt;&gt; st; // 存储根节点到当前节点的值的栈 st.push(pair&lt;TreeNode*, int&gt;(root, root -&gt; val)); while (!st.empty()) { auto node = st.top(); st.pop(); if (!(node.first -&gt; left) &amp;&amp; !(node.first -&gt; right) &amp;&amp; node.second == targetSum) return true; // 判断当前取出的节点是否符合 if (node.first -&gt; left) st.push(pair&lt;TreeNode*, int&gt;(node.first -&gt; left, node.second + node.first -&gt; left -&gt; val)); // 将左孩子与左孩子的路径值入栈 if (node.first -&gt; right) st.push(pair&lt;TreeNode*, int&gt;(node.first -&gt; right, node.second + node.first -&gt; right -&gt;val)); // 将右孩子与右孩子的路径值入栈 } return false; } }; 113 迭代法: class Solution { public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) { vector&lt;vector&lt;int&gt;&gt; result; if (!root) return result; vector&lt;vector&lt;int&gt;&gt; paths; // 存放节点的路径, 换成栈也可以 stack&lt;pair&lt;TreeNode*, int&gt;&gt; st; // 存放节点和到达它的路径值 st.push(pair&lt;TreeNode*, int&gt;(root, root -&gt; val)); paths.push_back(vector&lt;int&gt;{root -&gt; val}); while (!st.empty()) { auto node = st.top(); st.pop(); auto path = paths.back(); paths.pop_back(); if (!(node.first -&gt; left) &amp;&amp; !(node.first -&gt; right) &amp;&amp; node.second == targetSum) result.push_back(path); // 如果当前取出的节点符合条件, 就将路径记录在结果数组里 if (node.first -&gt; left) { // 左孩子的相关信息记录下来 st.push(pair&lt;TreeNode*, int&gt;(node.first -&gt; left, node.second + node.first -&gt; left -&gt; val)); path.push_back(node.first -&gt; left -&gt; val); paths.push_back(path); path.pop_back(); } if (node.first -&gt; right) { // 右孩子的相关信息记录下来 st.push(pair&lt;TreeNode*, int&gt;(node.first -&gt; right, node.second + node.first -&gt; right -&gt; val)); path.push_back(node.first -&gt; right -&gt; val); paths.push_back(path); } } return result; } }; 105.从前序与中序遍历序列构造二叉树 106.从中序与后序遍历序列构造二叉树 代码随想录链接 题目 根据二叉树的中序和后序遍历构建二叉树 根据二叉树的前序和中序遍历构建二叉树 自己的想法 对于给定中序和后序的情况, 先使用后序的最后一个确定根节点, 然后根据根节点, 在中序数组中划分出来左字数的中序和右子树的中序, 又因为同一棵子树的节点数目是相同的, 也能在后序遍历的数组当中划分出左子树的后序遍历以及右子树的后序遍历. 根据左右子树的两种遍历数组, 递归地进行构建即可. 对于给定前序和中序的情况, 和上面是相似的, 进行划分, 得到左右子树的前序和中序遍历, 再进行递归即可. 题解 105: class Solution { public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { if (inorder.size() != preorder.size()) return NULL; if (!inorder.size()) return NULL; int rootVal = preorder.front(); TreeNode *root = new TreeNode(rootVal); if (inorder.size() == 1) return root; int rootValIndex; for (rootValIndex = 0; rootValIndex &lt; inorder.size(); rootValIndex++) // 找到根节点的位置, 以进行划分 if (inorder[rootValIndex] == rootVal) break; vector&lt;int&gt; leftInOrder(inorder.begin(), inorder.begin() + rootValIndex); // 划分左右子树的前序和中序 vector&lt;int&gt; rightInOrder(inorder.begin() + rootValIndex + 1, inorder.end()); vector&lt;int&gt; leftPreOrder(preorder.begin() + 1, preorder.begin() + rootValIndex + 1); vector&lt;int&gt; rightPreOrder(preorder.begin() + rootValIndex + 1, preorder.end()); root -&gt; left = buildTree(leftPreOrder, leftInOrder); // 递归构建左右子树 root -&gt; right = buildTree(rightPreOrder, rightInOrder); return root; } }; 106: class Solution { public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { if (inorder.size() != postorder.size()) return NULL; if (!inorder.size()) return NULL; int rootVal = postorder.back(); TreeNode *root = new TreeNode(rootVal); if (inorder.size() == 1) return root; int rootValIndex; for (rootValIndex = 0; rootValIndex &lt; inorder.size(); rootValIndex++) // 定位根节点, 以进行划分 if (inorder[rootValIndex] == rootVal) break; vector&lt;int&gt; leftInOrder(inorder.begin(), inorder.begin() + rootValIndex); // 划分左右子树的中序和后序 vector&lt;int&gt; rightInOrder(inorder.begin() + rootValIndex + 1, inorder.end()); vector&lt;int&gt; leftPostOrder(postorder.begin(), postorder.begin() + rootValIndex); vector&lt;int&gt; rightPostOrder(postorder.begin() + rootValIndex, postorder.end() - 1); root -&gt; left = buildTree(leftInOrder, leftPostOrder); // 递归构建左右子树 root -&gt; right = buildTree(rightInOrder, rightPostOrder); return root; } };","link":"/2023/03/04/algorithm-train-day18/"},{"title":"代码随想录算法训练营第2天 |  977.有序数组的平方，209.长度最小的子数组，59.螺旋矩阵II","text":"977.有序数组的平方 代码随想录链接 题目 LeetCode-977 给定一个顺序不减的有序数组A，返回一个由A数组中每个值的平方组成的顺序不减数组。 自己的思考 可能还是倾向于暴力法一点，有看到提示说可以用双指针法，但是自己也没想明白应该怎么用(我好蔡啊.jpg) 解法一 暴力法，先就原地计算出来每一项的平方是多少，覆盖到原位置，然后再排个序。 #include&lt;algorithm&gt; class Solution { public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { for (int i = 0; i &lt; nums.size(); i++) { // 遍历每个值 nums[i] *= nums[i]; // 求出平方值，写入原位置 } sort(nums.begin(), nums.end()); // 调用C++的sort函数进行排序 return nums; } }; 一个for循环遍历数组，时间复杂度为\\(O(n)\\)，C++的sort函数是基于快速排序的优化算法，时间复杂度为\\(O(nlogn)\\)。 使用了常数个变量，空间复杂度为\\(O(1)\\)。 解法二 双指针法，类似于昨天的题目，使用两个指针来完成。 为什么可以使用双指针法呢？要题目给定的条件出发。 题目给定的数组是顺序不减进行排列的，求得平方值值后需要调整位置的情况，只存在于原数组左侧的负数，平方之后应该被排在右侧的某个位置，而原数组和结果数组的右侧都是较大的值。由这个条件，我们可以使用双指针法，对比两个指针指向的值的平方，较大的值，应该依次从右至左写入到结果数组内。 #include&lt;algorithm&gt; #include&lt;cmath&gt; class Solution { public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; result(nums.size(), 0); // 声明并实例化一个新的数组，大小和原数组一样，并均用0填充 int leftIndex = 0, rightIndex = nums.size() - 1, resultIndex = nums.size() - 1; // 声明原数组的左右指针，以及结果数组的指针 while(leftIndex &lt;= rightIndex) { // 循环条件 if (pow(nums[leftIndex], 2) &gt; pow(nums[rightIndex], 2)) { // 若左指针指向的数的平方值要大于右指针指向的数的平方值 result[resultIndex--] = pow(nums[leftIndex++], 2); // 将左指针的值写入到目标数组,并移动左指针和结果数组的指针 } else { result[resultIndex--] = pow(nums[rightIndex--], 2); // 否则，就将右指针指向的数的平方值写入结果数组，并相应调整两个指针 } } return result; } }; 算法中while的循环次数和数组的大小线性相关，时间复杂度为\\(O(n)\\)。 由于使用了一个新的且和原数组大小一致的数组，空间复杂度为\\(O(n)\\)。 209.长度最小的子数组 代码随想录链接 题目 LeetCode-209 自己的思考 暴力法（蔡啊） 失败案例 使用两个for循环，计算并对比从第一个for循环的索引指向的数开始的每个子序列是否符合条件，若符合条件，记录下最短值。 class Solution { public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int result = INT32_MAX; int sum = 0; int subLength = 0; for (int i = 0; i &lt; nums.size(); i++) { // 外层for循环，其索引用于标记子序列的开头 sum = 0; for (int j = i; j &lt; nums.size(); j++) { // 内层for循环，j表示当前判断的子序列的末尾索引 sum += nums[j]; // 将当前位置的值加入 if (sum &gt;= target) { // 若满足了大于等于目标值的条件，就计算并对比是否是最短子序列 subLength = j - i + 1; result = result &lt; subLength ? result : subLength; break; // 都找到满足的了，再往后找，子序列就变更长了，该考虑以下一位数据开头的子序列了 } } } return result == INT32_MAX ? 0 : result; // 如果result还是初始值，代表没有找到合适的子序列，按题目要求返回0 } }; 很不幸，由于这个写法的时间复杂度为\\(O(n^2)\\)，没有AC，超时了 LeetCode-209-寄 正确解法 滑动窗口法 什么是滑动窗口呢，这里给出一个百科链接，讲述的是TCP协议中的滑动窗口。 下面我用自己的语言描述一下滑动窗口。所谓滑动窗口，是指在序列中取一段子序列，其前后边界是可以随时按照情况进行灵活调整的。 但如果仍然使用上面的两个for循环来表示起始和终止位置的话，那和“灵活”两个字怕是要说再见了。 可以仅适用一个for循环来表示后指针，在循环内，对左指针进行调整。这里偷一个代码随想录网站上的动图，来更好地说明滑动窗口。 滑动窗口动图示意，图来自代码随想录 class Solution { public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int result = INT32_MAX; int sum = 0; int subLength = 0; int leftIndex = 0; // 左指针 for (int rightIndex = 0; rightIndex &lt; nums.size(); rightIndex++) { // 右指针 sum += nums[rightIndex]; // 移动右指针之后，更新当前窗口内元素之和 while (sum &gt;= target) { // 若当前窗口之和符合条件，则进入判断，若不符合条件，则进入for循环的下一次循环 subLength = rightIndex - leftIndex + 1; // 计算当前窗口的长度，并与记录值对比，若小于记录的长度值，则更新记录值 result = result &lt; subLength ? result : subLength; sum -= nums[leftIndex++]; // 将窗口左侧向右移动 } } return result == INT32_MAX ? 0 : result; } }; 这个解法使用了一个for循环来遍历数组，for循环内又有一个while循环，所以时间复杂度是\\(O(b^2)\\)，但是while循环执行一次，左指针就会向右移动一次，而左指针移动的次数是和数组的长度是线性相关的，所以整个过程中while循环的执行次数是\\(O(n)\\)，与for循环的次数无关。 故该解法的时间复杂度为\\(O(2 * n) = O(n)\\)。 使用了常数个变量，空间复杂度为\\(O(1)\\)。 59.螺旋矩阵II 代码随想录链接 题目 LeetCode-59 给定一个正整数n，以顺时针方向螺旋填充\\(n * n\\)的一个矩阵 自己的思考 这题本科的时候绝对做过。需要设定一些控制变量，用于记录当前填充的坐标，但是怎么设置控制变量，是非常关键的地方，然后想不出来了 解法 在设计控制变量的时候，要考虑好在什么条件下，需要按照上右下左四个边的顺序进行进行下一个边的填充。 还要考虑到填充的时候，边与边的重叠部分，应该怎么处理，比如： 重叠部分由当前边填写 由下一个边填写 当然甚至还可以： + 两个边都填写，然后再调整要填写的数字 这里选择由下一个边填写的方法，原因是在完成一个loop之后，下一个loop开始的位置比较容易计算。 class Solution { public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; result(n, vector&lt;int&gt;(n, 0)); // 结果矩阵 int startx = 0, starty = 0; // 下一个loop开始时的坐标 int offset = 1; // 控制填写一条边的时候，应该剩下几个位置不填写，offset初始为1即表示重叠部分在下一个边填写 int loop = n / 2; // 需要进行多少次螺旋 int mid = n / 2; // 计算是否需要对最中间的位置单独进行填充 int count = 1; // 记录下次填充的数字 int i, j; // 当前填充的位置坐标 while (loop--) { i = startx; // 自左上方开始的横纵坐标 j = starty; for (j = starty; j &lt; n - offset; j++) result[i][j] = count++; // 填写上边 for (i = startx; i &lt; n - offset; i++) result[i][j] = count++; // 填写右边 for (; j &gt; starty; j--) result[i][j] = count++; // 填写下边，这里的 j &gt; starty 也是为了控制重叠部分在下一条边填写 for (; i &gt; startx; i--) result[i][j] = count++; // 填写左边，这里的 i &gt; startx 同上理 startx++; // 完成一次四边填写后，调整起始位置 starty++; offset++; // 完成一次四边填写，offset应该+1来控制上边和右边的填写不覆盖掉之前填写的内容 } if (n % 2) result[mid][mid] = count; // 若 n 为基数，需要针对中心位置单独填写 return result; } }; 代码时间复杂度为\\(O(n^2)\\)，空间复杂度为\\(O(n^2)\\)。 数组总结 在这个数组的专题内，学习到的方法主要有 二分法 用于查找，主要思想是在有序的数组里，通过左边界和有边界计算出来区间中间位置，根据中间位置的数据与目标数据的大小关系来调整下一次寻找的左右区间。 关键的一点是坚持自己刚开始设定的对于区间的定义（是左闭右开、左开右闭亦或是左闭右闭），并贯穿到所写题目的整个代码当中。 时间复杂度为\\(O(logn)\\) 例题：LeetCode-704 二分查找 双指针法 顾名思义，使用两个指针在一个for循环下，完成两个for循环的工作，使得时间复杂度降低。 双指针法既可以是同时从一个方向起步，例如LeetCode-27；也可以是分别从数组的开始和末尾向中间靠拢，例如LeetCode-977 双指针法还经常在链表中使用。 滑动窗口 滑动窗口可以用于求一个数组中子序列之用，相比于暴力法显著地降低了时间复杂度。 要理解滑动窗口，关键之处就在于理解窗口的起始位置和结束位置是怎么调整的。例题：LeetCode-209 本文上面的部分有滑动窗口的示意图。 模拟行为 例如模拟螺旋填充矩阵。这类题目主要考察对于代码循环边界控制的能力。要做好这类题目，关键是需要坚持好边界上的处理方法，从一而终。","link":"/2023/02/16/algorithm-train-day2/"},{"title":"代码随想录算法训练营第21天 | 530.二叉搜索树的最小绝对差, 501.二叉搜索树中的众数, 236. 二叉树的最近公共祖先","text":"530.二叉搜索树的最小绝对差 代码随想录链接 题目 返回给定的二叉搜索树内, 节点之间最小的差值. 自己的思路 二叉搜索树的中序遍历的结果是有序的, 在其中中找相邻值最小的即可. 题解 递归法: class Solution { private: vector&lt;int&gt; result; void traversal(TreeNode *root) { // 中序遍历, 记录结果 if (!root) return; traversal(root -&gt; left); result.push_back(root -&gt; val); traversal(root -&gt; right); } public: int getMinimumDifference(TreeNode* root) { traversal(root); int minGap = INT_MAX; for (int i = 1; i &lt; result.size(); i++) // 找相邻数据最小的差值 if (result[i] - result[i - 1] &lt; minGap) minGap = result[i] - result[i - 1]; return minGap; } }; 迭代法: class Solution { public: int getMinimumDifference(TreeNode* root) { if (!root) return 0; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; st.push(root); while (!st.empty()) { // 中序遍历 TreeNode *node = st.top(); if (node) { st.pop(); if (node -&gt; right) st.push(node -&gt; right); st.push(node); st.push(nullptr); if (node -&gt; left) st.push(node -&gt; left); } else { st.pop(); node = st.top(); st.pop(); result.push_back(node -&gt; val); } } int minGap = INT_MAX; for (int i = 1; i &lt; result.size(); i++) // 找最小差值 if (result[i] - result[i - 1] &lt; minGap) minGap = result[i] - result[i - 1]; return minGap; } }; 501.二叉搜索树中的众数 代码随想录链接 题目 给定一个二叉搜索树, 返回其中的众数. 自己的思路 可以将全部节点遍历一遍, 通过map记录出现次数, 再进行排序得到, 但这样就和普通的二叉树没区别了. 二叉搜索树的中序遍历是有序的, 相同的数都会排在一起, 可以通过这个特性, 在中序遍历的基础上, 找到众数. 题解 递归法: class Solution { private: int maxCount = 0; // 统计出现次数最多的值出现了几次 int count = 0; // 统计当前值出现了几次 TreeNode *pre = NULL; // 标记上一个访问的节点, 判断和当前访问节点的值是否相等 vector&lt;int&gt; result; void searchBST(TreeNode *cur) { // 中序遍历 if (cur == NULL) return; searchBST(cur -&gt; left); if (pre == NULL) count = 1; // 第一个节点, pre为空的情况的处理 else if (pre -&gt; val == cur -&gt; val) count++; // 与上一个遍历的节点的值相同, 当前值出现次数+1 else count = 1; // 遇上一个点值不同, 重置出现次数 pre = cur; // pre后移 if (count == maxCount) result.push_back(cur -&gt; val); // 当前值统计次数和最大次数一致, 是可能得众数, 加入结果中 if (count &gt; maxCount) { // 若当前值出现的次数超过了前面值出现最多的次数, 证明众数的要求提高了 maxCount = count; // 更新maxCount result.clear(); // 之前的数都不是众数 result.push_back(cur -&gt; val); } searchBST(cur -&gt; right); } public: vector&lt;int&gt; findMode(TreeNode* root) { searchBST(root); return this -&gt; result; } }; 迭代法: (也是中序遍历, 甚至直接把上面对于中序遍历的中间节点的处理直接复制过来都没问题) class Solution { public: vector&lt;int&gt; findMode(TreeNode* root) { vector&lt;int&gt; result; if (!root) return result; int maxCount = 0; int count = 0; TreeNode *pre = nullptr; stack&lt;TreeNode*&gt; st; st.push(root); while (!st.empty()) { TreeNode *node = st.top(); if (node) { st.pop(); if (node -&gt; right) st.push(node -&gt; right); st.push(node); st.push(NULL); if (node -&gt; left) st.push(node -&gt; left); } else { // 和递归法中一样的处理思路 st.pop(); node = st.top(); st.pop(); if (pre == NULL) count = 1; else if (pre -&gt; val == node -&gt; val) count++; else count = 1; pre = node; if (count == maxCount) result.push_back(node -&gt; val); if (count &gt; maxCount) { maxCount = count; result.clear(); result.push_back(node -&gt; val); } } } return result; } }; 236. 二叉树的最近公共祖先 代码随想录链接 题目 给定一棵二叉树和其中的两个节点, 返回离这两个节点最近的公共祖先. 自己的思路 自己是想按照之前写二叉树的所有叶子路径那样来写这个题, 确实也实现了, 但是提交的时候就超时了. 看了卡尔哥的写法, 才发现不用写我那样复杂. 题解 自己想的通过遍历并记录路径来做的方法: class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(!root) return nullptr; vector&lt;vector&lt;TreeNode*&gt;&gt; paths; // 记录节点的路径 vector&lt;TreeNode*&gt; p_path; // 记录p节点的路径 vector&lt;TreeNode*&gt; q_path; // 记录q节点的路径 stack&lt;TreeNode*&gt; st; // 用于遍历的栈 st.push(root); paths.push_back(vector&lt;TreeNode*&gt;{root}); bool hasFoundp = false; // 是否找到节点的标记 bool hasFoundq = false; while (!st.empty() &amp;&amp; (!hasFoundp || !hasFoundq)) { // 如果栈不为空, 且q p没有全部找到, 则继续遍历 auto node = st.top(); st.pop(); auto path = paths.back(); paths.pop_back(); if (!hasFoundp &amp;&amp; node == p) { // 如果找到了p节点, 就标记p的路径 hasFoundp = true; copy(path.begin(), path.end(), back_inserter(p_path)); } if (!hasFoundq &amp;&amp; node == q) { // 找到了q节点, 标记q的路径 hasFoundq = true; copy(path.begin(), path.end(), back_inserter(q_path)); } if (node -&gt; right) { // 右节点和其路径压栈 st.push(node -&gt; right); path.push_back(node -&gt; right); paths.push_back(path); path.pop_back(); } if (node -&gt; left) { // 左节点和其路径压栈 st.push(node -&gt; left); path.push_back(node -&gt; left); paths.push_back(path); } } int pathLength = min(p_path.size(), q_path.size()); for (int i = 1; i &lt; pathLength; i++) { // 找p, q路径中最后一个相同的节点 if (p_path[i] != q_path[i]) return p_path[i - 1]; } if (p_path[pathLength - 1] == q_path[pathLength - 1]) return p_path[pathLength - 1]; // 路径中最后一个节点相同, 则返回最后一个节点 return root; } }; 卡尔哥的思路: 其实就是通过后序递归, 先找到p, q节点, 如果从左右子树里都找到了p, q, 那么在递归中首先满足这个条件的节点, 一定就是二者的最近公共祖先. class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == q || root == p || !root) return root; // 如果该节点为空, 或者为p, 或q, 就返回该节点 TreeNode *left = lowestCommonAncestor(root -&gt; left, p, q); // 在左子树中找p, q的最近公共祖先 TreeNode *right = lowestCommonAncestor(root -&gt; right, p, q);// 在右子树中找 if (left &amp;&amp; right) return root; // 左右有p, q的存在, 本节点一定是祖先 if (left &amp;&amp; !right) return left;// 左子树中有目标节点, 返回左子树中的目标节点 if (!left &amp;&amp; right) return right;// 右子树中有目标节点, 返回右子树中的目标节点 return NULL; } };","link":"/2023/03/07/algorithm-train-day21/"},{"title":"代码随想录算法训练营第20天 | 654.最大二叉树, 617.合并二叉树, 700.二叉搜索树中的搜索, 98.验证二叉搜索树","text":"654.最大二叉树 代码随想录链接 题目 根据一个给定的数组, 使用数组中的最大值建立一个根节点, 再使用数组中最大值左侧的部分建立左子树, 使用数组中最大值右侧的部分建立右子树. 自己的想法 题目就很递归, 且给人的感觉像是前序遍历. 题解 递归法: class Solution { public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return NULL; if (nums.size() == 1) return new TreeNode(nums[0]); // 特殊情况处理 int pivotIndex = 0, maxVal = INT_MIN; for (int i = 0; i &lt; nums.size(); i++) // 找最大值并根据最大值建立新节点. if (nums[i] &gt; maxVal) { maxVal = nums[i]; pivotIndex = i; } TreeNode *root = new TreeNode(nums[pivotIndex]); vector&lt;int&gt; leftTreeNodes(nums.begin(), nums.begin() + pivotIndex); // 左右分区 vector&lt;int&gt; rightTreeNodes(nums.begin() + pivotIndex + 1, nums.end()); root -&gt; left = constructMaximumBinaryTree(leftTreeNodes); // 递归地建立左右子树 root -&gt; right = constructMaximumBinaryTree(rightTreeNodes); return root; } }; 优化版的递归法: (主要优化在了没有建立新的数组, 每次递归时, 直接在原数组上进行分区) class Solution { private: TreeNode* constructMaximumBinaryTreeRecursive(vector&lt;int&gt;&amp;nums, int left, int right) { if (left &gt;= right) return NULL; // 分区采用左闭右开区间, 左侧边界不能大于等于右侧边界 int pivotIndex = left, maxVal = INT_MIN; // 找分区中最大值并建立新节点 for (int i = left; i &lt; right; i++) if (nums[i] &gt; maxVal) { maxVal = nums[i]; pivotIndex = i; } TreeNode *root = new TreeNode(nums[pivotIndex]); root -&gt; left = constructMaximumBinaryTreeRecursive(nums, left, pivotIndex); // 根据分区建立左右子树 root -&gt; right = constructMaximumBinaryTreeRecursive(nums, pivotIndex + 1, right); return root; } public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { return constructMaximumBinaryTreeRecursive(nums, 0, nums.size()); } }; 617.合并二叉树 代码随想录链接 题目 合并两棵二叉树, 如果位置相同的节点都存在的话, 则进行值的相加, 如果一棵树的子树不存在, 则将另外一棵树上相同位置的子树复制过来. 自己的想法 两棵树一起前/中/后序遍历, 都存在则值相加, 有一棵树不存在某侧子树则使用另一棵的进行覆盖. 题解 递归法:(作为懒狗只写了中序遍历, 前序和后序只需要调整值相加的语句的位置就能完成) class Solution { private: TreeNode* traversal(TreeNode *root1, TreeNode* root2) { if (!root1 &amp;&amp; !root2) return nullptr; if (root1 &amp;&amp; !root2) return root1; // 处理一棵树上的一侧子树不存在而另一棵树上相应子树存在的情况 if (!root1 &amp;&amp; root2) return root2; root1 -&gt; left = traversal(root1 -&gt; left, root2 -&gt; left); // 递归合并左子树 root1 -&gt; val += root2 -&gt; val; root1 -&gt; right = traversal(root1 -&gt; right, root2 -&gt; right); // 递归合并右子树 return root1; } public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { return traversal(root1, root2); } }; 迭代法:(把要比较的节点成对地入栈比较, 像101.对称二叉树那题一样) class Solution { public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { if (!root1) return root2; if (!root2) return root1; stack&lt;TreeNode*&gt; st; st.push(root2); st.push(root1); while (!st.empty()) { TreeNode *node1 = st.top(); st.pop(); // 连取两个节点进行对比 TreeNode *node2 = st.top(); st.pop(); node1 -&gt; val += node2 -&gt; val; // 两个节点进行值相加 if (node1 -&gt; left &amp;&amp; node2 -&gt; left) { // 都存在左子树, 左子树入栈合并 st.push(node2 -&gt; left); st.push(node1 -&gt; left); } if (node1 -&gt; right &amp;&amp; node2 -&gt; right) { // 都存在右子树, 右子树入栈合并 st.push(node2 -&gt; right); st.push(node1 -&gt; right); } if (!(node1 -&gt; left) &amp;&amp; node2 -&gt; left) {// 处理一侧不存在的情况 node1 -&gt; left = node2 -&gt; left; } if (!(node1 -&gt; right) &amp;&amp; node2 -&gt; right) { node1 -&gt; right = node2 -&gt; right; } } return root1; } }; 700.二叉搜索树中的搜索 代码随想录链接 题目 在二叉搜索树中找到带有给定值的节点. 自己的想法 就...搜呗, (根节点)大了往左边找, 小了往右边找. 题解 递归法: class Solution { private: TreeNode* traversal(TreeNode* root, int val) { if (!root) return nullptr; if (root -&gt; val == val) return root; // 符合了就这个节点 if (root -&gt; val &gt; val) return traversal(root -&gt; left, val); // 大了往左边找 if (root -&gt; val &lt; val) return traversal(root -&gt; right, val);// 小了往右边找 return nullptr; // &quot;我不到啊&quot; } public: TreeNode* searchBST(TreeNode* root, int val) { return traversal(root, val); } }; 迭代法: class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { if (!root) return nullptr; TreeNode *cur = root; // 像不像遍历链表那样 while (cur) { if (cur -&gt; val == val) return cur; if (cur -&gt; val &gt; val) cur = cur -&gt; left; // 大了往左边找 else cur = cur -&gt; right; // 小了往右边找 } return nullptr; // 没找到 } }; 98.验证二叉搜索树 代码随想录链接 题目 判断给定的二叉树是否是二叉搜索树. 自己的想法 刚开始甚至还写了递归地判断左右孩子和遍历到的节点的大小关系, 这种情况就是忘了整个子树都要比根节点大/小的关系了. 自然是不行的. 看了题目的一些分析, 才回忆起来可以通过中序遍历的结果来进行判断, 又是王道上的题.都还回去了呜呜呜 题解 其实就中序遍历, 再加个遍历结果单调性的判断. 递归法: class Solution { private: vector&lt;int&gt; result; void traversal(TreeNode *root) { if (!root) return; traversal(root -&gt; left); result.push_back(root -&gt; val); // 中序遍历 traversal(root -&gt; right); } public: bool isValidBST(TreeNode* root) { traversal(root); for (int i = 1; i &lt; result.size(); i++) { // 遍历结果单调性判断 if (result[i] &lt;= result[i - 1]) return false; } return true; } }; 迭代法: class Solution { public: bool isValidBST(TreeNode* root) { if (!root) return true; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; st.push(root); while (!st.empty()) { // 中序遍历 TreeNode *node = st.top(); if (node) { st.pop(); if (node -&gt; right) st.push(node -&gt; right); st.push(node); st.push(NULL); if (node -&gt; left) st.push(node -&gt; left); } else { st.pop(); node = st.top(); st.pop(); result.push_back(node -&gt; val); } } for (int i = 1; i &lt; result.size(); i++) // 遍历结果单调性判断 if (result[i] &lt;= result[i - 1]) return false; return true; } };","link":"/2023/03/06/algorithm-train-day20/"},{"title":"代码随想录算法训练营第23天 | 669.修剪二叉搜索树, 108.将有序数组转换为二叉搜索树, 538.把二叉搜索树转换为累加树, 二叉树总结","text":"669.修剪二叉搜索树 代码随想录链接 题目 LeetCode-669.修剪二叉搜索树 给定一个二叉搜索树和一个左闭右闭的区间, 要求将二叉搜索树中不符合的节点去除, 并保持在树中节点的相对位置. 自己的想法 刚开始是想着和昨天的题目一样, 遇见一个不符合的节点就把这个节点删掉, 试着写了一分代码, 全是Run Time Error. 在看卡尔哥的写法时, 发现自己做题目还是忽略了好些二叉搜索树的性质, 没有真正去理解(也可能是上午刷题太困了) 个人感觉这道题目非常重要的一点是: 如果遇到一个节点的值在给定区间左侧(i.e. 值小于整个区间), 那么其左子树必定是要被删除的; 同理, 如果一个节点的值在给定区间的右侧(i.e. 值大于整个区间), 那么其右子树是必定会被删除的, 可以直接忽略. 题解 递归法: class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { if (root == nullptr) return root; // 空指针直接返回 if (root -&gt; val &gt; high) return trimBST(root -&gt; left, low, high); // 如果节点值在区间右侧, 则抛弃该节点和其右子树, 用剪枝后的左子树来代替当前节点 if (root -&gt; val &lt; low) return trimBST(root -&gt; right, low, high); // 如果节点值在区间左侧, 则抛弃该节点和其左子树, 用剪枝后的右子树来代替当前节点 root -&gt; left = trimBST(root -&gt; left, low, high); // 如果当前节点的值符合要求, 就再对左右子树进行剪枝 root -&gt; right = trimBST(root -&gt; right, low, high); return root; } }; 迭代法: class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { if (!root) return root; while (root &amp;&amp; (root -&gt; val &gt; high || root -&gt; val &lt; low)) { // 如果根节点不在目标范围内, 就移动根节点, 同时相应地抛弃一侧的子树(因为该侧子树和根节点一样, 都在给定范围之外) if (root -&gt; val &gt; high) root = root -&gt; left; else root = root -&gt; right; } TreeNode *cur = root; // 访问子树节点的指针 while (cur) { // 从根节点, 沿着左指针找下去 while (cur -&gt; left &amp;&amp; cur -&gt; left -&gt; val &lt; low) { // 找到一个不符合条件的节点, 使用其右子树来代替该节点和其左子树, 直至该位置的节点在范围内 cur -&gt; left = cur -&gt; left -&gt; right; } cur = cur -&gt; left; } cur = root; // 从根节点再次向右找不符合的节点 while (cur) { while (cur -&gt; right &amp;&amp; cur -&gt; right -&gt; val &gt; high) { // 找到一个不符合条件的节点, 使用其左子树来代替该节点和其右子树, 直至该位置的节点在范围内 cur -&gt; right = cur -&gt; right -&gt; left; } cur = cur -&gt; right; } return root; } }; 108.将有序数组转换为二叉搜索树 代码随想录链接 题目 LeetCode-108.将有序数组转换为二叉搜索树 将一个给定的有序数组转化为一棵平衡二叉树. 自己的想法 像从中序和后序遍历结果构建二叉树那样, 去区间中值, 左右两侧分别递归就可以. 题解 递归法: class Solution { private: TreeNode* traversal(vector&lt;int&gt; &amp;nums, int left, int right) { if (left &gt; right) return nullptr; int mid = left + (right - left) / 2; // 取中间值 TreeNode *node = new TreeNode(nums[mid]); // 建立中间节点 node -&gt; left = traversal(nums, left, mid - 1); // 左侧递归 node -&gt; right = traversal(nums, mid + 1, right); // 右侧递归 return node; // 返回子树 } public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { TreeNode *root = traversal(nums, 0, nums.size() - 1); return root; } }; 迭代法: 使用三个队列, 分别记录子树的根节点, 这棵子树的左区间, 以及这棵子树的右区间. class Solution { public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return nullptr; TreeNode *root = new TreeNode(0); queue&lt;TreeNode*&gt; nodeQue; // 子树根节点, 赋值操作在下面完成 queue&lt;int&gt; leftIndexes, rightIndexes; // 相应位置的子树的左右区间 nodeQue.push(root); // 推入根节点 leftIndexes.push(0); // 推入左区间 rightIndexes.push(nums.size() - 1); // 推入右区间 while (!nodeQue.empty()) { TreeNode *cur = nodeQue.front(); nodeQue.pop(); // 取子树的根节点和其左右区间 int left = leftIndexes.front(); leftIndexes.pop(); int right = rightIndexes.front(); rightIndexes.pop(); int mid = left + (right - left) / 2; // 求区间中值索引 cur -&gt; val = nums[mid]; // 给子树根节点赋值 if (left &lt; mid) { // 给左子树建立根节点并推入节点队列, 推入左子树的区间 cur -&gt; left = new TreeNode(0); nodeQue.push(cur -&gt; left); leftIndexes.push(left); rightIndexes.push(mid - 1); } if (right &gt; mid) { // 给右子树建立根节点并推入节点队列, 推入右子树的区间 cur -&gt; right = new TreeNode(0); nodeQue.push(cur -&gt; right); leftIndexes.push(mid + 1); rightIndexes.push(right); } } return root; } }; 能不能用栈来代替队列呢? 可以的, 无非就是使用队列时, 构建节点的顺序是从上至下, 从左至右; 使用栈时的顺序是从下至上, 从右至左. 538.把二叉搜索树转换为累加树 代码随想录链接 题目 LeetCode-538.把二叉搜索树转换为累加树 将二叉搜索树中每个节点的值都修改为整棵树中大于等于自己的节点的值之和. 自己的想法 中序遍历, 想着先遍历一下, 保存一个指针的数组, 再计算一堆应该修改的数, 最后通过遍历保存的数组把值给修改了.Too yong too simple, sometimes naive 其实中序遍历反过来就可以一次遍历完成操作, 反过来的操作刚好是由大到小遍历二叉搜索树. 题解 递归法: class Solution { private: int sum = 0; void traversal(TreeNode *root) { if (!root) return; traversal(root -&gt; right); // 遍历右子树 sum += root -&gt; val; // 修改和 root -&gt; val = sum; // 赋值节点 traversal(root -&gt; left); // 遍历右子树 } public: TreeNode* convertBST(TreeNode* root) { traversal(root); return root; } }; 迭代法: 同样也是中序遍历反过来. class Solution { public: TreeNode* convertBST(TreeNode* root) { if (!root) return root; stack&lt;TreeNode*&gt; st; int sum = 0; st.push(root); while (!st.empty()) { TreeNode *node = st.top(); if (node) { st.pop(); if (node -&gt; left) st.push(node -&gt; left); st.push(node); st.push(NULL); if (node -&gt; right) st.push(node -&gt; right); } else { st.pop(); node = st.top(); st.pop(); sum += node -&gt; val; // 修改和 node -&gt; val = sum; // 赋值 } } return root; } }; 二叉树总结 代码随想录链接 二叉树算是代码随想录里第一个这么长的篇章吧. 总共60天的训练营, 后面37天都是回溯法动态规划贪心算法, 只能说是很刺激了.","link":"/2023/03/09/algorithm-train-day23/"},{"title":"代码随想录算法训练营第22天 | 235.二叉搜索树的最近公共祖先, 701.二叉搜索树中的插入操作, 450.删除二叉搜索树中的节点","text":"235. 二叉搜索树的最近公共祖先 代码随想录链接 题目 235.二叉搜索树的最近公共祖先 给定一个二叉搜索树和两个指定节点, 在这个二叉树中找到这两个指定节点的最近公共祖先. 自己的想法 和昨天的236题一样, 使用递归法来找这两个节点的最近公共祖先, 实测昨天的代码也是可以直接AC的. 但这没有利用到二叉树的特性. 二叉树的特性的存在, 使得找节点更有方向性. 当前遍历节点的值小于两个目标节点, 则向遍历节点的右侧查找; 否则就向左侧查找. 题解 递归法: class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (!root) return NULL; if (root -&gt; val &gt; p -&gt; val &amp;&amp; root -&gt; val &gt; q -&gt; val) return lowestCommonAncestor(root -&gt; left, p, q); // 节点值大于两个目标节点, 向左侧查找 if (root -&gt; val &lt; p -&gt; val &amp;&amp; root -&gt; val &lt; q -&gt; val) return lowestCommonAncestor(root -&gt; right, p, q); // 节点值小于两个目标节点, 向右侧查找 return root; // 若落在两个节点的区间内, 则为要找的节点 } }; 迭代法: class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { while (root) { if (root -&gt; val &gt; p -&gt; val &amp;&amp; root -&gt; val &gt; q -&gt; val) root = root -&gt;left; // 节点值大于两个目标节点, 向左侧查找 else if (root -&gt; val &lt; p -&gt; val &amp;&amp; root -&gt; val &lt; q -&gt; val) root = root -&gt; right; // 节点值小于两个目标节点, 向右侧查找 else return root; // 若落在两个节点的区间内, 则为要找的节点 } return root; } }; 701.二叉搜索树中的插入操作 代码随想录链接 题目 701.二叉搜索树中的插入操作 向二叉搜索树种插入含有给定值的节点. 自己的想法 题目没有要求是平衡二叉树, 所以直接按照大小顺序遍历到一个空位置进行插入即可. 题解 递归法: class Solution { private: void traversal(TreeNode* cur, TreeNode* pre, int val) { // pre 标记上一个节点 if (cur == NULL) { // 当前节点不存在, 则给上一个节点插入一个包含给定值的孩子节点 TreeNode *node = new TreeNode(val); if (val &gt; pre -&gt; val) pre -&gt; right = node; else pre -&gt; left = node; return; } if (cur -&gt; val &gt; val) traversal(cur -&gt; left, cur, val); // 给定值大于当前节点值, 向左找空位 if (cur -&gt; val &lt; val) traversal(cur -&gt; right, cur, val); // 给定值小于当前节点值, 向右找空位 return; } public: TreeNode* insertIntoBST(TreeNode* root, int val) { if (!root) root = new TreeNode(val); else traversal(root, NULL, val); return root; } }; 迭代法: (和二叉搜索树的遍历类似) class Solution { public: TreeNode* insertIntoBST(TreeNode* root, int val) { if (!root) { TreeNode *node = new TreeNode(val); return node; } TreeNode *pre = NULL, *cur = root; while (cur) { // 找合适的空位 pre = cur; // 标记上一个节点 if (cur -&gt; val &gt; val) cur = cur -&gt; left; else cur = cur -&gt; right; } if (pre) { // 生成节点并插入到pre的左孩子或者右孩子位置 if (pre -&gt; val &gt; val) pre -&gt; left = new TreeNode(val); else pre -&gt; right = new TreeNode(val); } return root; } }; 450.删除二叉搜索树中的节点 代码随想录链接 题目 450.删除二叉搜索树中的节点 删除二叉搜索树中给定值的节点. 自己的想法 通过二叉搜索树的查找, 先找到要删除的节点, 然后再结合左右孩子的情况调整要删除的节点之于其父节点的指针. 题解 递归法: class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { if (!root) return nullptr; if (root -&gt; val == key) { // 若当前节点是要被删除的节点 if (!(root -&gt; left) &amp;&amp; !(root -&gt; right)) { // 如果没有子节点, 就直接删除 delete root; return nullptr; } else if (!(root -&gt; left) || !(root -&gt; right)) { // 如果有一个子节点, 就将子节点代替原来节点 auto node = !(root -&gt; left) ? root -&gt; right : root -&gt; left; delete root; return node; } else { // 如果有两个子节点, 就在右子树中找最左侧的节点(没有左子树的节点), 将被删除的节点的左子树移动到这个节点的左孩子位置上, 并用原节点的右孩子代替被删除节点的位置. auto cur = root -&gt; right; while (cur -&gt; left) { cur = cur -&gt; left; } cur -&gt; left = root -&gt; left; auto tmp = root; root = root -&gt; right; delete tmp; return root; } } if (root -&gt; val &gt; key) root -&gt; left = deleteNode(root -&gt; left, key); // 向左查找要删除的节点 if (root -&gt; val &lt; key) root -&gt; right = deleteNode(root -&gt; right, key); // 向右查找被删除的节点 return root; } }; 还可以使用交换节点法来删除二叉树中的节点(对于所有二叉树都可以): class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { if (!root) return nullptr; if (root -&gt; val == key) { // 找到了目标节点 if (!(root -&gt; right)) return root -&gt; left; // 如果没有右孩子, 就拿左孩子来代替被删除的节点 auto cur = root -&gt; right; // 取右子树中最左侧的节点, 交换与被删除的节点的值 while (cur -&gt; left) cur = cur -&gt; left; swap(root -&gt; val, cur -&gt; val); } // 被交换至没有左子树的节点之后, 再次被遍历时, 会再次被挪到右子树的最左侧节点, 当被挪到叶子节点时再被遍历到, 会被以NULL形式覆盖掉, 完成真正的删除 root -&gt; left = deleteNode(root -&gt; left, key); // 递归删除包含给定值的节点 root -&gt; right = deleteNode(root -&gt; right, key); return root; } }; 迭代法, 删除的逻辑和上面是一样的, 只是找要被删除的节点的过程是迭代的: class Solution { private: TreeNode* deleteTheNode(TreeNode* target) { if (!target) return nullptr; if (!(target -&gt; right)) return target -&gt; left; auto cur = target -&gt; right; while (cur -&gt; left) { cur = cur -&gt; left; } cur -&gt; left = target -&gt; left; return target -&gt; right; } public: TreeNode* deleteNode(TreeNode* root, int key) { if (!root) return nullptr; auto cur = root; TreeNode *pre = nullptr; while (cur) { if (cur -&gt; val == key) break; pre = cur; if (cur -&gt; val &gt; key) cur = cur = cur -&gt; left; else cur = cur -&gt; right; } if (!pre &amp;&amp; root -&gt; val == key) return deleteTheNode(root); if (pre -&gt; left &amp;&amp; pre -&gt; left -&gt; val == key) pre -&gt; left = deleteTheNode(cur); if (pre -&gt; right &amp;&amp; pre -&gt; right -&gt; val == key) pre -&gt; right = deleteTheNode(cur); return root; } };","link":"/2023/03/08/algorithm-train-day22/"},{"title":"代码随想录算法训练营第24天 | 回溯法理论基础, 77.组合","text":"回溯法理论基础 代码随想录链接 什么是回溯 回溯是一种搜索的方式, 其本质是穷举, 是递归的副产品, 只要有递归就会有回溯. 回溯法难理解, 但并不高校, 因为其本质是穷举所有可能, 然后筛选出符合要求的答案, 最多只能通过剪枝来减少穷举的部分, 但不能改变其本质. 回溯能解决的问题 组合问题 N个数里找出k个数的集合(无序) 切割问题 一个字符串按照一定的规则有几种切割方式 子集问题 N个数找出K个熟的排列(有序) 排列问题 N个数按照一定的规则的全排列 棋盘问题 N皇后, 解数独等 理解回溯法 回溯法解决的问题都可以抽象为树型结构, 集合的大小就是熟的宽度, 递归的深度, 就是熟的深度. 递归需要有终止条件, 所以这棵递归树一定是一棵高度有限的树. 回溯法模板 回溯三部曲: 回溯法函数模板返回值及参数 回溯算法中函数返回值一般为void, 参数需要在写逻辑时确定需要什么参数 void backtracing(DataType param) 回溯函数终止条件 在回溯树中的叶子节点时的处理逻辑, 搜到叶子结点, 也就找到了满足条件的一条答案, 把这个答案存放起来, 并结束本层递归. if (endCondition) { /** * Store the result; */ return; } 回溯遍历过程 回溯法遍历过程 for循环横向遍历, 递归进行纵向遍历 for (DataType child : thisLayer) { processThisNode(); backtracing(Path, Selection); // Recursion back(); // 回溯，撤销处理结果 } 综上可以得出回溯法模板框架如下: void backtracing(type&lt;A&gt; param) { if (endCondition) { /** * Store the result; */ return; } for (DataType child : thisLayer) { processThisNode(); backtracing(Path, Selection); // Recursion back(); // 回溯，撤销处理结果 } } 77.组合 代码随想录链接 题目 LeetCode-77.组合 给定两个整数 n 和 k, 返回在[1, n]范围中的所有的 K 个数的集合. 自己的想法 暴力法第24天了哥, 别暴力了 上面不是才学了回溯的理论基础吗, 这道题肯定要拿回溯来做, 回溯的层序遍历可以是找剩下的数中组合开头的数, 然后递归地往结果内加下一个k-1个数的组合. 由于求的是组合, 所以在找k-1个数的组合的时候, 就一定要指明找的边界, 不能把找过的数再次放入. 解法 class Solution { private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracing(int n, int k, int startIndex) { // 回溯递归 if (path.size() == k) { // 集合中满足了k个数, 则记录结果, 结束递归 result.push_back(path); return; } for (int i = startIndex; i &lt;= n; i++) { // 横向遍历 path.push_back(i); // 推入这个数 backtracing(n, k, i + 1); // 纵向递归, 回溯法 path.pop_back(); // 完成了当前这个数的组合的查找, 取出这个数 } } public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { backtracing(n, k, 1); return this -&gt; result; } }; 上面的代码仍然存在一些不必要的步骤, 进行for循环时, 如果i右侧的数不足以填满集合内剩下的空位, 那么就没有必要继续for循环下去, 据此可以进行剪枝操作: class Solution { private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracing(int n, int k, int startIndex) { if (path.size() == k) { result.push_back(path); return; } for (int i = startIndex; i &lt;= n - (k - path.size() - 1); i++) { // 新增了判断是否还有足够的数来填充集合空位 path.push_back(i); backtracing(n, k, i + 1); path.pop_back(); } } public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { backtracing(n, k, 1); return this -&gt; result; } };","link":"/2023/03/10/algorithm-train-day24/"},{"title":"代码随想录算法训练营第3天 | 链表基础，203.移除链表元素，707.设计链表，206.反转链表","text":"链表理论 链表，顾名思义，是链状的数据的集合。在计算机编程语言当中，链表通常的表现形式为： 单链表，图源自代码随想录 根据不同的节点构成，链表可以被分为： 单链表 如上面的图所示，即为单链表，“单”指的是单向，即一个节点除了所存储的数据外，只保留其下一个节点的指针。 双链表 在单链表的基础上，在每个节点上增加一个指向上一个节点的指针，将根据这个节点能查询到的节点扩展为前后节点。 双向链表 循环链表 在双链表或者单链表的基础上，使链表首尾相连，就形成了一个循环链表。 循环链表 链表的存储方式与数组不同，数组通常是连续存储的，通过索引和数组起始位置即可以\\(O(1)\\)的时间访问到指定的数据，但链表中的节点不是连续存储的，需要从链首指针开始，依次查询到指定位置才可以，需要花费\\(O(n)\\)的时间。 链表存储示意图 根据链表的定义，一个常见的单链表的节点可以用C++表示为： struct Node* { int data; // 该节点所存储的数据 Node* next; // 指向下一个节点的指针 Node(int x) : data(x), next(nullptr) {} // 节点的构造函数，可选 }; 一个常见的双链表节点可以用C++表示为： struct Node* { int data; // 该节点所存储的数据 Node* prev; // 指向前一个节点的指针 Node* next; // 指向下一个节点的指针 Node(int x) : data(x), prev(nullptr), next(nullptr) {} // 节点的构造函数，可选 }; 203.移除链表元素 代码随想录链接 题目 LeetCode-203 删除链表中等于给定值的所有节点。 自己的想法 自己首先想到的还是使用链表原有的头和尾来完成，对头进行单独的判断处理，如果头携带值就等于给定值，则不断地把头设置为下一个节点，当头所携带的值不是给定值之后，再对链表后面进行处理，自己写的版本即为解法一。 解法一 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* cur = NULL; // 为了保存当前使用的节点而设立的一个指针 while (head != NULL &amp;&amp; head -&gt; val == val) { // 如果头指针指向的节点携带的值等于给定值 cur = head; // 保存头结点的地址 head = head -&gt; next; // 将头指向下一个节点，使下一个节点成为头结点，这一步之后原来的头结点已经被剥离链表 delete cur; // 释放掉原来头结点的空间 } cur = head; // 从头结点开始遍历，此时头结点的值不等于给定值，所以我们下面只需要看cur -&gt; next的值是否等于给定值 while (cur != NULL) { // 当遍历节点不为空时 if (cur -&gt; next != NULL &amp;&amp; cur -&gt; next -&gt; val == val) { // 如果当前节点存在下一个节点且下一个节点的数据等于给定值 ListNode* toDel = cur -&gt; next; // 标记需要被删除的节点 cur -&gt; next = toDel -&gt; next; // 更新当前节点的next指针，将其指向被删除节点的下一个节点，此步之后被删除节点已被剥离链表 delete toDel; // 释放被删除节点的空间 } else { // 如果当前节点的下一个节点不存在或者其值不等于给定值 cur = cur -&gt; next; // 则移动节点 } } return head; // 返回链表表首指针 } }; 由于遍历了整个链表，故时间复杂度为\\(O(n)\\)，使用了常数个额外变量，空间复杂度为\\(O(1)\\)。 解法二 下面这种方法的思想和上面是一样的，只不过使用了一个假表首来使得代码实现起来比较简单。之前学过但是自己想的时候就是想不起来这种做法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); dummyHead -&gt; next = head; ListNode* cur = dummyHead; while (cur -&gt; next != NULL) { if (cur -&gt; next -&gt; val == val) { ListNode* toDel = cur -&gt; next; cur -&gt; next = toDel -&gt; next; delete toDel; } else { cur = cur -&gt; next; } } head = dummyHead -&gt; next; delete dummyHead; return head; } }; 由于遍历了整个链表，故时间复杂度为\\(O(n)\\)，使用了常数个额外变量，空间复杂度为\\(O(1)\\)。 707.设计链表 代码随想录链接 题目 Leetcode-707 就是实现链表的增删查功能，改太简单了。上过数据结构的同学应该能非常熟练地完成才对。 自己的思考 尽量地多使用伪表首来实现功能，让代码的逻辑看起来更清晰一些。 解法 class MyLinkedList { public: struct Node { int val; Node* next; Node(int val): val(val), next(nullptr){} }; MyLinkedList() { _dummyHead = new Node(0); // 内部实现一个假表首 _size = 0; // 内部的变量，用于存储当前链表的大小 } int get(int index) { if (index &gt;= _size || index &lt; 0) return -1; // 在index不正确时，按照题目要求返回-1 Node* cur = _dummyHead -&gt; next; // 声明一个用于遍历链表的节点 while (index--) cur = cur-&gt;next; // 根据index定位到节点 return cur -&gt; val; // 返回节点值 } void addAtHead(int val) { Node* toAdd = new Node(val); // 实例化一个新的节点来存储值 toAdd -&gt; next = _dummyHead -&gt; next; // 将新的节点的next指针指向当前的（真）头指针，让头节点成为其下一个节点 _dummyHead -&gt; next = toAdd; // 将假表首的next指针指向新的节点，代表新节点成为了（真）头指针 _size++; // 别忘了更新链表的大小 } void addAtTail(int val) { Node* cur = _dummyHead; // 依次遍历到链表的末尾，实例化一个新的节点，并将原末尾节点的next指针指向新的节点 while (cur -&gt; next != NULL) cur = cur -&gt; next; Node* toAdd = new Node(val); cur -&gt; next = toAdd; _size++; } void addAtIndex(int index, int val) { // 类似于get函数的做法，先定位到index指向的节点，然后根据题意将节点插入在该节点之前（修改前节点的next指针和新节点的next指针） if (index &gt; _size) return; if (index &lt; 0) index = 0; Node* toAdd = new Node(val); Node* cur = _dummyHead; while (index--) cur = cur -&gt; next; toAdd -&gt; next = cur -&gt; next; cur -&gt; next = toAdd; _size++; } void deleteAtIndex(int index) { // 根据index定位到节点，通过将前一个节点的next指针修改为要删除节点的下一个节点的地址来完成删除 if (index &gt;= _size || index &lt; 0 ) return; Node* cur = _dummyHead; while (index--) cur = cur -&gt; next; Node* todel = cur -&gt; next; cur -&gt; next = todel -&gt; next; delete todel; // 释放节点空间 _size--; } private: int _size; Node* _dummyHead; }; 206.反转链表 代码随想录链接 题目 LeetCode-206 将一个给定的单链表的节点顺序依次翻转过来。 自己的思考 首先想到的是生成一个新的链表，依次分别将原链表中的数据不断在新链表的头部进行添加。但考虑到这样会造成额外的空间开销，就考虑使用链表的现有节点进行逆转。 解法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if (head == NULL) return NULL; // 处理空表的特殊情况 if (head -&gt; next == NULL) return head; // 处理只有一个节点的特殊情况 ListNode* dummyHead = new ListNode(0); // 使用假表首 ListNode* cur = head; // 使用一个当前节点的指针 while (cur != NULL) { // 循环条件 ListNode* tmp = cur; // 使用一个临时指针来标记当前节点A cur = cur -&gt; next; // 将当前节点向后移动，标记原链表中A的下一个节点 tmp -&gt; next = dummyHead -&gt; next; // 将A的next指针指向假表首的下一个节点 dummyHead -&gt; next = tmp; // 使A成为新的表首 } return dummyHead -&gt; next; // 真表首是假表首的next指针所指向的节点 } }; 遍历了链表，时间复杂度为\\(O(n)\\)；由于没有产生新的链表，空间复杂度为\\(O(1)\\)。","link":"/2023/02/17/algorithm-train-day3/"},{"title":"代码随想录算法训练营第4天 | 24. 两两交换链表中的节点， 19.删除链表的倒数第N个节点，面试题 02.07. 链表相交，142.环形链表II，链表总结","text":"24.两两交换链表中的节点 代码随想录链接 题目 LeetCode-24 给定一个链表，将奇数位与相邻右侧偶数位的节点进行翻转。 自己的想法 使用假表头，遍历时使用一个cur指针指向在需要交换的一对节点的前面一个节点，然后对这一对节点的位置进行交换。 解法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0, head); // 一个假表头，并使用构造函数将next指向head节点 ListNode* cur = dummyHead; // cur指针用于遍历链表 while(cur != NULL &amp;&amp; cur -&gt; next != NULL) { // 如果cur指针为空，或者cur节点后没有节点的话，就跳出循环 if (cur -&gt; next -&gt; next == NULL) break; // 如果cur指针指向的节点没有一对节点的话，结束 ListNode* first = cur -&gt; next; // 取cur指向的节点后的第一个节点，即奇数位节点 ListNode* second = first -&gt; next; // 取要交换的偶数位节点 ListNode* third = second -&gt; next; // 取偶数位节点后的节点 cur -&gt; next = second; // 将偶数位节点向前置，置于奇数位节点之前 second -&gt; next = first; // 将奇数位节点置于偶数位节点之后 first -&gt; next = third; // 将原来偶数位节点之后的节点置于奇数位节点之后 cur = first; // 移动cur指针 } return dummyHead -&gt; next; // 返回真表头 } }; 对链表进行遍历，时间复杂度为\\(O(n)\\)；使用了常数个额外变量，空间复杂度为\\(O(1)\\)。 19.删除链表中的倒数第N个节点 代码随想录链接 题目 LeetCode-19 给定一个单链表，删除倒数第n个节点。 自己的想法 双指针么，根据给定的n，使快指针先走对应的\\((n - 1)\\)步, 然后快慢指针再一起移动，当慢指针移动到末尾节点时，慢指针指向的就是要删除的节点。 为什么是\\((n - 1)\\)步呢，因为这里的想法是使得fast指向最后一个节点时停止，而不是fast为NULL时停止，在这种条件下，fast和slow指针之间的步数差距应该是\\((n - 1)\\)步，举个例子，如果要删除倒数第2个节点，当fast指向末尾节点时，slow指向的是fast前的一个节点，此时fast和slow之间的步数差距不是2，而是1。 为了能在单链表中正确删除给定位置的节点，还可以让fast在寻找末尾的时候少走一步，这样fast和slow指针一起移动结束之时，slow指针指向的是要被删除的节点之前的节点，便于进行链表操作。 解法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0, head); // 利用构造函数声明一个假表头并让其next指针指向head节点 ListNode* slow = dummyHead, *fast = dummyHead; // 快慢指针 n--; // 计算步数差 while (n-- &amp;&amp; fast != NULL) fast = fast -&gt; next; // 让fast指针先走 while (fast -&gt; next != NULL &amp;&amp; fast -&gt; next -&gt; next != NULL) { // 当fast指针在倒数第二个节点的时候就停下来，这样slow就在要删除的节点的上一个节点停下来了 fast = fast -&gt; next; // slow和fast指针同时前进 slow = slow -&gt; next; } ListNode* toDel = slow -&gt; next; // 根据上面的思路，此时slow节点的next指针指向的就是要删除的节点，在此标注 slow -&gt; next = toDel -&gt; next; // 将slow节点的next指针指向要删除的节点的下一个节点，将要删除的节点剥离链表 delete toDel; // 释放删除的节点的内存空间 return dummyHead -&gt; next; // 返回真表头 } }; 上面的这个代码实现和代码随想录里的C++代码实现有些许的不同，主要区别是在如何处理fast指针的位置，使得slow指针能够停留在要删除的节点的上一个节点处。代码随想录里的做法循环的跳出条件是，fast为空时，slow指针要指向被删除节点的上一个节点，所以fast指针不仅要比slow指针多走n步，甚至还要再多1步；而上面的实现中，fast指针最终停在了末尾节点的上一个节点。作用是一样的。 上面的实现中，时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)。 链表相交 代码随想录链接 题目 LeetCode-面试题02.07 给定两个链表，要求找到两个链表重合部分的起始节点。王道考研资料数据结构书上的题。 自己的想法 先通过遍历两个链表，获得两个链表分别的长度，再让长链表的遍历指针先走等于长度差的步数，接着让长短链表的遍历指针同时移动，当这两个指针指向同一个节点时，就找到了重合相交部分的起始节点。 解法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *dummyA = headA, *dummyB = headB; // 假表头 ListNode *curA = dummyA, *curB = dummyB; // 用来计算长度的遍历指针 int lengthA = 0, lengthB = 0; // 长度的变量 while (curA != NULL &amp;&amp; curA -&gt; next != NULL) { // 查A的长度 curA = curA -&gt; next; lengthA++; } while (curB != NULL &amp;&amp; curB -&gt; next != NULL) { // 查B的长度 curB = curB -&gt; next; lengthB++; } ListNode *curLongerList = lengthA &gt;= lengthB ? dummyA : dummyB; // 根据长度对比，分别确定长链表和锻炼表 ListNode *curShorterList = lengthA &lt; lengthB ? dummyA : dummyB; int steps = lengthA &gt;= lengthB ? (lengthA - lengthB) : (lengthB - lengthA); // 计算步数差 while (steps--) curLongerList = curLongerList -&gt; next; // 长链表先走 while (curLongerList &amp;&amp; curShorterList) { // 长短链表遍历指针同时移动 if (curLongerList == curShorterList) return curLongerList; // 当两条链表的遍历指针指向同一个节点时，返回该节点指针 curLongerList = curLongerList -&gt; next; // 否则，两个指针继续移动 curShorterList = curShorterList -&gt; next; } return NULL; // 如果一直没有指向同一个节点，证明两链表无相交部分 } }; 和代码随想录上的C++实现也还是有些许的差别，主要是在确定长短链表那里。 上面的实现遍历了两次链表，时间复杂度为\\(O(2 * n) = O(n)\\)，使用了常数个变量，空间复杂度为\\(O(1)\\)。 142.环形链表II 代码随想录链接 题目 LeetCode-142 给定一个链表，返回链表内环形结构开始的节点。若无环，则返回 NULL 。 这道题目不要太熟悉啊，也是王道考研资料的数据结构书上面的题，可能是链表部分练习题的最后一道大题来着。并不耽误我这次一开始自己没做出来。 自己的想法 双指针法，快指针一次走两步，慢指针一次走一步。当快慢指针相遇时，证明有环状结构存在。此时，快指针的步数是慢指针步数的两倍。 示意图，图源代码随想录 设链表入环前的长度为\\(x\\)，链表环的入口到快慢指针相遇的地方长度为\\(y\\)，相遇之处从沿快慢指针前进方向距环的入口的长度为\\(z\\)，可得以下公式： \\begin{equation} 2 * (x + y) = x + n * (x + y) + z \\end{equation} 其中，\\(n\\)为快指针进入环结构之后，完整走完了几次环结构。 根据上面的式子，可得： \\begin{equation} x = (n - 1) * (y + z) + z \\end{equation} \\((y + z)\\)等于一个环结构的长度，我们假设\\(n = 1\\)，即快指针完整走完了一次环结构后才与慢指针相遇，可得： \\begin{equation} x = z \\end{equation} 此时若新设立一个指针，从链表表头开始，与慢指针同时一步一步前进，则当慢指针走过\\(z\\)步，新指针走过\\(x\\)步时，慢指针和新指针将在环结构入口处相遇。 若\\(n &gt; 1\\)，同样在链表表头设立一个新指针，此时新指针与慢指针的距离为\\((x + y)\\)。由上面的式子可得： \\begin{equation} x + y = (n - 1) * (y + z) + z + y = n * (y + z) \\end{equation} 即此时新指针与慢指针的差距为环形结构的长度的\\(n\\)倍，在新指针与慢指针同时一步一步前进的条件下，两者最终还是会在环装结构入口处相遇。 解法 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *fast = head, *slow = head; while (fast != NULL &amp;&amp; fast -&gt; next != NULL) { slow = slow -&gt; next; fast = fast -&gt; next -&gt; next; if (slow == fast) break; } if (fast == NULL || fast -&gt; next == NULL) return NULL; ListNode *prob = head; while (prob != slow) { prob = prob -&gt; next; slow = slow -&gt; next; } return prob; } }; 不知道怎么说这个时间复杂度为好。。。空间复杂度为\\(O(1)\\)。 链表总结 两天干完链表。感觉链表的内容确实不算那种非常难的知识。最起码给我这个计算机科班的人感觉像是在复习。或这就是为什么卡哥给算法训练营中数组和链表都只安排了两天吧。 链表基础 链表的种类分为： 单链表 双链表 循环链表 链表的存储方式：分散存储，依靠相邻节点之间的指针保持联系。 常见题目 虚拟头节点 虚拟头结点主要使用在单链表遍历过程中需要使用前一个节点才能进行操作时。不使用虚拟头结点也能做，就是要单独处理头结点的情况；而使用虚拟头结点，能够在后续的代码中简化实现。 例题： 代码随想录--LeetCode 203.移除链表元素 链表增删改查 既然是个数据结构嘛，免不了要进行增删（改）查，为什么把改单独括起来呢，因为改的前一步往往是要查。 这种题目考的是链表的一些基础操作，虽然看起来简单，但是非常重要，而且经常会在小地方出错而导致代码不能AC。 例题： 代码随想录--LeetCode 707.设计链表 反转链表 将链表的本末倒置。考察对于链表操作的熟练程度，方法主要有递归法和迭代法。 例题： 代码随想录--LeetCode 206.反转链表 删除倒数第N个节点 双指针法。理清快慢指针之间的关系即可。 例题： 代码随想录--LeetCode 19.删除链表的倒数第N个节点 链表相交 找清楚链表相同的部分，将不同的部分予以对齐。 例题： 代码随想录--LeetCode 面试题 02.07 链表相交 环形链表 这种题目主要是数学公式的推导，实现并非难点。 例题： 代码随想录--LeetCode 142.环形链表II","link":"/2023/02/18/algorithm-train-day4/"},{"title":"代码随想录算法训练营第6天 | 242.有效的字母异位词，349.两个数组的交集，202.快乐数，1.两数之和","text":"没第5天？因为第5天是周日，放个假。 哈希表理论基础 什么是哈希表 哈希表就是根据数据的关键码来对数据进行直接访问的数据结构。例如数组其实就是一个哈希表，可以根据数据的索引来直接访问对应位置的数据。 哈希表主要用来解决快速判断一个元素是否出现在一个集合中。这里的快速判断是指要通过\\(O(1)\\)的时间复杂度来判断，而并非像遍历数组那样的\\(O(n)\\)的时间复杂度。 哈希函数 通过一定的计算方法，将要存储的数据转化出来对应的哈希表上的索引的函数，为哈希函数。 例如，将学生的姓名通过哈希函数计算出数值，再将该学生的姓名存放在哈希表上的对应位置。 如果哈希函数的设计不足以完全达到对不同的数据产生一定产生不同的哈希值（例如哈希函数为 x % 10时，数据11和数据21的哈希值都是1），就会发生哈希碰撞。 哈希碰撞 在下面这个图中，两个不同的数据，通过哈希函数计算出来的哈希值是相同的。 解决哈希碰撞主要有两种方法： 拉链法 哈希表表内实际上存储的是一个一个（警撅）链表的表头指针，将发生哈希碰撞的数据按照插入的先后顺序，存放在对应位置的链表上。如图所示。 线性探测法 该方法的思想是，在遭遇到碰撞时，从哈希值所指的位置开始，线性向后依次探测出一个空位置，并将数据存放至该空位置。 但是单纯的线性探测，会使得哈希值相同的数据聚集在同一个区域，此时一个改进的方法就是将“依次探测空位置”变为“按照一定的计算方法向后探测位置”，如将向后探测位置的步数从每次加1改为向后探测\\(1^2, 2^2, ...\\)。 再哈希 准备多个哈希函数，在出现哈希碰撞时，使用下一个哈希函数进行计算，直至哈希函数不再冲突。 其中\\(RH_i\\)为不同的哈希函数。 常见的三种哈希结构 数组 set--集合 map--映射 数组作为哈希结构在上文中有提到。 set在C++主要有下面三种数据结构，将代码随想录的表格抄过来，如下表所示： 数据结构 底层实现 有序 可以重复 可以更改数值 查询效率 增删效率 std::set 红黑树 Y N N \\(O(logn)\\) \\(O(logn)\\) std::multiset 红黑树 Y Y N \\(O(logn)\\) \\(O(logn)\\) std::unordered_set 哈希表 N N N \\(O(1)\\) \\(O(1)\\) 红黑树是一种平衡二叉搜索树，所以key是有序的，但key不能修改，只能对数据进行删除和增加。 C++中，集合的调用形式为： #include &lt;set&gt; // ... std::unordered_set&lt;DATA_TYPE&gt; set; // 声明一个集合 set.insert(DATA); // 插入一个数据 auto iter = set.find(DATA); // 判断一个集合是否包含一个数据 if (iter != set.end()) { // 如果包含一个数据，则进行一些处理 // do things } 映射，顾名思义，就是将一个值映射到另外一个值上面，形成一定的对应关系。 map在C++中主要有以下三种数据结构，将代码随想录的表格抄过来，如下表所示： 数据结构 底层实现 有序 可以重复 可以更改数值 查询效率 增删效率 std::map 红黑树 Y(Key) N N \\(O(logn)\\) \\(O(logn)\\) std::multimap 红黑树 Y(key) Y N \\(O(logn)\\) \\(O(logn)\\) std::unordered_map 哈希表 N(Key) N N \\(O(1)\\) \\(O(1)\\) 同上，multimap和map中的key是有序的且无法修改。 C++中，映射的调用形式为： #include &lt;map&gt; // ... std::unordered_set&lt;KEY_TYPE, DATA_TYPE&gt; map; // 声明一个映射 map.insert(pair&lt;KEY_TYPE, DATA_TYPE&gt;(key, data)); // 插入一对数据 auto iter = map.find(key); // 判断一个集合是否包含一个数据 if (iter != map.end()) { // 如果包含一个数据，则进行一些处理 // do things } 使用集合来解决哈希问题时，优先使用unordered_set，因为其查询效率和增删效率都是最优的。 242.有效的字母异位词 代码随想录链接 题目 LeetCode-242 给定两个字符串，判断这两个字符串是否是异位词。 自己的想法 异位词的其实就是同样的一组字母，进行不同的排列而形成的单词。特点有： 出现的字符相同 每个字符的出现次数相同 那在这里其实就可以使用映射关系，来存储26个字母中每个字母的出现的次数。可以使用数组，也可以使用map。 解法 class Solution { public: bool isAnagram(string s, string t) { int letters[26] = {0}; // 用于存储26个字母出现次数的数组 for (int i = 0; i &lt; s.size(); i++) letters[s[i] - 'a']++; // 遍历s字符串，计算每个字母出现的次数 for (int i = 0; i &lt; t.size(); i++) letters[t[i] - 'a']--; // 遍历t字符串，将出现的字母的次数进行减1 for (int i = 0; i &lt; 26; i++) if (letters[i] != 0) return false; // 如果数组中出现了不为0的值，证明两个字符串不符合异位词的特点 return true; // 如果数组最终均为0值，则两个字符串时异位词 } }; 该解法时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)。 349. 两个数组的交集 代码随想录链接 题目 LeetCode-349 给定两个数组，输出它们的交集。 自己的想法 集合么，将一个数组转为一个集合，然后遍历另外一个数组，依次判断第二个数组中的值是否存在于集合中，若存在，则将该数插入到结果集合中。 解法 class Solution { public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_set&lt;int&gt; result; // 结果集合 unordered_set&lt;int&gt; nums1_set(nums1.begin(), nums1.end()); // 根据第一个数组中的值生成一个集合 for (int i = 0; i &lt; nums2.size(); i++) { // 依次判断第二个数组中的数是否存在于集合中 if (nums1_set.find(nums2[i]) != nums1_set.end()) result.insert(nums2[i]); // 若存在，就将该值插入到结果结合中 } return vector&lt;int&gt;(result.begin(), result.end()); // 将结果集合转化为数组 } }; unordered_set的查询和增删效率都是\\(O(1)\\)，故生成集合的过程耗费时间为\\(O(n)\\)，遍历并判断是否存在以及插入到结果集合所耗费的时间为\\(O(n)\\)，将结果转化为数组的时间为\\(O(n)\\)，故时间复杂度为\\(o(n)\\)，空间复杂度为\\(o(n)\\)。 202. 快乐数 代码随想录链接 题目 LeetCode-202 判断一个数是否为快乐数，快乐数的定义为：进行一个循环，每次循环都将这个数替换为其各位数的平方和，若最终平方和为1，则该数为快乐数；若一直无限循环，则该数不是快乐数。 自己的想法 一直无限循环的话，每次替换的数值必定会有重复的，例如给定数是2时，其替换的值依次为：4,16,37,58,89,145,42,20,4,...。是一个重复的序列。 所以我们可以使用一个集合，当替换的值不为1时，判断每次替换的值是否存在于该集合中，如果存在则说明非快乐数，否则就将该替换值加入集合当中，继续循环。 解法 class Solution { public: int getSum(int n) { // 用于计算一个数的各位平方之和的函数 int sum = 0; while (n) { sum += (n % 10) * (n % 10); n /= 10; } return sum; } bool isHappy(int n) { unordered_set&lt;int&gt; sumSet; // 每次计算出的平方和的集合 while (n != 1) { // 当平方和不为1时进行循环 n = getSum(n); // 计算出平方和 if (sumSet.find(n) != sumSet.end()) return false; // 如果已经出现过这个平方和，说明非快乐数 else sumSet.insert(n); // 没有出现过就将本次平方和加入集合 } return true; // n == 1时，该数为快乐数 } }; 1. 两数之和 代码随想录链接 题目 LeetCode-1 给定一个数组和一个值，判断该数组中是否存在两个数且他们之和为给定值，若存在，则输出这两个值的索引。 自己的想法 暴力解法，两个for循环，根据一个数来查是否存在另外一个数 由于要输出的是两个值的索引，这个地方可以使用map来存储&lt;值, 索引&gt;对来解决问题。 解法一 class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { for (int i = 0; i &lt; nums.size(); i++) { // 遍历数组 int num1 = nums[i]; // 取当前遍历到的值A for (int j = i + 1; j &lt; nums.size(); j++) if (target - num1 == nums[j]) return vector&lt;int&gt;{i, j}; // 遍历查找在A之后的值中是否有与A之和等于给定值的数（你说为啥不从前面开始找，那我遍历前面的时候不是找过了？） } return vector&lt;int&gt;(); // 不存在则返回空数组 } }; 时间复杂度为\\(O(n^2)\\)，空间复杂度为\\(o(1)\\)。 解法二 class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; indexMap; // 存储&lt;值, 索引&gt;对的映射 for (int i = 0; i &lt; nums.size(); i++) { // 遍历数组 auto iter = indexMap.find(target - nums[i]); // 查找映射中是否有key为相应的加数的键值对 if (iter != indexMap.end()) return {iter -&gt; second, i}; // 若存在，则返回这两个索引 indexMap.insert(pair&lt;int, int&gt;(nums[i], i)); // 否则就将该键值对插入映射中 } return {}; // 不存在则返回空数组 } }; unordered_map的查询和增删效率都是\\(O(1)\\)，故该实现的时间复杂度为\\(O(n)\\)，空间复杂度为\\(o(n)\\)。","link":"/2023/02/20/algorithm-train-day6/"},{"title":"代码随想录算法训练营第7天 | 454.四数相加II，383. 赎金信，15.三数之和，18.四数之和，哈希总结","text":"454.四数相加II 代码随想录链接 题目 LeetCode-454 给定四个数组，计算满足从各个数组中取一个值得到的四个值之和为0的情况有几种。 自己的想法 怎么一上来先想到的是暴力法啊（恼） 因为要求四个数之和是0，且只要求输出可行的对数，可以使用一个map来存储第一个和第二个数组中每种可能的和，然后根据第三个数组和第四个数组中取出的数之和来找在map中是否有相应的数据满足四个数之和为0。 解法 class Solution { public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) { unordered_map&lt;int, int&gt; addedMap; // 存储第1个和第2个数组中取出的数的值之和的情况 int count = 0; // 计数有多少种可能满足 for (int a: nums1) { for (int b: nums2) { addedMap[a + b]++; // 存储和的出现次数 } } for (int c: nums3) { for (int d: nums4) { if (addedMap[0 - (c + d)] != 0) { // 如果存在a+b满足a+b+c+d==0 count += addedMap[0 - (c + d)]; // 计数器增加 } } } return count; } }; 时间复杂度为\\(O(n^2)\\)，空间复杂度为\\(O(n)\\)。 383.赎金信 代码随想录链接 题目 LeetCode-383 给定一个字符串ransom和另一个字符串magazine，判断ransom字符串能否由magazine字符串中的字母组成，每个位置上的字母只能使用一次。 自己的想法 使用map统计magazine中每个字符出现的次数，然后再遍历ransom字符串，判断每个字符都在map内存在对应的足够的出现次数。 其实也可以用int record[26] = {0}来存，因为题目说了只有小写字母。 解法 class Solution { public: bool canConstruct(string ransomNote, string magazine) { unordered_map&lt;char, int&gt; mapMagazine; // 用来存储magazine中字符出现次数的map for (char m: magazine) { mapMagazine[m]++; // 遍历magazine字符串，统计字符出现次数 } for (char r: ransomNote) { // 遍历ransom字符串 if (mapMagazine.count(r) &lt;= 0) return false; // 若map中不存在这个字符，直接判断不满足 mapMagazine[r]--; // 抵消map中这个字符的计数一次 if (mapMagazine[r] &lt; 0) return false; // 如果抵消后，计数低于0，证明不满足条件，返回false } return true; // 满足条件，返回true } }; 时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(n)\\)。 15.三数之和 代码随想录链接 题目 LeetCode-15 给定一个数组，输出三个位置不相同的数，且这三个数之和为0。 自己的想法 一开始想用哈希做来着，但是哈希感觉还要去重，不是很容易。然后就不知道该咋办了 看了代码随想录的提示，开始往双指针上考虑。这个方法主要是要想好开始的时候左右指针要怎么定义，以及移动指针的条件。 由于题目要求输出三个相加为0的数，所以可以对本题的数组进行排序。遍历数组，并在遍历的数据后方进行左右指针的调整。 解法 class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; results; // 存储最终数组 sort(nums.begin(), nums.end()); // 对数组进行排序，sort函数默认为升序 for (int i = 0; i &lt; nums.size(); i++) { // 遍历数组中每个数据 if (nums[i] &gt; 0) { // 如果其本身就已经大于0，加上后面的数据必大于0，一定不满足条件 return results; } if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { // 如果和左侧相邻的数相同，已经计算过，不用再次计算 continue; } int left = i + 1; // 确定左右区间 int right = nums.size() - 1; while (right &gt; left) { // 指针不能重合 if (nums[i] + nums[left] + nums[right] &gt; 0) right--; // 如果三个值之和大于0，证明右指针需要朝着变小的方向移动 else if (nums[i] + nums[left] + nums[right] &lt; 0) left++; // 如果三个值之和小于0，证明左指针需要朝着变大的方向移动 else { // 如果三值之和等于0 results.push_back(vector&lt;int&gt;{nums[i], nums[left], nums[right]}); // 保存满足条件的结果 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; // 跳过会和刚才保存的结果相同的数据 while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; left++; // 继续收缩区间 right--; } } } return results; // 返回结果 } }; 18.四数之和 代码随想录链接 题目 LeetCode-18 在一个给定的数组内，找出4个索引不同的数据，使得四个数之和为给定的目标值。 自己的想法 和上面道题非常相似，其实感觉就可以在上面的题解的基础上，增加一个for循环，以两个for循环的索引指向的值之和为确定值，使用双指针法确定剩下两个数。 解法 class Solution { public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; result; // 结果数组 sort(nums.begin(), nums.end()); // 生序排序 for (int k = 0; k &lt; nums.size(); k++) { // 遍历，确定第1个值 if (nums[k] &gt; target &amp;&amp; nums[k] &gt;= 0) { // 如果本身就是正数且大于目标值，右侧的数只会比这个数大，加起来必定不会满足条件 break; } if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) { // 去重 continue; } for (int i = k + 1; i &lt; nums.size(); i++) { // 遍历，确定第2个值 if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= 0) { // 第1个值和第2个值加起来大于目标值且之和为正数，加上右侧的数必定不满足条件 break; } if (i &gt; k + 1 &amp;&amp; nums[i] == nums[i - 1]) { // 第2个值去重 continue; } int left = i + 1; // 确定左右区间 int right = nums.size() - 1; while (right &gt; left) { // 双指针循环条件 if ((long) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) right--; // 四数之和大于目标值，右指针左移 else if ((long) nums[k] + nums[i] + nums[left] + nums[right] &lt; target) left++; // 四数之和小于目标值，左指针右移 else { // 若四数之和等于目标值 result.push_back(vector&lt;int&gt;{nums[k], nums[i], nums[left], nums[right]}); // 保存结果 while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; // 左指针指向的值去重 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; // 右指针指向的值去重 right--; // 左右指针向中间移动一位 left++; } } } } return result; // 返回结果 } }; 哈希总结 哈希表在刷题中经常用于快速判断一个元素是否出现在集合里。一些哈希表实现的知识，请参考昨天的总结。 经典题目 数组作为哈希表 在昨天和今天的题目里，主要是用于在只会出现的小写字母的字符串判断。这种情况下使用数组要比使用C++的STL要更快一些。 LeetCode-242 有效的字母异位词 LeetCode-383 赎金信 set作为哈希表 当可能出现的数据的范围比较大时，再使用数组就不合理了，因为数组大小是有限的，而且声明过大的数组会浪费内存。 在昨天的文章中，提到了C++中set的三种数据结构，在不需要排序和数据重复的情况下，使用std::unordered_set是最高效的。 LeetCode-202 快乐数 LeetCode-349 两个数组的交集 map作为哈希表 相比于set，map适合用在需要记录额外信息的地方，例如，记录了一个元素出现了多少次、记录一个元素的在数组中的下标等等... map所存储的是键值对，在昨天的文章中，提到了C++中有三种map的数据结构，和set类似，如果不需要对key进行排序和重复的情况下，使用std::unordered_map的效率是最高的。 LeetCode-1 两数之和 LeetCode-454 四数相加II","link":"/2023/02/21/algorithm-train-day7/"},{"title":"代码随想录算法训练营第8天 | 344.反转字符串，541.反转字符串II，剑指Offer 05.替换空格，151.翻转字符串里的单词，剑指Offer58-II.左旋转字符串","text":"344.反转字符串 代码随想录链接 题目 LeetCode-344 将一个字符串中的字符翻转。只能在函数中使用\\(O(1)\\)的额外空间。 自己的想法 使用\\(O(1)\\)的空间意味着，对于字符串的逆转操作只能原地进行。 因为本题的关键点就在于逆转操作，故不可以直接使用reverse函数完成。 使用双指针法，将左右指针分别指向字符串的起始位置和末尾，交换两个指针指向的字符，并将指针向中间靠拢。 解法 class Solution { public: void reverseString(vector&lt;char&gt;&amp; s) { int left = 0, right = s.size() - 1; // 初始化左右指针 while (left &lt; right) { // 左右指针结束循环条件 swap(s[left], s[right]); // 交换左右指针的值 left++; // 左右指针分别向中间移动 right--; } } }; 时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)。 541.反转字符串II 代码随想录链接 题目 LeetCode-541 给定一个字符串和一个正整数k，对于每2k的字符，翻转前k个字符。若剩余不到k个字符，则全部翻转；若剩余字符数大于等于k但小于2k，则翻转前k个字符。 自己的想法 使用一个for循环来确定每2k个字符所形成的字符串的左侧起始区间，判断自该位置起始的剩余字符串的长度是否大于等于k，若大于等于k，则翻转自该位置起的k个字符所形成的字符串；若剩余长度小于k，则翻转剩余字符。 解法 class Solution { public: string reverseStr(string s, int k) { for (int i = 0; i &lt; s.size(); i += 2 * k) { // 确定每2k个字符形成的字符串的起始位置 if (i + k &lt;= s.size()) { // 若剩余字符个数大于等于k reverse(s.begin() + i, s.begin() + i + k); // 翻转k个字符 } else { // 否则就翻转剩下的字符 reverse(s.begin() + i, s.end()); } } return s; } }; 剑指Offer 05.替换空格 代码随想录链接 题目 剑指 Offer 05.替换空格 将字符串中的空格替换为\"%20\"。 自己的想法 如果使用额外的新数组作为结果进行返回，题目就很简单，遍历数组即可。使用\\(O(1)\\)的空间复杂度才使得这个题目有难度。 这个题目类似于LeetCode-27.移除元素，可以使用双指针方法来进行替换。若要原地替换，首先统计字符串中有多少个空格，计算出新的字符串应该有的长度，对原字符串进行长度调整。然后再使用两个指针，指针A指向原字符串的末尾，指针B指向调整后的字符串的末尾。将指针A向前移动，若遇见一个空格，则在指针B指向的位置依次向前插入'0', '2', '%'；若遇见空格之外的字符，则直接拷贝至指针B指向的位置。 解法一 暴力法 class Solution { public: string replaceSpace(string s) { string result; for (char c: s) { if (c == ' ') { result.append(&quot;%20&quot;); } else result.push_back(c); } return result; } }; 解法二 class Solution { public: string replaceSpace(string s) { int blankCount = 0; for (char c: s) { // 统计空格的个数 if (c == ' ') { blankCount++; } } int oldPointer = s.size() - 1; // 指针A指向原字符串的末尾 s.resize(2 * blankCount + s.size()); // 扩展字符串至替换后应该有的长度 int newPointer = s.size() - 1; // 指针B指向新字符串的末尾 while (blankCount) { // 当空格没有被替换完毕时 if (s[oldPointer] == ' ') { // 如果指针A遇到了一个空格 s[newPointer--] = '0'; // 依次插入替换的字符 s[newPointer--] = '2'; s[newPointer--] = '%'; blankCount--; // 空格计数器减1 oldPointer--; // 指针A向前移动 } else s[newPointer--] = s[oldPointer--]; // 遇到的不是空格，就直接拷贝原字符 } return s; } }; 时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)。 151.翻转字符串里的单词 代码随想录链接 题目 LeetCode-151 将字符串中的单词进行翻转，而单词保持原来的状态。同时去除字符串前后的空格和连续的多余空格。 自己的想法 字符串中的一些部分翻转而另外一些保持原形，就可以考虑使用先整体翻转再部分翻转来解决。 在这个题目中，可以先去除多余的空格，再将整个字符串翻转，最后再以单词为分区，进行分区内的翻转。 解法 class Solution { public: string reverseWords(string s) { int fast = 0, slow = 0; // 同27.移除元素，使用双指针法移除元素 while (s[fast] == ' ' &amp;&amp; fast &lt; s.size()) fast++; // 移除开头的空格 while (fast &lt; s.size()) { // 每碰见一个空格，就像慢指针的位置写入一个空格，并将快指针移至下一个不为空格的位置 if (s[fast] == ' ') { s[slow++] = ' '; while (s[fast] == ' ' &amp;&amp; fast &lt; s.size()) fast++; } else { s[slow++] = s[fast++]; // fast指针不指向空格时，拷贝fast指针指向的内容至slow指针 } } if (s[slow - 1] == ' ') { // 去除末尾可能多出来的一个空格 slow--; } s.resize(slow); // 调整s的大小，该大小为去除多余空格之后的字符串大小 reverse(s.begin(), s.end()); // 翻转整个字符串 int start = 0; // 标记每个单词的起始位置 for (int i = 0; i &lt;= s.size(); i++) { // 遍历字符串，找单词之间的空格 if (i == s.size() || s[i] == ' ') { // 遇到了空格或者字符串末尾 reverse(s.begin() + start, s.begin() + i); // 翻转[start, i)区间的字符串 start = i + 1; // 移动单词起始位置至空格后的字符 } } return s; } }; 剑指 Offer 58-II.左旋转字符串 代码随想录链接 题目 剑指 Offer 58-II.左旋转字符串 给定一个字符串和一个整数k，将前k位的字符移至字符串末尾。 自己的想法 和上面的题相似，可以采用先整体翻转再局部翻转的方法解决。先将整个字符串进行翻转，再翻转\\([0, size - k)\\)区间的字符，最后反转\\([size - k, size)\\)部分即可。 解法 class Solution { public: string reverseLeftWords(string s, int n) { reverse(s.begin(), s.end()); // 翻转整个字符串 reverse(s.begin(), s.end() - n); // 翻转[0, size - k) reverse(s.end() - n, s.end()); // 翻转[size - k, size) return s; } };","link":"/2023/02/22/algorithm-train-day8/"},{"title":"代码随想录算法训练营第9天 | 28.实现 strStr()，459.重复的子字符串，字符串总结，双指针回顾","text":"28.实现strStr() 代码随想录链接 题目 LeetCode-28 给定字符串A和B，返回B作为子串在A中出现的位置。 自己的想法 暴力法就不说了，时间复杂度\\(O(m * n)\\)。 优化方法是使用KMP算法来进行字符串匹配，可惜考研的时候只在王道上学了KMP怎么样手工计算next数组，代码莫得掌握。 KMP太长了，感觉自己讲不明白，详细的说明可以去看上面代码随想录的链接。这里只说明一下KMP的思想就是：字符串某个位置出现不匹配的时候，可以不用从头开始匹配，直接根据next数组跳转至已经匹配过得一部分。 题解 class Solution { public: void getNext(string &amp;s, int* next) { // 获取字符串的next数组 int j = 0; // j是前缀末尾，初始指向首位 next[0] = j; // 后面一位的值为回退到字符串初始位置 for (int i = 1; i &lt; s.size(); i++) { // i指向后缀末尾 while (j &gt; 0 &amp;&amp; s[i] != s[j]) { // 前缀末尾不等于后缀末尾时，前缀末尾向前回退 j = next[j - 1]; } if (s[i] == s[j]) j++; // 找到相同的前后缀 next[i] = j; // 将前缀的长度赋给next数组中的next[i] } } int strStr(string haystack, string needle) { if (needle.size() == 0) return 0; int next[needle.size()]; getNext(needle, next); // 根据needle获取next数组 int j = 0; // j用来指向needle中的字符 for (int i = 0; i &lt; haystack.size(); i++) { // i用来指向haystack里的字符 while (j &gt; 0 &amp;&amp; haystack[i] != needle[j]) j = next[j - 1]; // 若字符不相同，needle的指针根据next数组回退 if (haystack[i] == needle[j]) j++; // 相同时，needle指针往后探索 if (j == needle.size()) { // needle指针探索到了needle的末尾时，证明匹配完成 return (i - needle.size() + 1); } } return -1; } }; 459.重复的子字符串 代码随想录链接 题目 LeetCode-459 判断一个字符串是否由一个子串多次重复构成。 自己的想法 暴力法 其实也可以用KMP算法来解决，如果一个字符串是由其子串多次重复而得到的，其next数组就会呈现出一定的规律。 假设重复n次来组成的串s的子串为sub，长为x, 那么s的长度为\\(m * x\\)，且s的最长相同前后缀长度必定为 \\((m - 1) * x\\)，通过这个条件，就可以根据next数组判断是否满足题设。 题解 class Solution { public: void getNext(int *next, const string &amp;s) { // 和上题一样，根据给定字符串获得一个next数组 int j = 0; next[0] = 0; for (int i = 1; i &lt; s.size(); i++) { while (j &gt; 0 &amp;&amp; s[i] != s[j]) j = next[j - 1]; if (s[i] == s[j]) j++; next[i] = j; } } bool repeatedSubstringPattern(string s) { if (s.size() == 0) return false; int next[s.size()]; getNext(next, s); int len = s.size(); if (next[len - 1] != 0 &amp;&amp; (len % (len - next[len - 1]) == 0)) { // 如果next数组的最后一位不指向0，且字符串长度能够整除以最长前后缀以外的部分的长度，则满足条件 return true; } return false; } }; 字符串总结 字符串，其实可以看做是字符的数组。在C++中，字符串可以是 char a[5] = &quot;asd&quot;; \\\\ 也可以是 vector&lt;char&gt; vc; \\\\ 还可以是 string s; 使用char的数组来组成一个字符串，需要自行判断'\\0‘来检测字符串的结尾，string则不用，且string类型提供了更多的接口来进行字符串处理。所以在遇到字符串问题的时候，尽量还是使用string类型。 双指针法 和数组中的双指针法非常相似，无论是翻转，还是去除某些元素。 例题： 344.反转字符串 字符串：替换空格 151.翻转字符串里的单词 反转题目 这类题目涉及到对于字符串的翻转操作，按照要求完成一部分翻转或者是某个区间的翻转。 例题： 541. 反转字符串II 151.翻转字符串里的单词 剑指Offer58-II.左旋转字符串 KMP 两个字符串进行匹配，思想是匹配过程中出现不相同字符时，使用预先计算好的内容，避免从头开始重新进行匹配。 例题： 28.实现 strStr() 459.重复的子字符串 双指针回顾 双指针主要是用于将暴力法（通常情况下）的\\(O(n^2)\\)的时间复杂度给降低下来，使用两个指针在一个for循环下完成两个嵌套for循环的工作。 字符串 主要涉及原地翻转，去除给定字符操作。（其实在数组里也是这些） 例题： 344.反转字符串 剑指Offer 05.替换空格 151.翻转字符串里的单词 链表 还是反转，反转链表；以及环形结构的问题。 例题： 206.反转链表 142.环形链表II N数之和 例题： 15.三数之和 18.四数之和","link":"/2023/02/23/algorithm-train-day9/"},{"title":"11.1 迁移学习【斯坦福21秋季：实用机器学习中文版】","text":"本节课程课件： 课件 自己做的思维导图： 导图 迁移学习的出发点 - 在一个任务上学习到的知识，可以在另外一个地方用到 因为训练要花钱，还要搞数据集 途径 训练好的模型做成特征抽取的模块，得到特征干别的事情，比如作为另外一个模型的输入 在相关的任务上训练一个模型，在另外一个任务上直接用，例如GPT系列 在训练好的模型上，针对新的任务进行微调（本节内容） 相关领域 半监督学习 极端情况下，新的任务，不给标记；或者只给几张有标记 多任务学习，每一个任务都有自己的数据但不是很够，但任务之间又有相关性 转移知识 - 有很多大规模的标好的数据集，尤其是图片分类任务上（因为标记很容易） 计算机视觉的迁移学习里面，存在很多效果比较好的模型，希望把这些模型的知识拓展到自己的任务上去 刚开始进行任务的时候可能不会投入太多，看能不能利用别人在标记好的、比自己的数据集大10倍，100倍的数据集上面学到的一些东西迁移过来，试试效果 预训练模型 - 用的最多的迁移学习的方法 一般来说，一个神经网络大概分为两块 编码器 可以认为是特征提取器 将像素转化为在语义空间里面线性可分的一些特征（浅表示） 解码器 可能就是个线性层 把编码器的输出映射为最终结果，做决策 例如 给个猫的图片 可以认为除了最后一层之外的，都是编码器 最后一层把语义特征（如1024的特征向量），转化为语义空间内的表示 也可以认为最后几层都是解码器，剩下的是编码器 预训练模型 在比较大的数据集上训练好的一个模型 训练的数据集大，可以认为其有一定的泛化能力 泛化能力指，放到别的任务或者数据集上，多多少少也是能帮点忙 虽然目标任务可能不会对猫感兴趣，但是编码器部分多多少少学会了点怎么样去处理像素的信息 在ImageNet上训练的模型，能对其他任务的图片做特征提取，总比从随机开始好 Fine-Tune技巧 - 通常认为，在深度学习中微调能够带来最好的效果 在新的任务上面，构建一个新的模型，其架构要与预训练模型一样 如一个在ImageNet上训练好的ResNet 50模型 在新的任务上面，也要用一个ResNet 50模型（可以先找找在当前任务的特定架构上是不是有比较好的预训练模型） 初始化模型 新模型的特征提取器（编码器）的权重直接从预训练模型得到 解码器的权重随机初始化 不同任务的语义空间不同 例如图中右侧的例子 在限制搜索空间，进行训练 因为之前效果已经比较好了，已经在最优解附近了 要把学习率调的小 例如正常是0.1，现在要用1e-3 epoch数要小 例如 不做特别的限制的话，不管是fine-tune还是随机初始化整个网络，在足够长的时间下，网络都会达到一个特定的程度，但这个程度并非是最佳状态 泛化误差和训练误差是不一样的 在数据集不大且网络足够复杂的情况下，网络是可以记住整个数据集的 训练误差最低的时候，泛化误差不一定更好 在完全拟合自己的数据和保留在大数据集上的泛化能力之间，做一个权衡 冻结底层网络 - 限制搜索空间的另一种方法 因为神经网络有个比较层次化的学习过程 在最底层学到一些底层的特征的表示，像素底层特征，学习到的纹理是什么形状、颜色的知识 如一个圆圈，图形的边 层数越来越高的时候，多多少少会学到一些更大，更全局的东西，更加跟语义相关 最下面的层在微调的时候不动 例如第0层学习率为0，第1层为1e-8，第二层为1e-7 通常做法，固定住最下面一些层，往上面一些层学习率为1e-3，再往上是1e-1 需要固定多少层是需要调的 若目标任务和预训练模型之间差比较大的话，需要多训练一些层 差异小的话，可以固定更多层，极端情况下甚至可以只允许最后一层进行训练 在哪儿找与训练模型 - 在微调的时候怎么样找到一个与训练模型，很重要 首先有没有 例如要注重latency的话，找个训练好的MobileNet 其次是考虑在什么样的大数据集上 例如是在ImageNet上训练好的 各种各样的Hub Timm的Hub Fine-Tune应用 - 使用在大数据集预训练好的模型，Fine-Tune到自己的任务上，是过去七八年至现在，在CV方面都是一个主流方法 - 目标检测/分割----图片相似但目标不同 - 医学/卫星图像识别----任务相同但图像不同 微调加速了收敛 开始的点不是随机初始化的点，而是比较靠近目标的点 不一定提升精度 预训练的数据集和目标数据集比较像的时候，一般结果会比只在目标数据集上训练好 有时候直接在目标数据集上训练时也会得到一个相似的结果，特别是在目标数据集比较大的情况下 通常不会让精度变得更低，So why not? 总结 - 通常会在比较大的数据集上训练预训练好的模型 在新的任务上，初始化一个编码器部分的权重和预训练模型权重一样的模型，解码器权重随机初始化 微调通常来说加速收敛，有时会提升精度，但不会使得精度变差","link":"/2022/07/23/cs329p-slides-transfer-learning/"},{"title":"剑指 Offer 47. 礼物的最大价值","text":"题目 LeetCode-链接直达 给定一个二维数组, 每一步只能向下或向右移动, 求在从二维数组的\\([0][0]\\)位移动到\\([m-1][n-1]\\)的过程中, 经过位置的值之和的最大值. 自己的想法 自己的想法 X 看了别人的想法之后自己的理解 √ 一个递推方程, 如果要保证走到最后的值最大, 则需要每一步都是最大的. \\begin{equation} dp(i, j) = \\begin{cases} grid(i, j), &amp; i = 0, j = 0 \\\\ grid(i, j) + dp(i, j - 1), &amp; i = 0, j \\neq 0 \\\\ grid(i, j) + dp(i - 1, j), &amp; i \\neq 0, j = 0 \\\\ grid(i, j) + \\max(dp(i - 1, j), dp(i, j - 1)), &amp; i \\neq 0,j \\neq 0 \\end{cases} \\end{equation} 其实就是递归地把整个二维数组中从开始到每个位置的路过值之和的最大值求出来, 是贪心还是动态规划啊. 自己再遇到这种问题的时候可以想一下有没有什么递推公式可以用来解决这个问题, 数学归纳法. 题解 根据上面的方程, 写出对应的代码还是不难的. class Solution { public: int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n)); for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (i == 0 &amp;&amp; j == 0) dp[i][j] = grid[i][j]; else if (i == 0 &amp;&amp; j != 0) dp[i][j] = dp[i][j - 1] + grid[i][j]; else if (i != 0 &amp;&amp; j == 0) dp[i][j] = dp[i - 1][j] + grid[i][j]; else dp[i][j] = grid[i][j] + max(dp[i - 1][j], dp[i][j - 1]); } } return dp[m - 1][n - 1]; } }; 时间复杂度为\\(O(mn)\\), 空间复杂度为\\(O(mn)\\). 由于整个遍历过程是从上往下从左至右一行一行遍历的, 其实也可以在原数组上进行计算, 这样空间复杂度就只有\\(O(1)\\)了. class Solution { public: int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (i == 0 &amp;&amp; j == 0) grid[i][j] = grid[i][j]; else if (i == 0 &amp;&amp; j != 0) grid[i][j] = grid[i][j - 1] + grid[i][j]; else if (i != 0 &amp;&amp; j == 0) grid[i][j] = grid[i - 1][j] + grid[i][j]; else grid[i][j] = grid[i][j] + max(grid[i - 1][j], grid[i][j - 1]); } } return grid[m - 1][n - 1]; } };","link":"/2023/03/03/leetcode-max-gift-sum/"},{"title":"macOS 10.15 ”app已损坏，无法打开“ 解决方法","text":"问题表现 安装了网上下载来的破解软件（大写加粗的穷）后，双击发现 不！能！用！还提示你扔到垃圾桶。 因为实在莫得钱去买软件，只能去找解决方案 # 命令行处理 将下载到的App拖入应用程序后，打开终端（iTerm等都可以），输入以下命令： $ sudo xattr -rd com.apple.quarantine 输入完先不要按下Enter，打开finder到应用程序那里，找到你下载的破解App，将其拖入到终端内。会变成类似于下面的 $ sudo xattr -rd com.apple.quarantine /Applications/xxx.app 其中xxx是你要用的软件的名字。这个时候按下回车，并输入当前用户的密码（输入密码的时候是看不见的，直接输就好），按下回车。 再打开就好了。","link":"/2019/12/18/mac-catalina-damaged-app/"},{"title":"Mac下Clion的OpenGL环境配置","text":"Mac下Clion的OpenGL环境配置 安装glfw/glew $ brew install glew $ brew install glfw 对工程内CMakeLists.txt进行更改： cmake_minimum_required(VERSION 3.14) project(XXX) set(CMAKE_CXX_STANDARD 11) # 添加头文件 set(GLEW_H /usr/local/Cellar/glew/2.1.0/include/GL) set(GLFW_H /usr/local/Cellar/glfw/3.2.1/include/GLFW) include_directories(${GLEW_H} ${GLFW_H}) # 添加目标链接 set(GLEW_LINK /usr/local/Cellar/glew/2.1.0/lib/libGLEW.2.1.dylib) set(GLFW_LINK /usr/local/Cellar/glfw/3.2.1/lib/libglfw.3.dylib) link_libraries(${OPENGL} ${GLEW_LINK} ${GLFW_LINK}) # 执行编译命令 set(SOURCE_FILES main.cpp) add_executable(XXX ${SOURCE_FILES}) if (APPLE) target_link_libraries(XXX \"-framework OpenGL\") target_link_libraries(XXX \"-framework GLUT\") endif() 将上方的XXX改为自己的工程名称即可","link":"/2019/05/28/mac-clion-opengl/"},{"title":"Mac手动切换显卡","text":"手动切换Mac 显卡 主力电脑是一台15年的MacBook Pro 15寸顶配，有的时候，某些程序在运行时系统会把图形卡模式自动调整为高性能，就觉得对性能有影响，想手动切换。 系统自带的切换只能选择自动和独显，所以要使用其他方法 ### 终端切换 强制使用核显(集成显卡) $ sudo pmset -a GPUSwitch 0 强制使用独立显卡 $ sudo pmset -a GPUSwitch 1 自动切换 $ sudo pmset -a GPUSwitch 2 查看是否切换成功 $ pmset -g 使用第三方软件 Homebrew 安装 gfxCardStatus $ brew cask install gfxCardStatus","link":"/2019/05/27/mac-select-gpu/"},{"title":"微信小程序云开发数据库联表查找","text":"需求分析 现在有以下集合 orders集合： [ {\"_id\":4,\"book\":\"novel 1\",\"price\":30,\"quantity\":2}, {\"_id\":5,\"book\":\"science 1\",\"price\":20,\"quantity\":1}, {\"_id\":6} ] books集合： [ {\"_id\":\"book1\",\"author\":\"author 1\",\"category\":\"novel\",\"stock\":10,\"time\":1564456048486,\"title\":\"novel 1\"}, {\"_id\":\"book3\",\"author\":\"author 3\",\"category\":\"science\",\"stock\":30,\"title\":\"science 1\"}, {\"_id\":\"book4\",\"author\":\"author 3\",\"category\":\"science\",\"stock\":40,\"title\":\"science 2\"}, {\"_id\":\"book2\",\"author\":\"author 2\",\"category\":\"novel\",\"stock\":20,\"title\":\"novel 2\"}, {\"_id\":\"book5\",\"author\":\"author 4\",\"category\":\"science\",\"stock\":50,\"title\":null}, {\"_id\":\"book6\",\"author\":\"author 5\",\"category\":\"novel\",\"stock\":\"60\"} ] 要求进行联表查询，返回结果，匹配字段为orders的book字段和books的title字段 # 代码 const db = cloud.database() db.collection('orders').aggregate() .lookup({ from: 'books', localField: 'book', foreignField: 'title', as: 'bookList', }) .end() .then(res => console.log(res)) .catch(err => console.error(err)) 得到的结果为： [ { \"_id\": 4, \"book\": \"novel 1\", \"price\": 30, \"quantity\": 2, \"bookList\": [ { \"_id\": \"book1\", \"title\": \"novel 1\", \"author\": \"author 1\", \"category\": \"novel\", \"stock\": 10 } ] }, { \"_id\": 5, \"book\": \"science 1\", \"price\": 20, \"quantity\": 1, \"bookList\": [ { \"_id\": \"book3\", \"category\": \"science\", \"title\": \"science 1\", \"author\": \"author 3\", \"stock\": 30 } ] }, { \"_id\": 6, \"bookList\": [ { \"_id\": \"book5\", \"category\": \"science\", \"author\": \"author 4\", \"stock\": 50, \"title\": null }, { \"_id\": \"book6\", \"author\": \"author 5\", \"stock\": \"60\", \"category\": \"novel\" } ] } ] HINT：其中localField字段和foreignField字段，其中一个可以指定为Array。 改进 上面的代码里会生成一个新的字段bookList，若要将查询结果直接并入上一级，可有： var db = cloud.database() var $ = db.command.aggregate db.collection('orders').aggregate() .lookup({ from: \"books\", localField: \"book\", foreignField: \"title\", as: \"bookList\" }) .replaceRoot({ newRoot: $.mergeObjects([ $.arrayElemAt(['$bookList', 0]), '$$ROOT' ]) }) .project({ bookList: 0 }) .end() .then(res => console.log(res)) .catch(err => console.error(err)) 其中replaceRoot指定的是新生成的数据有哪些字段，必须传入newRoot参数 project指定要保留哪些字段，0为不保留，1为保留 引用 微信官方文档·小程序","link":"/2020/03/12/miniapp-lookup/"},{"title":"腾讯云SCF云函数部署OneDrive共享盘","text":"更新 更新于2022年7月 腾讯云SCF大幅削减了免费额度，请事先查阅收费标准再决定是否使用。 前情提要 申请了Office365技术社区成员，通过后获得了一个Office 365 E3的账号，其中包含1T容量的OneDrive for business世纪互联版。物要尽其用，用这个搭一个网盘。 &gt; OneDrive for business下的文件，组织的管理员可以查看，私人文件请放OneDrive个人版 教育邮箱白嫖的1T空间需要有管理员才可以继续搭建 # 准备工作 + 自己腾讯云账户SecretID和SecretKey + SCF函数文件 点击去Github 新建云函数 点击去云函数控制台 新建一个云函数，选择自己想要的区域，新建函数，运行环境选择Php 7.2，选择空白模板，下一步 OneDrive个人版选择内地区域可能会有问题，建议选择中国香港 拉到下方高级配置，你刚才选择的区域Region官方对应列表 点击完成 上传代码文件 返回到函数列表，点击函数，选择函数代码，更改提交方法，把解压缩的代码传上去，保存 添加触发方式 在触发方式内添加触发方式，选择API网关触发方式，将启用集成响应打钩，其余默认即可 获得访问路径 配置网盘参数 访问上一步内获得的链接 填写之前获得的SecretKey和SecretID，设置密码，确认 稍等会跳转到首页，点击左上角的管理，添加Onedrive盘 选择自己对应的版本： 怎么样选择自己的版本： 在浏览器里打开OneDrive的文件目录的首页，看地址栏的域名 域名 版本 onedrive.live.com 个人版 *****.sharepoint.cn 商业世纪互联版 *****.sharepoint.com 商业国际版 这里我用的是世纪互联版，选第二个 确认后会调到授权界面，授权即可 稍等即可跳转到首页 完善体验 网盘配置 在云函数环境变量处可以添加以下值（说明来自开发者）： 变量名 说明 sitename 网站的名称，不添加会显示为‘请在环境变量添加sitename’。 admin 管理密码，不添加时不显示登录页面且无法登录。 adminloginpage 管理登录的页面不再是'?admin'，而是此设置的值。如果设置，登录按钮及页面隐藏。 public_path 使用API长链接访问时，显示网盘文件的路径，不设置时默认为根目录；不能是private_path的上级（public看到的不能比private多，要么看到的就不一样）。 private_path 使用自定义域名访问时，显示网盘文件的路径，不设置时默认为根目录。 domain_path 格式为\"a1.com:/dir/path1|b1.com:/path2\"，比private_path优先。 imgup_path 设置图床路径，不设置这个值时该目录内容会正常列文件出来，设置后只有上传界面，不显示其中文件（登录后显示）。 passfile 自定义密码文件的名字，可以是'pppppp'，也可以是'aaaa.txt'等等；密码是这个文件的内容，可以空格、可以中文；列目录时不会显示，只有知道密码才能查看或下载此文件。 自定义域名 触发方式下选择API服务名 在自定义域名下选择新建 填写域名，路径映射选择自定义，填/，环境选择发布 如果没有证书的话，可以去控制台免费申请证书 点击提交前，请先将自定义的域名用CNAME方式指向图中的公网二级域名 在管理API下，点击编辑 路径改为/ 下一步 勾选是否启用响应集成 下一步 返回类型选择HTML 完成，点击前往发布服务 点击发布 写点备注，提交 部署完成 已经可以用来访问了","link":"/2020/03/12/scf-onedrive/"},{"title":"基于Wechaty的群学习内容推送工具","text":"Author: @GilesWong Code: @GilesWong/wechaty-xiaowang 功能 定时采集英语的每日一题，推送到群里 早晨问好，同时发送当天天气预报，每半天检查一次未来 24 小时内设定的经纬度处是否有降水。 采集网站上的新闻早报，补充时政知识 发送每日一句 图灵机器人对话 （来源于第三方的数据仅供学习之用，请经常访问这些优质网站） ## 特点 使用腾讯云云函数进行定时获取信息的操作，减少了服务器上的配置难度 使用 Node.js Express 对 Wechaty 进行了封装，后续功能可以本地写好 python 或 nodejs 云函数后，直接部署在腾讯云上，不用调整服务器 使用 pm2 进行 wechaty 运行状态的维持（后续可以考虑改为使用无服务器的环境，比如 Leancloud、Heroku 容器等，减少服务器的开支） 功能示例 项目结构 |-- wechaty-xiaowang |-- index.js //主程序 |-- package-lock.json |-- package.json |-- puppet-config.js //pupet参数 |-- serverchan.js //通过方糖报告错误 |-- tulingbot.js //图灵机器人 |-- cloudFunctions // 运行在腾讯云上的云函数爬虫 |-- dailyEnglishTest //英语每日一题 |-- dailySentence //英语每日一句 |-- moringNews //每日早报 |-- rainDetection //降雨提醒 |-- weatherTip //早晨问好，及天气预报 架构说明 服务器端 Express + Wechaty 开放一个 HTTP 接口用于访问，传入 HTTP 接口的内容会被发送到预先指定的群内 云函数端 定时获取信息，并通过 HTTP 调用发送给 Wechaty 机器人 使用 wechaty 的部署 填写代码中的配置，如Token，服务器地址、端口等 上传至服务器 在其目录下，获取所有用到的 NPM 包 npm i 使用node index.js命令，启动wechaty，并扫码登录 （可选）调试好之后，可选择使用pm2等工具维持wechaty的运行 （可选）使用Nginx的反向代理功能来实现HTTPS，增强安全性 （可选）使用cloudflare的防火墙规则或者Nginx，来将访问权限限制到特定的范围，增强安全性 云函数的部署 打开 https://console.cloud.tencent.com/scf/index 注册并新建云函数 新建时选择空白函数即可,然后选择目前要增加的函数的环境，之后点击下一步 Python 3.6 Node.js 12.16 在提交方法处，选择上传文件夹 选择当前增加的函数的文件夹，上传即可 新建完成后，返回云函数主页面，点击函数服务- 触发管理 弹出的创建触发器的页面内，选择自定义触发，填入Cron表达式 Cron表达式用法见：https://cloud.tencent.com/document/product/583/9708#cron-.E8.A1.A8.E8.BE.BE.E5.BC.8F 完成 对于每日新闻的代码，其运行于Coding的定时构建计划内，详见：https://help.coding.net/docs/devops/ci/trigger.html 致谢 JUZI Bot提供的Token，使这个小项目具有可行性 Wechaty (非常优秀的项目) 腾讯云（提供了几乎免费的云函数） Coding（提供了免费使用的构建计划的主机） ```","link":"/2020/08/24/wechaty/"}],"tags":[{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"代码随想录","slug":"代码随想录","link":"/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"},{"name":"Transfer Learning","slug":"Transfer-Learning","link":"/tags/Transfer-Learning/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"Clion","slug":"Clion","link":"/tags/Clion/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Serverless","slug":"Serverless","link":"/tags/Serverless/"},{"name":"Onedrive","slug":"Onedrive","link":"/tags/Onedrive/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"}],"categories":[],"pages":[]}